This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
build.gradle
src/main/java/io/github/game/Background.java
src/main/java/io/github/game/editor/AddEnemyCommand.java
src/main/java/io/github/game/editor/AddPlatformCommand.java
src/main/java/io/github/game/editor/AddPowerupCommand.java
src/main/java/io/github/game/editor/ClearLevelCommand.java
src/main/java/io/github/game/editor/EditorCommand.java
src/main/java/io/github/game/editor/RemoveEnemyCommand.java
src/main/java/io/github/game/editor/RemovePlatformCommand.java
src/main/java/io/github/game/editor/RemovePowerupCommand.java
src/main/java/io/github/game/enemies/Enemy.java
src/main/java/io/github/game/enemies/EnemyType.java
src/main/java/io/github/game/enemies/Goomba.java
src/main/java/io/github/game/enemies/Koopa.java
src/main/java/io/github/game/GameStateManager.java
src/main/java/io/github/game/GoalPost.java
src/main/java/io/github/game/Level.java
src/main/java/io/github/game/LevelEditor.java
src/main/java/io/github/game/Main.gwt.xml
src/main/java/io/github/game/Main.java
src/main/java/io/github/game/Platform.java
src/main/java/io/github/game/Player.java
src/main/java/io/github/game/Powerup.java
src/main/java/io/github/game/SoundManager.java
src/main/java/io/github/game/WorldMap.java
src/main/java/io/github/game/WorldMapConfig.java
src/main/java/io/github/game/WorldMapNode.java

================================================================
Files
================================================================

================
File: build.gradle
================
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
eclipse.project.name = appName + '-core'

dependencies {
  api "com.badlogicgames.gdx:gdx:$gdxVersion"
  api "com.crashinvaders.basisu:basisu-gdx:$gdxBasisUniversalVersion"
  api "com.crashinvaders.basisu:basisu-wrapper:$gdxBasisUniversalVersion"
  api "com.github.crykn:kryonet:$kryoNetVersion"

  if(enableGraalNative == 'true') {
    implementation "io.github.berstanio:gdx-svmhelper-annotations:$graalHelperVersion"
  }
}

================
File: src/main/java/io/github/game/Background.java
================
// File: core/src/main/java/io/github/game/Background.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;

public class Background {

    private Texture backgroundTexture;
    private String currentTexturePath;
    private float textureWidth;
    private float textureHeight;
    private float scrollSpeed = 0.5f; // Default scroll speed

    public static final String DEFAULT_BACKGROUND_PATH = "mario_sprites/backgrounds/background_0.png";

    public Background() {
        setTexture(DEFAULT_BACKGROUND_PATH);
    }

    public Background(String texturePath) {
        setTexture(texturePath);
    }

    public void setTexture(String texturePath) {
        if (texturePath == null || texturePath.isEmpty()) {
            Gdx.app.error("Background", "Texture path is null or empty. Using default: " + DEFAULT_BACKGROUND_PATH);
            texturePath = DEFAULT_BACKGROUND_PATH;
        }

        if (this.currentTexturePath != null && this.currentTexturePath.equals(texturePath) && backgroundTexture != null) {
            return; // Texture is already loaded and is the same
        }

        try {
            if (backgroundTexture != null) {
                backgroundTexture.dispose(); // Dispose old texture
            }
            Gdx.app.log("Background", "Attempting to load background: " + texturePath);
            backgroundTexture = new Texture(Gdx.files.internal(texturePath));
            this.currentTexturePath = texturePath;
            textureWidth = backgroundTexture.getWidth();
            textureHeight = backgroundTexture.getHeight();
            Gdx.app.log("Background", "Successfully loaded new background: " + texturePath + " (Width: " + textureWidth + ", Height: " + textureHeight + ")");
        } catch (Exception e) {
            Gdx.app.error("Background", "Failed to load background texture: " + texturePath, e);
            // Attempt to load a fallback if the primary one fails and it wasn't the default already
            if (!texturePath.equals(DEFAULT_BACKGROUND_PATH)) {
                Gdx.app.error("Background", "Falling back to default background due to previous error.");
                setTexture(DEFAULT_BACKGROUND_PATH); // Recursive call to load default
            } else {
                // If default also fails, then we have a bigger issue, or it's missing
                Gdx.app.error("Background", "Default background also failed to load. Background will be blank.");
                if (backgroundTexture != null) backgroundTexture.dispose();
                backgroundTexture = null; // Prevent NPEs in render
                this.currentTexturePath = null;
                textureWidth = 0; // Reset dimensions
                textureHeight = 0;
            }
        }
    }


    public void update(float deltaTime) {
        // This method can be used for future background animations or effects.
        // For parallax scrolling based on camera, all logic is in render().
    }

    public void render(SpriteBatch batch, OrthographicCamera camera) {
        if (backgroundTexture == null || textureWidth == 0) { // Don't render if texture failed to load or has no width
            return;
        }

        float cameraViewLeft = camera.position.x - camera.viewportWidth * camera.zoom / 2f;
        float cameraViewRight = camera.position.x + camera.viewportWidth * camera.zoom / 2f;

        float parallaxOffset = camera.position.x * scrollSpeed;

        // Ensure the loop condition handles cases where textureWidth might be zero to prevent infinite loops.
        // The condition textureWidth == 0 is checked at the beginning.
        for (float x = (float)Math.floor((cameraViewLeft - parallaxOffset) / textureWidth) * textureWidth + parallaxOffset; // Adjusted logic slightly
             x < cameraViewRight;
             x += textureWidth) {
            // Draw the background from y=0 up to camera.viewportHeight or level height.
            // For simplicity, drawing at y=0 with its original height.
            // If viewportHeight is desired, texture scaling or tiling vertically would be needed if textureHeight < viewportHeight.
            batch.draw(backgroundTexture, x, 0, textureWidth, textureHeight);
        }
    }

    public void dispose() {
        if (backgroundTexture != null) {
            backgroundTexture.dispose();
            backgroundTexture = null;
        }
    }
}

================
File: src/main/java/io/github/game/editor/AddEnemyCommand.java
================
package io.github.game.editor;

import io.github.game.Level;

public class AddEnemyCommand implements EditorCommand {
    private Level level;
    private Level.EnemyData enemyData;

    public AddEnemyCommand(Level level, Level.EnemyData enemyData) {
        this.level = level;
        this.enemyData = enemyData;
    }

    @Override
    public void execute() {
        level.addEnemy(enemyData);
    }

    @Override
    public void undo() {
        level.removeEnemy(enemyData);
    }
}

================
File: src/main/java/io/github/game/editor/AddPlatformCommand.java
================
// File: core/src/main/java/io/github/game/editor/AddPlatformCommand.java
package io.github.game.editor;

import io.github.game.Level;
import io.github.game.Level.PlatformData; // If PlatformData is public inner class

public class AddPlatformCommand implements EditorCommand {
    private Level level;
    private PlatformData platformData;

    public AddPlatformCommand(Level level, PlatformData platformData) {
        this.level = level;
        this.platformData = platformData;
    }

    @Override
    public void execute() {
        level.addPlatform(platformData);
    }

    @Override
    public void undo() {
        level.removePlatform(platformData); // Assumes Level.removePlatform can remove by instance
    }
}

================
File: src/main/java/io/github/game/editor/AddPowerupCommand.java
================
package io.github.game.editor;

import io.github.game.Level;

public class AddPowerupCommand implements EditorCommand {
    private Level level;
    private Level.PowerupData powerupData;

    public AddPowerupCommand(Level level, Level.PowerupData powerupData) {
        this.level = level;
        this.powerupData = powerupData;
    }

    @Override
    public void execute() {
        level.addPowerup(powerupData);
    }

    @Override
    public void undo() {
        level.removePowerup(powerupData);
    }
}

================
File: src/main/java/io/github/game/editor/ClearLevelCommand.java
================
// File: core/src/main/java/io/github/game/editor/ClearLevelCommand.java
package io.github.game.editor;

import com.badlogic.gdx.utils.Array;
import io.github.game.Level;
import io.github.game.Level.PlatformData;

public class ClearLevelCommand implements EditorCommand {
    private Level level;
    private Array<PlatformData> originalPlatforms;
    private PlatformData defaultGroundAdded; // The specific instance of default ground added

    public ClearLevelCommand(Level level, Array<PlatformData> platformsBeforeClear, PlatformData defaultGroundInstance) {
        this.level = level;
        this.originalPlatforms = new Array<>(platformsBeforeClear); // Store a copy of the state before clear
        this.defaultGroundAdded = defaultGroundInstance;
    }

    @Override
    public void execute() {
        level.getPlatformData().clear();
        if (defaultGroundAdded != null) {
            level.addPlatform(defaultGroundAdded); // Add the specific instance
        }
    }

    @Override
    public void undo() {
        level.getPlatformData().clear();
        level.getPlatformData().addAll(originalPlatforms);
    }
}

================
File: src/main/java/io/github/game/editor/EditorCommand.java
================
// File: core/src/main/java/io/github/game/editor/EditorCommand.java
package io.github.game.editor;

public interface EditorCommand {
    void execute();
    void undo();
}

================
File: src/main/java/io/github/game/editor/RemoveEnemyCommand.java
================
// File: core/src/main/java/io/github/game/editor/RemoveEnemyCommand.java
package io.github.game.editor;

import io.github.game.Level;

public class RemoveEnemyCommand implements EditorCommand {
    private Level level;
    private Level.EnemyData enemyData;
    // private int originalIndex = -1; // Optional for restoring order

    public RemoveEnemyCommand(Level level, Level.EnemyData enemyData) {
        this.level = level;
        this.enemyData = enemyData;
        // this.originalIndex = level.getEnemyData().indexOf(enemyData, true);
    }

    @Override
    public void execute() {
        level.removeEnemy(enemyData);
    }

    @Override
    public void undo() {
        // if (originalIndex != -1 && originalIndex < level.getEnemyData().size) {
        //    level.getEnemyData().insert(originalIndex, enemyData);
        // } else {
        level.addEnemy(enemyData); // Adds to the end if index not used
        // }
    }
}

================
File: src/main/java/io/github/game/editor/RemovePlatformCommand.java
================
// File: core/src/main/java/io/github/game/editor/RemovePlatformCommand.java
package io.github.game.editor;

import io.github.game.Level;
import io.github.game.Level.PlatformData;
import com.badlogic.gdx.utils.Array; // For storing index if needed

public class RemovePlatformCommand implements EditorCommand {
    private Level level;
    private PlatformData platformData;
    private int originalIndex = -1; // Optional: for restoring exact order

    public RemovePlatformCommand(Level level, PlatformData platformData) {
        this.level = level;
        this.platformData = platformData;
        // To store originalIndex, you'd find it before removing:
        // this.originalIndex = level.getPlatformData().indexOf(platformData, true);
    }

    @Override
    public void execute() {
        // If originalIndex was stored, ensure it's still valid or re-find before removal.
        // For simplicity, we assume Level.removePlatform works by instance.
        level.removePlatform(platformData);
    }

    @Override
    public void undo() {
        // if (originalIndex != -1 && originalIndex < level.getPlatformData().size) {
        //    level.getPlatformData().insert(originalIndex, platformData);
        // } else {
        level.addPlatform(platformData); // Adds to the end if index not used
        // }
    }
}

================
File: src/main/java/io/github/game/editor/RemovePowerupCommand.java
================
package io.github.game.editor;

import io.github.game.Level;

public class RemovePowerupCommand implements EditorCommand {
    private Level level;
    private Level.PowerupData powerupData;

    public RemovePowerupCommand(Level level, Level.PowerupData powerupData) {
        this.level = level;
        this.powerupData = powerupData;
    }

    @Override
    public void execute() {
        level.removePowerup(powerupData);
    }

    @Override
    public void undo() {
        level.addPowerup(powerupData);
    }
}

================
File: src/main/java/io/github/game/enemies/Enemy.java
================
// File: core/src/main/java/io/github/game/enemies/Enemy.java
package io.github.game.enemies;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
// Remove TextureAtlas import if not used by any direct Enemy subclass that NEEDS an atlas
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Disposable;
import io.github.game.Platform;
import io.github.game.Player;

public abstract class Enemy implements Disposable {
    public enum EnemyState {
        WALKING,
        STOMPED,
        DEAD
    }

    protected Vector2 position;
    protected Vector2 velocity;
    protected Rectangle bounds;
    protected boolean isAlive;
    protected boolean facingRight;
    protected float stateTimer;
    protected EnemyState currentState;
    // Removed: protected TextureAtlas enemyAtlas;

    public static final float GRAVITY = -900f;

    // Modified Constructor: No longer takes TextureAtlas
    public Enemy(float x, float y, float width, float height) {
        this.position = new Vector2(x, y);
        this.velocity = new Vector2(0, 0);
        this.bounds = new Rectangle(x, y, width, height);
        this.isAlive = true;
        this.facingRight = false;
        this.stateTimer = 0f;
        this.currentState = EnemyState.WALKING;
    }

    public void update(float deltaTime, Array<Platform> platforms, Player player) {
        if (!isAlive && currentState != EnemyState.STOMPED) return;

        stateTimer += deltaTime;
        updateLogic(deltaTime, platforms, player);

        if (currentState == EnemyState.WALKING) {
            velocity.y += GRAVITY * deltaTime;
        }

        position.x += velocity.x * deltaTime;
        bounds.setX(position.x);
        checkHorizontalPlatformCollisions(platforms);

        position.y += velocity.y * deltaTime;
        bounds.setY(position.y);
        checkVerticalPlatformCollisions(platforms);

        if (position.y < -bounds.height * 2) {
            isAlive = false;
            currentState = EnemyState.DEAD;
        }
    }

    protected abstract void updateLogic(float deltaTime, Array<Platform> platforms, Player player);
    public abstract void render(SpriteBatch batch);
    public abstract void onStompedBy(Player player);
    public abstract boolean onCollisionWith(Player player);

    protected void checkHorizontalPlatformCollisions(Array<Platform> platforms) {
        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue;
            if (bounds.overlaps(platform.getBounds())) {
                if (velocity.x > 0) {
                    position.x = platform.getBounds().x - bounds.width;
                    velocity.x = -Math.abs(velocity.x);
                    facingRight = false;
                } else if (velocity.x < 0) {
                    position.x = platform.getBounds().x + platform.getBounds().width;
                    velocity.x = Math.abs(velocity.x);
                    facingRight = true;
                }
                bounds.setX(position.x);
            }
        }
    }

    protected void checkVerticalPlatformCollisions(Array<Platform> platforms) {
        boolean grounded = false;
        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue;
            if (bounds.overlaps(platform.getBounds())) {
                if (velocity.y <= 0 && position.y + bounds.height * 0.5f >= platform.getBounds().y + platform.getBounds().height) {
                    position.y = platform.getBounds().y + platform.getBounds().height;
                    velocity.y = 0;
                    grounded = true;
                } else if (velocity.y > 0 && position.y < platform.getBounds().y) {
                    position.y = platform.getBounds().y - bounds.height;
                    velocity.y = 0;
                }
                bounds.setY(position.y);
            }
        }
        if (currentState == EnemyState.WALKING && grounded) {
            // Simplified edge detection - if moving and no ground directly ahead and below, turn.
            // This requires careful implementation of "ahead and below".
            // For now, turning is primarily handled by hitting walls or more explicit edge detection in Goomba.
        }
    }

    public Rectangle getBounds() { return bounds; }
    public boolean isAlive() { return isAlive; }
    public Vector2 getPosition() { return position; }
    public Vector2 getVelocity() { return velocity; }
    public EnemyState getCurrentState() { return currentState; }

    @Override
    public void dispose() {
        // Subclasses responsible for disposing their own textures if they own them.
        // If textures are passed in and shared, Main/LevelEditor disposes them.
    }
}

================
File: src/main/java/io/github/game/enemies/EnemyType.java
================
// File: core/src/main/java/io/github/game/enemies/EnemyType.java
package io.github.game.enemies;

public enum EnemyType {
    GOOMBA("Goomba"),
    KOOPA("Koopa Troopa"); // NEW: Added Koopa Troopa
    // Add other enemy types here in the future, e.g., KOOPA_TROOPA

    private final String displayName;

    EnemyType(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }

    @Override
    public String toString() {
        return displayName;
    }
}

================
File: src/main/java/io/github/game/enemies/Goomba.java
================
// File: core/src/main/java/io/github/game/enemies/Goomba.java
package io.github.game.enemies;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.Array;
import io.github.game.Platform;
import io.github.game.Player;
import io.github.game.SoundManager; // Make sure SoundManager is accessible

public class Goomba extends Enemy {
    public static final float WIDTH = 32f;
    public static final float HEIGHT = 32f;
    private static final float COLLISION_WIDTH = 28f;
    private static final float COLLISION_HEIGHT = 28f;
    private static final float SPEED = 40f; // Slightly slower for more classic feel
    private static final float STOMP_DURATION = 0.5f;

    private Animation<TextureRegion> walkAnimation;
    private TextureRegion squashedTextureRegion; // Changed from Texture to TextureRegion

    // Modified Constructor to take Textures (or TextureRegions)
    public Goomba(Texture walkFrame1Tex, Texture walkFrame2Tex, Texture squashedTex, float x, float y) {
        super(x, y, COLLISION_WIDTH, COLLISION_HEIGHT); // Enemy constructor sets facingRight = false by default

        Array<TextureRegion> frames = new Array<>();
        frames.add(new TextureRegion(walkFrame1Tex));
        frames.add(new TextureRegion(walkFrame2Tex));
        walkAnimation = new Animation<>(0.25f, frames, Animation.PlayMode.LOOP); // Slower animation

        this.squashedTextureRegion = new TextureRegion(squashedTex);
        // If squashedTex is just one of the walk frames, it's fine.
        // Example: if no specific squashed sprite, use walkFrame1Tex for squashedTextureRegion

        // Initial velocity: Enemy.facingRight is false by default, so Goomba starts moving left.
        velocity.x = facingRight ? SPEED : -SPEED;
    }

    @Override
    protected void updateLogic(float deltaTime, Array<Platform> platforms, Player player) {
        if (currentState == EnemyState.STOMPED) {
            velocity.x = 0;
            if (stateTimer > STOMP_DURATION) {
                isAlive = false;
                currentState = EnemyState.DEAD;
            }
            return;
        }

        if (currentState == EnemyState.WALKING) {
            // Edge detection logic (simple version: turn if no ground immediately ahead)
            // Check slightly in front and down, relative to movement direction
            float lookAheadOffset = facingRight ? bounds.width : -1; // Small offset in front of the bounding box
            float lookAheadX = position.x + lookAheadOffset;
            float lookDownY = position.y - 1; // Check just below the Goomba's feet

            boolean groundAhead = false;
            for (Platform p : platforms) {
                if (p.getType() == Platform.PlatformType.COIN) continue;
                // A small feeler rectangle for ground detection ahead
                Rectangle feeler = new Rectangle(lookAheadX, lookDownY, 1, 1);
                if (p.getBounds().overlaps(feeler)) {
                    groundAhead = true;
                    break;
                }
            }
            if (!groundAhead && velocity.y == 0) { // If on ground (vy=0) and no ground ahead
                facingRight = !facingRight; // Turn around
                velocity.x = facingRight ? SPEED : -SPEED; // Update velocity based on new direction
            }
        }
    }

    @Override
    public void render(SpriteBatch batch) {
        if (!isAlive && currentState != EnemyState.STOMPED) return;

        TextureRegion currentFrame = null;
        if (currentState == EnemyState.STOMPED) {
            currentFrame = squashedTextureRegion;
        } else {
            currentFrame = walkAnimation.getKeyFrame(stateTimer, true);
        }

        if (currentFrame != null) {
            float drawX = position.x - (WIDTH - COLLISION_WIDTH) / 2f;
            float drawY = position.y; // Collision bounds Y is usually bottom
            float drawWidth = WIDTH;
            float drawHeight = (currentState == EnemyState.STOMPED) ? HEIGHT / 2f : HEIGHT;

            // If sprites are drawn facing LEFT by default:
            // - To move LEFT (facingRight = false), don't flip (flipX = false).
            // - To move RIGHT (facingRight = true), flip (flipX = true).
            // This means flipX should be true when facingRight is true.
            boolean flipX = facingRight; // Corrected logic

            batch.draw(currentFrame,
                flipX ? drawX + drawWidth : drawX, // If flipping, adjust x-coordinate to keep position
                drawY,
                flipX ? -drawWidth : drawWidth,    // Negative width flips the texture region
                drawHeight);
        }
    }

    @Override
    public void onStompedBy(Player player) {
        if (currentState == EnemyState.WALKING) {
            currentState = EnemyState.STOMPED;
            velocity.set(0, 0);
            stateTimer = 0f;
            // SoundManager.getInstance().playEnemyStomp(); // Example: play stomp sound
        }
    }

    @Override
    public boolean onCollisionWith(Player player) {
        return currentState == EnemyState.WALKING; // Harmful only if walking
    }

    // No need for dispose here if Textures are managed externally (by Main.java)
}

================
File: src/main/java/io/github/game/enemies/Koopa.java
================
// File: core/src/main/java/io/github/game/enemies/Koopa.java
package io.github.game.enemies;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.Array;
import io.github.game.Platform;
import io.github.game.Player;
import io.github.game.SoundManager;

public class Koopa extends Enemy {
    public static final float WIDTH = 32f;
    public static final float HEIGHT = 48f; // Taller than Goomba
    public static final float SHELL_HEIGHT = 24f; // Height when in shell form
    private static final float COLLISION_WIDTH = 28f;
    private static final float COLLISION_HEIGHT = 44f;
    private static final float SHELL_COLLISION_HEIGHT = 20f;
    private static final float WALK_SPEED = 30f; // Slower than Goomba
    private static final float SHELL_SPEED = 200f; // Fast shell movement
    private static final float SHELL_IDLE_DURATION = 5f; // Time before shell disappears or respawns

    public enum KoopaState {
        WALKING,
        SHELL_IDLE,
        SHELL_MOVING,
        DEAD
    }

    private Animation<TextureRegion> walkAnimation;
    private Animation<TextureRegion> shellMoveAnimation;
    private TextureRegion shellIdleRegion;

    private KoopaState koopaState;
    private float shellIdleTimer;
    private boolean shellMovingRight;

    public Koopa(Texture walkFrame1Tex, Texture walkFrame2Tex, Texture shellIdleTex,
                 Texture shellMove1Tex, Texture shellMove2Tex, Texture shellMove3Tex, Texture shellMove4Tex,
                 float x, float y) {
        super(x, y, COLLISION_WIDTH, COLLISION_HEIGHT);

        // Create walking animation
        Array<TextureRegion> walkFrames = new Array<>();
        walkFrames.add(new TextureRegion(walkFrame1Tex));
        walkFrames.add(new TextureRegion(walkFrame2Tex));
        walkAnimation = new Animation<>(0.4f, walkFrames, Animation.PlayMode.LOOP);

        // Create shell moving animation
        Array<TextureRegion> shellFrames = new Array<>();
        shellFrames.add(new TextureRegion(shellMove1Tex));
        shellFrames.add(new TextureRegion(shellMove2Tex));
        shellFrames.add(new TextureRegion(shellMove3Tex));
        shellFrames.add(new TextureRegion(shellMove4Tex));
        shellMoveAnimation = new Animation<>(0.1f, shellFrames, Animation.PlayMode.LOOP);

        this.shellIdleRegion = new TextureRegion(shellIdleTex);

        this.koopaState = KoopaState.WALKING;
        this.shellIdleTimer = 0f;
        this.shellMovingRight = false;

        // Initial velocity: start moving left
        velocity.x = facingRight ? WALK_SPEED : -WALK_SPEED;
    }

    @Override
    protected void updateLogic(float deltaTime, Array<Platform> platforms, Player player) {
        switch (koopaState) {
            case WALKING:
                updateWalkingLogic(deltaTime, platforms);
                break;
            case SHELL_IDLE:
                updateShellIdleLogic(deltaTime);
                break;
            case SHELL_MOVING:
                updateShellMovingLogic(deltaTime, platforms);
                break;
            case DEAD:
                velocity.x = 0;
                velocity.y = 0;
                break;
        }
    }

    private void updateWalkingLogic(float deltaTime, Array<Platform> platforms) {
        // Edge detection logic similar to Goomba
        float lookAheadOffset = facingRight ? bounds.width : -1;
        float lookAheadX = position.x + lookAheadOffset;
        float lookDownY = position.y - 1;

        boolean groundAhead = false;
        for (Platform p : platforms) {
            if (p.getType() == Platform.PlatformType.COIN) continue;
            Rectangle feeler = new Rectangle(lookAheadX, lookDownY, 1, 1);
            if (p.getBounds().overlaps(feeler)) {
                groundAhead = true;
                break;
            }
        }
        if (!groundAhead && velocity.y == 0) {
            facingRight = !facingRight;
            velocity.x = facingRight ? WALK_SPEED : -WALK_SPEED;
        }
    }

    private void updateShellIdleLogic(float deltaTime) {
        velocity.x = 0;
        shellIdleTimer += deltaTime;

        // After idle duration, respawn as walking Koopa or disappear
        if (shellIdleTimer > SHELL_IDLE_DURATION) {
            // For now, just mark as dead. In a full game, you might respawn the Koopa
            koopaState = KoopaState.DEAD;
            isAlive = false;
        }
    }

    private void updateShellMovingLogic(float deltaTime, Array<Platform> platforms) {
        // Shell moves fast in one direction until it hits something
        velocity.x = shellMovingRight ? SHELL_SPEED : -SHELL_SPEED;

        // Check for walls to bounce off
        // This is handled by the main collision detection in Enemy.update()
    }

    @Override
    public void render(SpriteBatch batch) {
        if (!isAlive && koopaState != KoopaState.SHELL_IDLE && koopaState != KoopaState.SHELL_MOVING) return;

        TextureRegion currentFrame = null;
        float drawWidth = WIDTH;
        float drawHeight = HEIGHT;

        switch (koopaState) {
            case WALKING:
                currentFrame = walkAnimation.getKeyFrame(stateTimer, true);
                break;
            case SHELL_IDLE:
                currentFrame = shellIdleRegion;
                drawHeight = SHELL_HEIGHT;
                break;
            case SHELL_MOVING:
                currentFrame = shellMoveAnimation.getKeyFrame(stateTimer, true);
                drawHeight = SHELL_HEIGHT;
                break;
            default:
                return;
        }

        if (currentFrame != null) {
            float drawX = position.x - (WIDTH - COLLISION_WIDTH) / 2f;
            float drawY = position.y;

            // Flip sprite based on direction (only when walking)
            boolean flipX = false;
            if (koopaState == KoopaState.WALKING) {
                flipX = facingRight; // Flip when facing right (assuming sprites face left by default)
            } else if (koopaState == KoopaState.SHELL_MOVING) {
                // Don't flip shell sprites as they should look the same regardless of direction
                flipX = false;
            }

            batch.draw(currentFrame,
                flipX ? drawX + drawWidth : drawX,
                drawY,
                flipX ? -drawWidth : drawWidth,
                drawHeight);
        }
    }

    @Override
    public void onStompedBy(Player player) {
        if (koopaState == KoopaState.WALKING) {
            // Transform into shell
            koopaState = KoopaState.SHELL_IDLE;
            shellIdleTimer = 0f;
            velocity.set(0, 0);

            // Adjust bounds for shell form
            bounds.height = SHELL_COLLISION_HEIGHT;

            // Play sound
            SoundManager.getInstance().playEnemyStomp();

            stateTimer = 0f;
            Gdx.app.log("Koopa", "Koopa turned into idle shell");
        } else if (koopaState == KoopaState.SHELL_IDLE) {
            // Kick the shell
            kickShell(player);
        } else if (koopaState == KoopaState.SHELL_MOVING) {
            // Stop the shell
            koopaState = KoopaState.SHELL_IDLE;
            shellIdleTimer = 0f;
            velocity.x = 0;
            Gdx.app.log("Koopa", "Moving shell stopped");
        }
    }

    private void kickShell(Player player) {
        koopaState = KoopaState.SHELL_MOVING;
        shellIdleTimer = 0f;

        // Determine kick direction based on player position
        float playerCenterX = player.getPosition().x + player.getBounds().width / 2f;
        float koopaCenterX = position.x + bounds.width / 2f;

        shellMovingRight = playerCenterX < koopaCenterX;
        velocity.x = shellMovingRight ? SHELL_SPEED : -SHELL_SPEED;

        stateTimer = 0f;

        // Play kick sound
        SoundManager.getInstance().playEnemyStomp();
        Gdx.app.log("Koopa", "Shell kicked! Moving " + (shellMovingRight ? "right" : "left"));
    }

    @Override
    public boolean onCollisionWith(Player player) {
        switch (koopaState) {
            case WALKING:
                Gdx.app.log("Koopa", "Walking Koopa hit player - harmful");
                return true; // Harmful when walking
            case SHELL_IDLE:
                // FIXED: Player kicks idle shell, not harmful
                Gdx.app.log("Koopa", "Player touched idle shell - kicking shell");
                kickShell(player);
                return false; // Not harmful, just kicked
            case SHELL_MOVING:
                Gdx.app.log("Koopa", "Moving shell hit player - harmful");
                return true; // Harmful when shell is moving
            default:
                return false;
        }
    }

    // Override collision methods to handle shell bouncing
    @Override
    protected void checkHorizontalPlatformCollisions(Array<Platform> platforms) {
        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue;
            if (bounds.overlaps(platform.getBounds())) {
                if (velocity.x > 0) {
                    position.x = platform.getBounds().x - bounds.width;
                    if (koopaState == KoopaState.SHELL_MOVING) {
                        shellMovingRight = false; // Bounce left
                        velocity.x = -SHELL_SPEED;
                    } else {
                        velocity.x = -Math.abs(velocity.x);
                        facingRight = false;
                    }
                } else if (velocity.x < 0) {
                    position.x = platform.getBounds().x + platform.getBounds().width;
                    if (koopaState == KoopaState.SHELL_MOVING) {
                        shellMovingRight = true; // Bounce right
                        velocity.x = SHELL_SPEED;
                    } else {
                        velocity.x = Math.abs(velocity.x);
                        facingRight = true;
                    }
                }
                bounds.setX(position.x);
            }
        }
    }

    public KoopaState getKoopaState() {
        return koopaState;
    }

    public boolean isShell() {
        return koopaState == KoopaState.SHELL_IDLE || koopaState == KoopaState.SHELL_MOVING;
    }

    public boolean isMovingShell() {
        return koopaState == KoopaState.SHELL_MOVING;
    }
}

================
File: src/main/java/io/github/game/GameStateManager.java
================
// File: core/src/main/java/io/github/game/GameStateManager.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.GlyphLayout;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.Array;

public class GameStateManager {

    public enum GameState {
        PLAYING,
        GAME_OVER,
        LEVEL_COMPLETE,
        PAUSED,
        WORLD_MAP, // NEW: World map state
        MAIN_MENU  // NEW: Main menu state (for future use)
    }

    private GameState currentState;
    private GameState previousState; // NEW: Track previous state for returning
    private int lives;
    private int coins;
    private int score;
    private int totalScore; // NEW: Track total score across all levels
    private boolean showLevelCompleteScreen;
    private float levelCompleteTimer;
    private String currentLevelName; // NEW: Track current level name
    private int currentWorld; // NEW: Track current world
    private int currentLevel; // NEW: Track current level number

    // FIXED: Add persistent stats that survive world map transitions
    private int persistentLives; // Lives that persist across world map transitions
    private int persistentTotalScore; // Total score that persists
    private boolean isInLevel; // Track if we're currently in a level

    // UI Elements
    private BitmapFont font;
    private BitmapFont titleFont;
    private BitmapFont smallFont; // NEW: For smaller text
    private ShapeRenderer shapeRenderer;

    // Game Over Screen
    private Rectangle retryButton;
    private Rectangle quitButton;
    private Rectangle worldMapButton; // NEW: Return to world map button
    private boolean retryClicked;
    private boolean quitClicked;
    private boolean worldMapClicked; // NEW

    // Level Complete Screen
    private Rectangle worldMapButtonComplete; // Only world map button
    private boolean worldMapCompleteClicked;

    // Constants
    private static final int STARTING_LIVES = 3;
    private static final int COINS_FOR_LIFE = 100;
    private static final float LEVEL_COMPLETE_AUTO_RETURN_TIME = 5.0f; // Auto return to world map after 5 seconds

    public void update(float deltaTime) {
        if (currentState == GameState.LEVEL_COMPLETE) {
            levelCompleteTimer += deltaTime;

            // Auto return to world map after 5 seconds
            if (levelCompleteTimer >= LEVEL_COMPLETE_AUTO_RETURN_TIME) {
                worldMapCompleteClicked = true;
                Gdx.app.log("GameState", "Auto-returning to World Map after 5 seconds");
            } else {
                handleLevelCompleteInput(); // Handle manual input before auto-return
            }
        }

        if (currentState == GameState.GAME_OVER) {
            handleGameOverInput();
        }

        // Handle pause state
        if (currentState == GameState.PAUSED) {
            if (Gdx.input.isKeyJustPressed(Input.Keys.P) ||
                Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
                resumeGame();
            }
        }
    }

    private void handleLevelCompleteInput() {
        if (Gdx.input.isButtonJustPressed(Input.Buttons.LEFT)) {
            float mouseX = Gdx.input.getX();
            float mouseY = Gdx.graphics.getHeight() - Gdx.input.getY();

            if (worldMapButtonComplete.contains(mouseX, mouseY)) {
                worldMapCompleteClicked = true;
                Gdx.app.log("GameState", "World Map button clicked");
            }
        }

        // Keyboard shortcuts - only world map return options
        if (Gdx.input.isKeyJustPressed(Input.Keys.M) ||
            Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE) ||
            Gdx.input.isKeyJustPressed(Input.Keys.SPACE) ||
            Gdx.input.isKeyJustPressed(Input.Keys.ENTER)) {
            worldMapCompleteClicked = true;
            Gdx.app.log("GameState", "Return to World Map via keyboard");
        }
    }

    private void handleGameOverInput() {
        if (Gdx.input.isButtonJustPressed(Input.Buttons.LEFT)) {
            float mouseX = Gdx.input.getX();
            float mouseY = Gdx.graphics.getHeight() - Gdx.input.getY();

            if (retryButton.contains(mouseX, mouseY)) {
                retryClicked = true;
            } else if (worldMapButton.contains(mouseX, mouseY)) {
                worldMapClicked = true;
            } else if (quitButton.contains(mouseX, mouseY)) {
                quitClicked = true;
            }
        }

        // Keyboard shortcuts
        if (Gdx.input.isKeyJustPressed(Input.Keys.R)) {
            retryClicked = true;
        } else if (Gdx.input.isKeyJustPressed(Input.Keys.M)) {
            worldMapClicked = true;
        } else if (Gdx.input.isKeyJustPressed(Input.Keys.Q) ||
            Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            quitClicked = true;
        }
    }

    public void renderUI(SpriteBatch batch, OrthographicCamera camera) {
        // Only render HUD during gameplay
        if (currentState == GameState.PLAYING) {
            renderHUD(batch);
        }

        // Render state-specific screens
        switch (currentState) {
            case GAME_OVER:
                renderGameOverScreen(batch);
                break;
            case LEVEL_COMPLETE:
                renderLevelCompleteScreen(batch);
                break;
            case PAUSED:
                renderPauseScreen(batch); // NEW
                break;
        }
    }

    private void renderHUD(SpriteBatch batch) {
        // Set up UI projection
        batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());

        batch.begin();
        font.setColor(Color.WHITE);

        // Render HUD (lives, coins, score, level info)
        float hudY = Gdx.graphics.getHeight() - 30f;
        font.draw(batch, "Lives: " + lives, 20f, hudY);
        font.draw(batch, "Coins: " + coins, 150f, hudY);
        font.draw(batch, "Score: " + score, 280f, hudY);

        // NEW: Show current level info
        if (!currentLevelName.isEmpty()) {
            font.draw(batch, currentLevelName, 450f, hudY);
        }

        // NEW: Show total score in smaller text
        smallFont.setColor(Color.LIGHT_GRAY);
        smallFont.draw(batch, "Total: " + totalScore, 20f, hudY - 25f);

        batch.end();
    }

    // NEW: Render pause screen
    private void renderPauseScreen(SpriteBatch batch) {
        // Draw semi-transparent overlay
        shapeRenderer.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0, 0, 0, 0.5f);
        shapeRenderer.rect(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        shapeRenderer.end();

        batch.begin();
        titleFont.setColor(Color.YELLOW);
        titleFont.draw(batch, "PAUSED",
            Gdx.graphics.getWidth()/2f - 80f,
            Gdx.graphics.getHeight()/2f + 50f);

        font.setColor(Color.WHITE);
        font.draw(batch, "Press P or ESC to resume",
            Gdx.graphics.getWidth()/2f - 120f,
            Gdx.graphics.getHeight()/2f);

        batch.end();
    }

    // FIXED: Enhanced constructor with proper persistent stats initialization
    public GameStateManager() {
        this.currentState = GameState.WORLD_MAP;
        this.previousState = GameState.WORLD_MAP;
        this.lives = STARTING_LIVES;
        this.coins = 0;
        this.score = 0;
        this.totalScore = 0;
        this.showLevelCompleteScreen = false;
        this.levelCompleteTimer = 0f;
        this.currentLevelName = "";
        this.currentWorld = 1;
        this.currentLevel = 1;
        this.isInLevel = false;

        // FIXED: Initialize persistent stats
        this.persistentLives = STARTING_LIVES;
        this.persistentTotalScore = 0;

        this.font = new BitmapFont();
        this.titleFont = new BitmapFont();
        this.smallFont = new BitmapFont();
        this.shapeRenderer = new ShapeRenderer();
        this.glyphLayout = new GlyphLayout();

        // Set default font scales
        this.font.getData().setScale(1.2f);
        this.titleFont.getData().setScale(2.0f);
        this.smallFont.getData().setScale(0.9f);

        // FIXED: Initialize all buttons to prevent null pointer exceptions
        initializeButtons();
    }

    private void renderGameOverScreen(SpriteBatch batch) {
        float screenWidth = Gdx.graphics.getWidth();
        float screenHeight = Gdx.graphics.getHeight();

        // Draw semi-transparent overlay
        shapeRenderer.getProjectionMatrix().setToOrtho2D(0, 0, screenWidth, screenHeight);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0, 0, 0, 0.85f);
        shapeRenderer.rect(0, 0, screenWidth, screenHeight);
        shapeRenderer.end();

        // Simple centered panel
        float panelWidth = 600f;
        float panelHeight = 400f;
        float panelX = (screenWidth - panelWidth) / 2f;
        float panelY = (screenHeight - panelHeight) / 2f;

        // Draw panel background
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0.1f, 0.1f, 0.15f, 0.95f);
        shapeRenderer.rect(panelX, panelY, panelWidth, panelHeight);
        shapeRenderer.end();

        // Draw panel border
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(Color.RED);
        Gdx.gl.glLineWidth(3f);
        shapeRenderer.rect(panelX, panelY, panelWidth, panelHeight);
        shapeRenderer.end();
        Gdx.gl.glLineWidth(1f);

        // Update button positions
        float buttonWidth = 140f;
        float buttonHeight = 45f;
        float buttonSpacing = 20f;
        float buttonY = panelY + 40f;

        retryButton.set(panelX + panelWidth/2f - buttonWidth*1.5f - buttonSpacing, buttonY, buttonWidth, buttonHeight);
        worldMapButton.set(panelX + panelWidth/2f - buttonWidth/2f, buttonY, buttonWidth, buttonHeight);
        quitButton.set(panelX + panelWidth/2f + buttonWidth/2f + buttonSpacing, buttonY, buttonWidth, buttonHeight);

        // Draw buttons
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0.2f, 0.7f, 0.2f, 0.9f); // Green
        shapeRenderer.rect(retryButton.x, retryButton.y, retryButton.width, retryButton.height);
        shapeRenderer.setColor(0.2f, 0.4f, 0.8f, 0.9f); // Blue
        shapeRenderer.rect(worldMapButton.x, worldMapButton.y, worldMapButton.width, worldMapButton.height);
        shapeRenderer.setColor(0.8f, 0.2f, 0.2f, 0.9f); // Red
        shapeRenderer.rect(quitButton.x, quitButton.y, quitButton.width, quitButton.height);
        shapeRenderer.end();

        // Button borders
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(Color.WHITE);
        shapeRenderer.rect(retryButton.x, retryButton.y, retryButton.width, retryButton.height);
        shapeRenderer.rect(worldMapButton.x, worldMapButton.y, worldMapButton.width, worldMapButton.height);
        shapeRenderer.rect(quitButton.x, quitButton.y, quitButton.width, quitButton.height);
        shapeRenderer.end();

        // FIXED: Simple, reliable text rendering
        batch.getProjectionMatrix().setToOrtho2D(0, 0, screenWidth, screenHeight);
        batch.begin();

        // Reset font scales to default
        titleFont.getData().setScale(2.0f);
        font.getData().setScale(1.5f);
        smallFont.getData().setScale(1.0f);

        // Draw title
        titleFont.setColor(Color.RED);
        titleFont.draw(batch, "GAME OVER", panelX + 150f, panelY + panelHeight - 50f);

        // Draw score info
        font.setColor(Color.YELLOW);
        font.draw(batch, "Final Score: " + score, panelX + 50f, panelY + panelHeight - 120f);

        font.setColor(Color.CYAN);
        font.draw(batch, "Total Score: " + totalScore, panelX + 50f, panelY + panelHeight - 160f);

        // Button labels - using simple positioning
        smallFont.setColor(Color.WHITE);
        smallFont.draw(batch, "RETRY", retryButton.x + 35f, retryButton.y + 28f);
        smallFont.draw(batch, "WORLD MAP", worldMapButton.x + 20f, worldMapButton.y + 28f);
        smallFont.draw(batch, "QUIT", quitButton.x + 40f, quitButton.y + 28f);

        // Controls
        smallFont.setColor(Color.GRAY);
        smallFont.draw(batch, "R: Retry  M: World Map  Q: Quit", panelX + 50f, panelY + 20f);

        batch.end();
    }

    private void renderLevelCompleteScreen(SpriteBatch batch) {
        float screenWidth = Gdx.graphics.getWidth();
        float screenHeight = Gdx.graphics.getHeight();

        // Draw overlay
        shapeRenderer.getProjectionMatrix().setToOrtho2D(0, 0, screenWidth, screenHeight);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0, 0, 0, 0.8f);
        shapeRenderer.rect(0, 0, screenWidth, screenHeight);
        shapeRenderer.end();

        // Main panel
        float panelWidth = 700f;
        float panelHeight = 500f;
        float panelX = (screenWidth - panelWidth) / 2f;
        float panelY = (screenHeight - panelHeight) / 2f;

        // Draw panel
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0.05f, 0.15f, 0.25f, 0.98f);
        shapeRenderer.rect(panelX, panelY, panelWidth, panelHeight);
        shapeRenderer.end();

        // Panel border
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(Color.GOLD);
        Gdx.gl.glLineWidth(4f);
        shapeRenderer.rect(panelX, panelY, panelWidth, panelHeight);
        shapeRenderer.end();
        Gdx.gl.glLineWidth(1f);

        // Update world map button position - centered since it's the only button
        float buttonWidth = 200f;
        float buttonHeight = 60f;
        float buttonY = panelY + 60f;

        if (worldMapButtonComplete == null) {
            worldMapButtonComplete = new Rectangle();
        }

        worldMapButtonComplete.set(panelX + (panelWidth - buttonWidth) / 2f, buttonY, buttonWidth, buttonHeight);

        // Draw world map button
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0.2f, 0.5f, 0.9f, 0.95f); // Blue
        shapeRenderer.rect(worldMapButtonComplete.x, worldMapButtonComplete.y, worldMapButtonComplete.width, worldMapButtonComplete.height);
        shapeRenderer.end();

        // Button border
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(Color.WHITE);
        Gdx.gl.glLineWidth(2f);
        shapeRenderer.rect(worldMapButtonComplete.x, worldMapButtonComplete.y, worldMapButtonComplete.width, worldMapButtonComplete.height);
        shapeRenderer.end();
        Gdx.gl.glLineWidth(1f);

        // FIXED: Simple, reliable text rendering
        batch.getProjectionMatrix().setToOrtho2D(0, 0, screenWidth, screenHeight);
        batch.begin();

        // Reset font scales
        titleFont.getData().setScale(2.5f);
        font.getData().setScale(1.3f);
        smallFont.getData().setScale(1.0f);

        // Animated title
        titleFont.setColor(Color.YELLOW);
        float pulse = 1.0f + 0.2f * (float)Math.sin(levelCompleteTimer * 4f);
        titleFont.getData().setScale(2.5f * pulse);
        titleFont.draw(batch, "LEVEL COMPLETE!", panelX + 100f, panelY + panelHeight - 50f);
        titleFont.getData().setScale(2.5f); // Reset

        // Level info
        float textY = panelY + panelHeight - 130f;
        float lineSpacing = 35f;

        font.setColor(Color.WHITE);
        if (!currentLevelName.isEmpty()) {
            font.draw(batch, "Level: " + currentLevelName, panelX + 50f, textY);
            textY -= lineSpacing;
        }

        font.setColor(Color.CYAN);
        font.draw(batch, "Level Score: " + String.format("%,d", score), panelX + 50f, textY);
        textY -= lineSpacing;

        font.setColor(Color.GOLD);
        font.draw(batch, "Coins Collected: " + coins, panelX + 50f, textY);
        textY -= lineSpacing;

        font.setColor(Color.YELLOW);
        font.draw(batch, "Total Score: " + String.format("%,d", totalScore), panelX + 50f, textY);
        textY -= lineSpacing;

        font.setColor(Color.PINK);
        font.draw(batch, "Lives: " + lives, panelX + 50f, textY);
        textY -= lineSpacing;

        // Time bonus
        if (levelCompleteTimer < 60f) {
            font.setColor(Color.GREEN);
            int timeBonus = (int)((60f - levelCompleteTimer) * 10);
            font.draw(batch, "TIME BONUS: +" + String.format("%,d", timeBonus), panelX + 50f, textY);
        }

        // Auto-return countdown timer
        float timeRemaining = LEVEL_COMPLETE_AUTO_RETURN_TIME - levelCompleteTimer;
        if (timeRemaining > 0) {
            font.setColor(Color.ORANGE);
            String countdownText = "Returning to World Map in " + String.format("%.1f", timeRemaining) + "s";
            font.draw(batch, countdownText, panelX + 50f, panelY + panelHeight - 430f);
        }

        // World map button label
        font.setColor(Color.WHITE);
        font.draw(batch, "WORLD MAP", worldMapButtonComplete.x + 50f, worldMapButtonComplete.y + 38f);

        // Instructions
        smallFont.setColor(Color.LIGHT_GRAY);
        smallFont.draw(batch, "Click button or press any key to return to World Map", panelX + 50f, panelY + 30f);

        batch.end();
    }

    // ENHANCED: Better button initialization with proper scaling
    private void initializeButtons() {
        float screenWidth = Gdx.graphics.getWidth();
        float screenHeight = Gdx.graphics.getHeight();

        // Scale factors for different screen sizes
        float scaleFactor = Math.min(screenWidth / 1920f, screenHeight / 1080f);
        scaleFactor = Math.max(scaleFactor, 0.7f);

        float buttonHeight = 35f * scaleFactor;
        float buttonSpacing = 10f * scaleFactor;
        float uiElementMargin = 15f * scaleFactor;

        // Game Over buttons with better scaling
        float gameOverButtonWidth = 200f * scaleFactor;
        float gameOverButtonHeight = 60f * scaleFactor;
        float gameOverButtonSpacing = 25f * scaleFactor;

        retryButton = new Rectangle(
            screenWidth/2f - gameOverButtonWidth*1.5f - gameOverButtonSpacing,
            screenHeight/2f - gameOverButtonHeight/2f - 80f * scaleFactor,
            gameOverButtonWidth,
            gameOverButtonHeight
        );

        worldMapButton = new Rectangle(
            screenWidth/2f - gameOverButtonWidth/2f,
            screenHeight/2f - gameOverButtonHeight/2f - 80f * scaleFactor,
            gameOverButtonWidth,
            gameOverButtonHeight
        );

        quitButton = new Rectangle(
            screenWidth/2f + gameOverButtonWidth/2f + gameOverButtonSpacing,
            screenHeight/2f - gameOverButtonHeight/2f - 80f * scaleFactor,
            gameOverButtonWidth,
            gameOverButtonHeight
        );

        // FIXED: Initialize only world map button for level complete (no next level button)
        float levelCompleteButtonWidth = 200f * scaleFactor;
        float levelCompleteButtonHeight = 60f * scaleFactor;

        // Initialize world map button centered (will be updated in renderLevelCompleteScreen)
        worldMapButtonComplete = new Rectangle(
            screenWidth/2f - levelCompleteButtonWidth/2f,
            screenHeight/2f - 100f * scaleFactor,
            levelCompleteButtonWidth,
            levelCompleteButtonHeight
        );
    }

    // NEW: Check if next level is available
    private boolean checkNextLevelAvailable() {
        return hasNextLevel; // This boolean should be set by the main game
    }

    // Add these fields to the GameStateManager class (if not already present)
    private boolean hasNextLevel = true;
    private String nextLevelName = "";

    // Methods to set next level information
    public void setNextLevelAvailable(boolean available) {
        this.hasNextLevel = available;
    }

    public void setNextLevelName(String nextLevelName) {
        this.nextLevelName = nextLevelName;
    }

    // ENHANCED: Level completion method simplified for world map return only
    public void completeLevel() {
        currentState = GameState.LEVEL_COMPLETE;
        showLevelCompleteScreen = true;
        levelCompleteTimer = 0f;
        addScore(1000); // Bonus for completing level

        // Add time bonus if completed quickly
        if (levelCompleteTimer < 60f) {
            int timeBonus = (int)((60f - levelCompleteTimer) * 10);
            addScore(timeBonus);
        }

        // FIXED: Update persistent stats when completing level
        persistentLives = lives;
        persistentTotalScore = totalScore;

        worldMapCompleteClicked = false;

        SoundManager.getInstance().playItemGet();
        Gdx.app.log("GameState", "Level completed! Will return to world map in " + LEVEL_COMPLETE_AUTO_RETURN_TIME + " seconds");
    }

    // UPDATED: dispose method to include GlyphLayout
    public void dispose() {
        if (font != null) font.dispose();
        if (titleFont != null) titleFont.dispose();
        if (smallFont != null) smallFont.dispose();
        if (shapeRenderer != null) shapeRenderer.dispose();
        // Note: GlyphLayout doesn't need disposal
    }

    private GlyphLayout glyphLayout; // Add this field

    // Game state methods
    public void collectCoin() {
        coins++;
        score += 50; // 50 points per coin

        // Give extra life every 100 coins
        if (coins % COINS_FOR_LIFE == 0) {
            addLife();
        }
    }

    public void addScore(int points) {
        score += points;
        totalScore += points; // NEW: Also add to total score
    }

    public void addLife() {
        lives++;
        persistentLives = lives; // FIXED: Update persistent lives
        SoundManager.getInstance().playItemGet();
        Gdx.app.log("GameState", "Extra life earned! Lives: " + lives);
    }

    public void loseLife() {
        lives--;
        Gdx.app.log("GameState", "Life lost! Lives remaining: " + lives);

        if (lives <= 0) {
            triggerGameOver();
        }
    }

    public void triggerGameOver() {
        currentState = GameState.GAME_OVER;
        retryClicked = false;
        quitClicked = false;
        worldMapClicked = false; // NEW
        SoundManager.getInstance().stopMusic();
        Gdx.app.log("GameState", "Game Over! Final Score: " + score);
    }

    // FIXED: Enhanced reset methods for better state management
    public void resetGame() {
        previousState = currentState; // NEW: Store previous state
        currentState = GameState.PLAYING;
        lives = STARTING_LIVES;
        coins = 0;
        score = 0;
        // Don't reset totalScore - it persists across game sessions
        showLevelCompleteScreen = false;
        levelCompleteTimer = 0f;
        retryClicked = false;
        quitClicked = false;
        worldMapClicked = false; // NEW
        worldMapCompleteClicked = false;
        isInLevel = true; // FIXED: Mark as in level

        // FIXED: Reset persistent stats to starting values
        persistentLives = STARTING_LIVES;
    }

    // NEW: Method to enter a level (called when entering from world map)
    public void enterLevel(String levelName, int world, int level) {
        isInLevel = true;
        currentState = GameState.PLAYING;

        // FIXED: Restore persistent stats when entering level
        lives = persistentLives;
        totalScore = persistentTotalScore;

        // Reset level-specific stats
        coins = 0;
        score = 0;

        setCurrentLevel(levelName, world, level);
        clearButtonStates();

        Gdx.app.log("GameState", "Entered level: " + levelName + " with " + lives + " lives");
    }

    // NEW: Method to exit to world map (preserves progress)
    public void exitToWorldMap() {
        isInLevel = false;
        currentState = GameState.WORLD_MAP;

        // FIXED: Update persistent stats before leaving level
        persistentLives = lives;
        persistentTotalScore = totalScore;

        clearButtonStates();

        Gdx.app.log("GameState", "Exited to world map. Lives preserved: " + persistentLives);
    }

    // NEW: Reset only the level-specific progress
    public void resetLevel() {
        if (isInLevel) {
            // Reset level stats but keep persistent progress
            coins = 0;
            score = persistentTotalScore; // Start level score from persistent total
            lives = persistentLives; // Use persistent lives
            showLevelCompleteScreen = false;
            levelCompleteTimer = 0f;

            Gdx.app.log("GameState", "Level reset. Lives: " + lives + ", Total Score: " + totalScore);
        }
    }

    public void pauseGame() {
        if (currentState == GameState.PLAYING) {
            previousState = currentState;
            currentState = GameState.PAUSED;
        }
    }

    public void resumeGame() {
        if (currentState == GameState.PAUSED) {
            currentState = previousState;
        }
    }

    // NEW: Set current level info
    public void setCurrentLevel(String levelName, int world, int level) {
        this.currentLevelName = levelName;
        this.currentWorld = world;
        this.currentLevel = level;
    }

    // NEW: Enter world map mode
    public void enterWorldMap() {
        exitToWorldMap(); // Use the enhanced exit method
    }

    // FIXED: Enhanced getters that handle persistent stats
    public GameState getCurrentState() { return currentState; }
    public GameState getPreviousState() { return previousState; } // NEW
    public int getLives() { return lives; }
    public int getCoins() { return coins; }
    public int getScore() { return score; }
    public int getTotalScore() { return totalScore; } // NEW
    public int getPersistentLives() { return persistentLives; } // NEW
    public String getCurrentLevelName() { return currentLevelName; } // NEW
    public int getCurrentWorld() { return currentWorld; } // NEW
    public int getCurrentLevel() { return currentLevel; } // NEW
    public boolean isInLevel() { return isInLevel; } // NEW
    public boolean isRetryClicked() { return retryClicked; }
    public boolean isQuitClicked() { return quitClicked; }
    public boolean isWorldMapClicked() { return worldMapClicked; } // NEW
    public boolean isWorldMapCompleteClicked() { return worldMapCompleteClicked; } // Only world map option for level complete
    public boolean isGameOver() { return currentState == GameState.GAME_OVER; }
    public boolean isPlaying() { return currentState == GameState.PLAYING; }
    public boolean isLevelComplete() { return currentState == GameState.LEVEL_COMPLETE; }
    public boolean isPaused() { return currentState == GameState.PAUSED; } // NEW
    public boolean isOnWorldMap() { return currentState == GameState.WORLD_MAP; } // NEW

    // Setters
    public void setState(GameState state) {
        this.previousState = this.currentState;
        this.currentState = state;
    }
    public void setLives(int lives) {
        this.lives = lives;
        if (isInLevel) {
            this.persistentLives = lives; // Update persistent lives if in level
        }
    }
    public void setCoins(int coins) { this.coins = coins; }
    public void setScore(int score) { this.score = score; }
    public void setTotalScore(int totalScore) {
        this.totalScore = totalScore;
        this.persistentTotalScore = totalScore; // Update persistent total
    }

    // NEW: Clear button click states
    public void clearButtonStates() {
        retryClicked = false;
        quitClicked = false;
        worldMapClicked = false;
        worldMapCompleteClicked = false;
    }
}

================
File: src/main/java/io/github/game/GoalPost.java
================
// File: core/src/main/java/io/github/game/GoalPost.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Disposable;

public class GoalPost implements Disposable {
    private Vector2 position;
    private Rectangle bounds;
    private Texture flagTexture;
    private Texture poleTexture;
    private boolean levelCompleted;
    private float animationTimer;

    public static final float GOAL_POST_WIDTH = 32f;
    public static final float GOAL_POST_HEIGHT = 180f; // Tall goal post
    public static final float FLAG_WIDTH = 48f;
    public static final float FLAG_HEIGHT = 32f;

    // Static textures for goal post
    private static Texture staticFlagTexture;
    private static Texture staticPoleTexture;

    static {
        try {
            // Try to load goal post textures
            if (Gdx.files.internal("mario_sprites/world/goal_post.png").exists()) {
                staticPoleTexture = new Texture("mario_sprites/world/goal_post.png");
            } else if (Gdx.files.internal("mario_sprites/world/cannon.png").exists()) {
                // Use cannon as fallback for pole
                staticPoleTexture = new Texture("mario_sprites/world/cannon.png");
            } else if (Gdx.files.internal("mario_sprites/world/brick.png").exists()) {
                // Use brick as another fallback
                staticPoleTexture = new Texture("mario_sprites/world/brick.png");
            } else {
                System.err.println("Warning: No goal post texture found");
            }

            if (Gdx.files.internal("mario_sprites/world/goal_flag.png").exists()) {
                staticFlagTexture = new Texture("mario_sprites/world/goal_flag.png");
            } else if (Gdx.files.internal("mario_sprites/world/exclamation_block.png").exists()) {
                // Use exclamation block as fallback for flag
                staticFlagTexture = new Texture("mario_sprites/world/exclamation_block.png");
            } else if (Gdx.files.internal("mario_sprites/world/coin.png").exists()) {
                // Use coin as fallback for flag
                staticFlagTexture = new Texture("mario_sprites/world/coin.png");
            } else {
                System.err.println("Warning: No goal flag texture found");
            }
        } catch (Exception e) {
            System.err.println("Error loading goal post textures: " + e.getMessage());
        }
    }

    public GoalPost(float x, float y) {
        this.position = new Vector2(x, y);
        this.bounds = new Rectangle(x, y, GOAL_POST_WIDTH, GOAL_POST_HEIGHT);
        this.levelCompleted = false;
        this.animationTimer = 0;
        this.flagTexture = staticFlagTexture;
        this.poleTexture = staticPoleTexture;
    }

    public void update(float deltaTime) {
        animationTimer += deltaTime;
    }

    public void render(SpriteBatch batch) {
        // Draw the pole
        if (poleTexture != null) {
            batch.draw(poleTexture, position.x, position.y, GOAL_POST_WIDTH, GOAL_POST_HEIGHT);
        }

        // Draw the flag with slight animation
        if (flagTexture != null) {
            float flagY = position.y + GOAL_POST_HEIGHT - FLAG_HEIGHT - 10f;
            float flagX = position.x + GOAL_POST_WIDTH;

            // Add slight waving animation
            float waveOffset = (float) Math.sin(animationTimer * 4) * 2f;

            batch.draw(flagTexture, flagX + waveOffset, flagY, FLAG_WIDTH, FLAG_HEIGHT);
        }
    }

    public boolean checkPlayerCollision(Rectangle playerBounds) {
        if (!levelCompleted && bounds.overlaps(playerBounds)) {
            levelCompleted = true;
            return true;
        }
        return false;
    }

    public boolean isLevelCompleted() {
        return levelCompleted;
    }

    public Vector2 getPosition() {
        return position;
    }

    public Rectangle getBounds() {
        return bounds;
    }

    public static void disposeStaticTextures() {
        if (staticFlagTexture != null) {
            staticFlagTexture.dispose();
            staticFlagTexture = null;
        }
        if (staticPoleTexture != null) {
            staticPoleTexture.dispose();
            staticPoleTexture = null;
        }
    }

    @Override
    public void dispose() {
        // Static textures are handled by disposeStaticTextures()
    }
}

================
File: src/main/java/io/github/game/Level.java
================
// File: core/src/main/java/io/github/game/Level.java
package io.github.game;

import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;
import com.badlogic.gdx.utils.ObjectMap;

public class Level implements Json.Serializable {
    public static class PlatformData {
        public float x, y, width, height;
        public Platform.PlatformType type;
        public Powerup.PowerupType containedPowerup;

        public PlatformData() {}

        public PlatformData(float x, float y, float width, float height, Platform.PlatformType type) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.type = type;
            this.containedPowerup = null;
        }
    }

    public static class EnemyData {
        public float x, y;
        public String type; // e.g., "GOOMBA"

        public EnemyData() {} // For JSON deserialization

        public EnemyData(float x, float y, String type) {
            this.x = x;
            this.y = y;
            this.type = type;
        }
    }

    // Powerup data class for standalone powerups
    public static class PowerupData {
        public float x, y;
        public String type; // e.g., "MUSHROOM", "FIRE_FLOWER", etc.

        public PowerupData() {} // For JSON deserialization

        public PowerupData(float x, float y, String type) {
            this.x = x;
            this.y = y;
            this.type = type;
        }
    }

    // NEW: Goal post data class
    public static class GoalPostData {
        public float x, y;

        public GoalPostData() {} // For JSON deserialization

        public GoalPostData(float x, float y) {
            this.x = x;
            this.y = y;
        }
    }

    private String name;
    private Array<PlatformData> platformData;
    private Array<EnemyData> enemyData;
    private Array<PowerupData> powerupData;
    private GoalPostData goalPostData; // NEW: Goal post data
    private float playerStartX, playerStartY;
    private String backgroundMusic;
    private float musicVolume;
    private String backgroundTexturePath;
    private ObjectMap<String, Powerup.PowerupType> questionBlockContents;

    public Level() {
        this.name = "Untitled Level";
        this.platformData = new Array<>();
        this.enemyData = new Array<>();
        this.powerupData = new Array<>();
        this.goalPostData = null; // NEW: Initialize as null
        this.playerStartX = 150;
        this.playerStartY = Platform.GROUND_TILE_SIZE * 2;
        this.backgroundMusic = "music/level1.mp3";
        this.musicVolume = 0.5f;
        this.backgroundTexturePath = Background.DEFAULT_BACKGROUND_PATH;
        this.questionBlockContents = new ObjectMap<>();
    }

    public Level(String name) {
        this();
        this.name = name;
    }

    // Existing getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public Array<PlatformData> getPlatformData() { return platformData; }
    public float getPlayerStartX() { return playerStartX; }
    public void setPlayerStartX(float x) { this.playerStartX = x; }
    public float getPlayerStartY() { return playerStartY; }
    public void setPlayerStartY(float y) { this.playerStartY = y; }
    public String getBackgroundMusic() { return backgroundMusic; }
    public void setBackgroundMusic(String music) { this.backgroundMusic = music; }
    public float getMusicVolume() { return musicVolume; }
    public void setMusicVolume(float volume) { this.musicVolume = volume; }
    public Array<EnemyData> getEnemyData() { return enemyData; }
    public String getBackgroundTexturePath() { return backgroundTexturePath; }
    public void setBackgroundTexturePath(String path) { this.backgroundTexturePath = path; }
    public Array<PowerupData> getPowerupData() { return powerupData; }

    // NEW: Goal post getters and setters
    public GoalPostData getGoalPostData() { return goalPostData; }
    public void setGoalPostData(GoalPostData goalPostData) { this.goalPostData = goalPostData; }
    public void setGoalPost(float x, float y) {
        this.goalPostData = new GoalPostData(x, y);
    }

    public void setQuestionBlockContent(String blockId, Powerup.PowerupType powerup) {
        questionBlockContents.put(blockId, powerup);
    }

    public Powerup.PowerupType getQuestionBlockContent(String blockId) {
        return questionBlockContents.get(blockId);
    }

    // Platform methods
    public void addPlatform(PlatformData data) {
        platformData.add(data);
    }

    public void removePlatform(PlatformData data) {
        platformData.removeValue(data, true);
    }

    public Array<Platform> createPlatforms() {
        Array<Platform> platforms = new Array<>();
        for (PlatformData data : platformData) {
            Platform platform = new Platform(data.x, data.y, data.width, data.height, data.type);
            if (data.containedPowerup != null) {
                platform.setContainedPowerup(data.containedPowerup);
            }
            platforms.add(platform);
        }
        return platforms;
    }

    // Enemy methods
    public void addEnemy(EnemyData data) {
        enemyData.add(data);
    }

    public void removeEnemy(EnemyData data) {
        enemyData.removeValue(data, true);
    }

    // Powerup methods
    public void addPowerup(PowerupData data) {
        powerupData.add(data);
    }

    public void removePowerup(PowerupData data) {
        powerupData.removeValue(data, true);
    }

    // NEW: Goal post creation method
    public GoalPost createGoalPost() {
        if (goalPostData != null) {
            return new GoalPost(goalPostData.x, goalPostData.y);
        }
        return null;
    }

    @Override
    public void write(Json json) {
        json.writeValue("name", name);
        json.writeValue("playerStartX", playerStartX);
        json.writeValue("playerStartY", playerStartY);
        json.writeValue("backgroundMusic", backgroundMusic);
        json.writeValue("musicVolume", musicVolume);
        json.writeValue("backgroundTexturePath", backgroundTexturePath);
        json.writeValue("platforms", platformData);
        json.writeValue("enemies", enemyData);
        json.writeValue("powerups", powerupData);
        json.writeValue("goalPost", goalPostData); // NEW: Serialize goal post
        json.writeValue("questionBlockContents", questionBlockContents);
    }

    @Override
    public void read(Json json, JsonValue jsonData) {
        name = jsonData.getString("name");
        playerStartX = jsonData.getFloat("playerStartX");
        playerStartY = jsonData.getFloat("playerStartY");
        backgroundMusic = jsonData.getString("backgroundMusic", "music/level1.mp3");
        musicVolume = jsonData.getFloat("musicVolume", 0.5f);
        backgroundTexturePath = jsonData.getString("backgroundTexturePath", Background.DEFAULT_BACKGROUND_PATH);

        platformData.clear();
        JsonValue platformsJson = jsonData.get("platforms");
        if (platformsJson != null) {
            for (JsonValue platformJson : platformsJson) {
                PlatformData data = json.readValue(PlatformData.class, platformJson);
                platformData.add(data);
            }
        }

        enemyData.clear();
        JsonValue enemiesJson = jsonData.get("enemies");
        if (enemiesJson != null) {
            for (JsonValue enemyJson : enemiesJson) {
                EnemyData data = new EnemyData();
                data.x = enemyJson.getFloat("x");
                data.y = enemyJson.getFloat("y");
                data.type = enemyJson.getString("type");
                enemyData.add(data);
            }
        }

        // Deserialize powerups
        powerupData.clear();
        JsonValue powerupsJson = jsonData.get("powerups");
        if (powerupsJson != null) {
            for (JsonValue powerupJson : powerupsJson) {
                PowerupData data = new PowerupData();
                data.x = powerupJson.getFloat("x");
                data.y = powerupJson.getFloat("y");
                data.type = powerupJson.getString("type");
                powerupData.add(data);
            }
        }

        // NEW: Deserialize goal post
        JsonValue goalPostJson = jsonData.get("goalPost");
        if (goalPostJson != null) {
            goalPostData = new GoalPostData();
            goalPostData.x = goalPostJson.getFloat("x");
            goalPostData.y = goalPostJson.getFloat("y");
        } else {
            goalPostData = null;
        }

        questionBlockContents.clear();
        JsonValue contentsJson = jsonData.get("questionBlockContents");
        if (contentsJson != null) {
            for (JsonValue.JsonIterator it = contentsJson.iterator(); it.hasNext(); ) {
                JsonValue entry = it.next();
                try {
                    questionBlockContents.put(entry.name, Powerup.PowerupType.valueOf(entry.asString()));
                } catch (IllegalArgumentException e) {
                    System.err.println("Warning: Unknown PowerupType '" + entry.asString() + "' for question block ID '" + entry.name + "'. Skipping.");
                }
            }
        }
    }
}

================
File: src/main/java/io/github/game/LevelEditor.java
================
// File: core/src/main/java/io/github/game/LevelEditor.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.ObjectMap;

import java.util.ArrayDeque;

import io.github.game.editor.EditorCommand;
import io.github.game.editor.AddPlatformCommand;
import io.github.game.editor.RemovePlatformCommand;
import io.github.game.editor.ClearLevelCommand;
import io.github.game.editor.AddEnemyCommand;
import io.github.game.editor.RemoveEnemyCommand;
import io.github.game.editor.AddPowerupCommand;
import io.github.game.editor.RemovePowerupCommand;

public class LevelEditor {
    private static final float GRID_SIZE = 32f;
    private static final float UI_PANEL_WIDTH = 240f;
    private static final float DEFAULT_GROUND_WIDTH_MULTIPLIER = 100f;
    private static final float DEFAULT_GROUND_HEIGHT_MULTIPLIER = 2f;

    private Level currentLevel;

    private enum EditorTool {
        PLATFORM,
        GOOMBA,
        KOOPA, // NEW: Koopa tool
        POWERUP,
        GOAL_POST // NEW: Goal post tool
    }
    private EditorTool currentTool = EditorTool.PLATFORM;
    private Platform.PlatformType selectedPlatformType = Platform.PlatformType.GRAVEL_BLOCK;
    private Powerup.PowerupType selectedPowerupType = Powerup.PowerupType.MUSHROOM;

    private Level.PlatformData selectedPlatform;
    private Level.EnemyData selectedEnemy;
    private Level.PowerupData selectedPowerup;
    private Level.GoalPostData selectedGoalPost; // NEW: Selected goal post

    private boolean isDragging = false;
    private float dragStartX, dragStartY;

    private ShapeRenderer shapeRenderer;
    private BitmapFont font;
    private Vector3 mousePos;

    private Array<Rectangle> platformTypeButtons;
    private Array<Platform.PlatformType> buttonPlatformTypes;
    private Rectangle goombaButton;
    private Rectangle koopaButton; // NEW: Koopa button
    private Array<Rectangle> powerupTypeButtons;
    private Array<Powerup.PowerupType> buttonPowerupTypes;
    private Rectangle goalPostButton; // NEW: Goal post button
    private Rectangle saveButton, loadButton, clearButton, playButton, previewButton;

    private Rectangle placementPreviewRect;
    private boolean showPlacementPreview = true;

    public enum EditorUIMode { EDITING, LEVEL_PREVIEW }
    private EditorUIMode currentUIMode = EditorUIMode.EDITING;
    private boolean hasUnappliedChanges = false;
    private BitmapFont notificationFont;

    private ArrayDeque<EditorCommand> undoStack = new ArrayDeque<>();
    private ArrayDeque<EditorCommand> redoStack = new ArrayDeque<>();
    private static final int MAX_HISTORY_SIZE = 100;

    private Array<String> availableBackgroundPaths;
    private Array<String> availableBackgroundNames;
    private Array<Rectangle> backgroundSelectorButtons;

    private Texture goombaPreviewTexture;
    private Texture koopaPreviewTexture; // NEW: Koopa preview texture
    private ObjectMap<Powerup.PowerupType, Texture> powerupPreviewTextures;
    private Texture goalPostPreviewTexture; // NEW: Goal post preview texture

    public LevelEditor() {
        this.currentLevel = new Level("New Level");
        this.shapeRenderer = new ShapeRenderer();
        this.font = new BitmapFont();
        this.notificationFont = new BitmapFont();
        this.mousePos = new Vector3();
        this.placementPreviewRect = new Rectangle();

        // Load preview textures
        try {
            goombaPreviewTexture = new Texture(Gdx.files.internal("mario_sprites/enemies/goomba_walk_0.png"));
        } catch (Exception e) {
            Gdx.app.error("LevelEditor", "Failed to load goomba_walk_0.png for editor preview: " + e.getMessage(), e);
            goombaPreviewTexture = null;
        }

        // NEW: Load Koopa preview texture
        try {
            koopaPreviewTexture = new Texture(Gdx.files.internal("mario_sprites/enemies/koopa/koopa_walk_0.png"));
        } catch (Exception e) {
            Gdx.app.error("LevelEditor", "Failed to load koopa_walk_0.png for editor preview: " + e.getMessage(), e);
            koopaPreviewTexture = null;
        }

        // NEW: Load goal post preview texture
        try {
            if (Gdx.files.internal("mario_sprites/world/goal_post.png").exists()) {
                goalPostPreviewTexture = new Texture(Gdx.files.internal("mario_sprites/world/goal_post.png"));
            } else if (Gdx.files.internal("mario_sprites/world/cannon.png").exists()) {
                goalPostPreviewTexture = new Texture(Gdx.files.internal("mario_sprites/world/cannon.png"));
            } else if (Gdx.files.internal("mario_sprites/world/brick.png").exists()) {
                goalPostPreviewTexture = new Texture(Gdx.files.internal("mario_sprites/world/brick.png"));
            } else {
                Gdx.app.error("LevelEditor", "No suitable goal post preview texture found");
                goalPostPreviewTexture = null;
            }
        } catch (Exception e) {
            Gdx.app.error("LevelEditor", "Failed to load goal post preview texture: " + e.getMessage());
            goalPostPreviewTexture = null;
        }

        // Load powerup preview textures
        powerupPreviewTextures = new ObjectMap<>();
        for (Powerup.PowerupType type : Powerup.PowerupType.values()) {
            try {
                Texture texture = new Texture(Gdx.files.internal(type.getTexturePath()));
                powerupPreviewTextures.put(type, texture);
            } catch (Exception e) {
                Gdx.app.error("LevelEditor", "Failed to load powerup preview for " + type.name() + ": " + e.getMessage());
                // Try to load coin as fallback
                try {
                    Texture fallback = new Texture(Gdx.files.internal("mario_sprites/world/coin.png"));
                    powerupPreviewTextures.put(type, fallback);
                } catch (Exception e2) {
                    Gdx.app.error("LevelEditor", "Failed to load fallback texture for " + type.name());
                }
            }
        }

        this.availableBackgroundPaths = new Array<>();
        this.availableBackgroundNames = new Array<>();
        this.backgroundSelectorButtons = new Array<>();
        this.powerupTypeButtons = new Array<>();
        this.buttonPowerupTypes = new Array<>();

        availableBackgroundPaths.add("mario_sprites/backgrounds/background_0.png");
        availableBackgroundNames.add("Sky (Default)");
        availableBackgroundPaths.add("mario_sprites/backgrounds/background_1.png");
        availableBackgroundNames.add("Hills");
        availableBackgroundPaths.add("mario_sprites/backgrounds/background_2.png");
        availableBackgroundNames.add("Night Sky");

        initializeUI();

        Level.PlatformData initialGround = new Level.PlatformData(
            0, 0, GRID_SIZE * DEFAULT_GROUND_WIDTH_MULTIPLIER, GRID_SIZE * DEFAULT_GROUND_HEIGHT_MULTIPLIER, Platform.PlatformType.GROUND
        );
        currentLevel.addPlatform(initialGround);
        this.hasUnappliedChanges = true;
    }

    private void initializeUI() {
        platformTypeButtons = new Array<>();
        buttonPlatformTypes = new Array<>();
        powerupTypeButtons.clear();
        buttonPowerupTypes.clear();
        backgroundSelectorButtons.clear();

        float viewportHeight = Gdx.graphics.getHeight();
        float currentY = viewportHeight - 20f;
        float buttonHeight = 28f;
        float buttonSpacing = 7f;
        float uiElementMargin = 10f;
        float buttonWidth = UI_PANEL_WIDTH - 2 * uiElementMargin;
        float sectionTitleHeight = 20f;
        float spaceAfterTitle = 5f;

        // --- Platforms Section ---
        currentY -= sectionTitleHeight;
        float nextButtonBottomY = currentY - spaceAfterTitle - buttonHeight;
        for (Platform.PlatformType type : Platform.PlatformType.values()) {
            Rectangle button = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
            platformTypeButtons.add(button);
            buttonPlatformTypes.add(type);
            nextButtonBottomY -= (buttonHeight + buttonSpacing);
        }
        currentY = nextButtonBottomY + buttonSpacing;

        // --- Enemies Section ---
        currentY -= sectionTitleHeight;
        nextButtonBottomY = currentY - spaceAfterTitle - buttonHeight;
        goombaButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
        nextButtonBottomY -= (buttonHeight + buttonSpacing);
        koopaButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight); // NEW: Koopa button
        currentY = nextButtonBottomY;

        // --- Powerups Section ---
        currentY -= sectionTitleHeight;
        nextButtonBottomY = currentY - spaceAfterTitle - buttonHeight;
        for (Powerup.PowerupType type : Powerup.PowerupType.values()) {
            Rectangle button = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
            powerupTypeButtons.add(button);
            buttonPowerupTypes.add(type);
            nextButtonBottomY -= (buttonHeight + buttonSpacing);
        }
        currentY = nextButtonBottomY;

        // --- NEW: Goal Post Section ---
        currentY -= sectionTitleHeight;
        nextButtonBottomY = currentY - spaceAfterTitle - buttonHeight;
        goalPostButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
        currentY = nextButtonBottomY;

        // --- Controls Section ---
        currentY -= sectionTitleHeight;
        nextButtonBottomY = currentY - spaceAfterTitle - buttonHeight;
        saveButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
        nextButtonBottomY -= (buttonHeight + buttonSpacing);
        loadButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
        nextButtonBottomY -= (buttonHeight + buttonSpacing);
        clearButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
        nextButtonBottomY -= (buttonHeight + buttonSpacing);
        previewButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
        nextButtonBottomY -= (buttonHeight + buttonSpacing);
        playButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
        currentY = nextButtonBottomY;

        // --- Backgrounds Section ---
        currentY -= sectionTitleHeight;
        nextButtonBottomY = currentY - spaceAfterTitle - buttonHeight;
        for (int i = 0; i < availableBackgroundPaths.size; i++) {
            Rectangle button = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
            backgroundSelectorButtons.add(button);
            nextButtonBottomY -= (buttonHeight + buttonSpacing);
        }
    }

    public void resize(int width, int height) {
        initializeUI();
    }

    private void executeCommand(EditorCommand command) {
        command.execute();
        undoStack.addLast(command);
        if (undoStack.size() > MAX_HISTORY_SIZE) undoStack.removeFirst();
        redoStack.clear();
        hasUnappliedChanges = true;
        selectedPlatform = null;
        selectedEnemy = null;
        selectedPowerup = null;
        selectedGoalPost = null; // NEW
    }

    private void undo() {
        if (!undoStack.isEmpty()) {
            EditorCommand command = undoStack.removeLast();
            command.undo();
            redoStack.addLast(command);
            if (redoStack.size() > MAX_HISTORY_SIZE) redoStack.removeFirst();
            hasUnappliedChanges = true;
            selectedPlatform = null;
            selectedEnemy = null;
            selectedPowerup = null;
            selectedGoalPost = null; // NEW
        }
    }

    private void redo() {
        if (!redoStack.isEmpty()) {
            EditorCommand command = redoStack.removeLast();
            command.execute();
            undoStack.addLast(command);
            if (undoStack.size() > MAX_HISTORY_SIZE) undoStack.removeFirst();
            hasUnappliedChanges = true;
            selectedPlatform = null;
            selectedEnemy = null;
            selectedPowerup = null;
            selectedGoalPost = null; // NEW
        }
    }

    public void update(OrthographicCamera camera) {
        mousePos.set(Gdx.input.getX(), Gdx.input.getY(), 0);
        camera.unproject(mousePos);

        if (currentUIMode == EditorUIMode.LEVEL_PREVIEW) {
            if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
                currentUIMode = EditorUIMode.EDITING;
            }
            return;
        }

        float snappedX = Math.round(mousePos.x / GRID_SIZE) * GRID_SIZE;
        float snappedY = Math.round(mousePos.y / GRID_SIZE) * GRID_SIZE;

        if (showPlacementPreview && mousePos.x > UI_PANEL_WIDTH) {
            if (currentTool == EditorTool.PLATFORM && isDragging) {
                float width = Math.abs(snappedX - dragStartX) + GRID_SIZE;
                float height = Math.abs(snappedY - dragStartY) + GRID_SIZE;
                float x = Math.min(snappedX, dragStartX);
                float y = Math.min(snappedY, dragStartY);
                placementPreviewRect.set(x, y, width, height);
            } else if (currentTool == EditorTool.GOAL_POST) { // NEW: Goal post preview
                placementPreviewRect.set(snappedX, snappedY, GoalPost.GOAL_POST_WIDTH, GoalPost.GOAL_POST_HEIGHT);
            } else {
                placementPreviewRect.set(snappedX, snappedY, GRID_SIZE, GRID_SIZE);
            }
        } else {
            placementPreviewRect.set(0,0,0,0);
        }
        handleEditorInput(snappedX, snappedY, camera);
    }

    private void handleEditorInput(float snappedX, float snappedY, OrthographicCamera camera) {
        boolean ctrlPressed = Gdx.input.isKeyPressed(Input.Keys.CONTROL_LEFT) || Gdx.input.isKeyPressed(Input.Keys.CONTROL_RIGHT);
        if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.Z)) { undo(); return; }
        if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.Y)) { redo(); return; }

        float camSpeed = 300 * Gdx.graphics.getDeltaTime();
        if (Gdx.input.isKeyPressed(Input.Keys.A) || Gdx.input.isKeyPressed(Input.Keys.LEFT)) camera.position.x -= camSpeed;
        if (Gdx.input.isKeyPressed(Input.Keys.D) || Gdx.input.isKeyPressed(Input.Keys.RIGHT)) camera.position.x += camSpeed;
        if (Gdx.input.isKeyPressed(Input.Keys.W) || Gdx.input.isKeyPressed(Input.Keys.UP)) camera.position.y += camSpeed;
        if (Gdx.input.isKeyPressed(Input.Keys.S) || Gdx.input.isKeyPressed(Input.Keys.DOWN)) camera.position.y -= camSpeed;
        camera.update();

        if (Gdx.input.isButtonJustPressed(Input.Buttons.LEFT)) handleLeftClick(snappedX, snappedY);
        if (Gdx.input.isButtonJustPressed(Input.Buttons.RIGHT)) handleRightClick(snappedX, snappedY);

        if (currentTool == EditorTool.PLATFORM && !Gdx.input.isButtonPressed(Input.Buttons.LEFT) && isDragging) {
            isDragging = false;
            if (placementPreviewRect.width >= GRID_SIZE && placementPreviewRect.height >= GRID_SIZE && mousePos.x > UI_PANEL_WIDTH) {
                Level.PlatformData newPlatform = new Level.PlatformData(
                    placementPreviewRect.x, placementPreviewRect.y, placementPreviewRect.width, placementPreviewRect.height, selectedPlatformType
                );

                // FIXED: Automatically assign powerups to question blocks for testing
                if (selectedPlatformType == Platform.PlatformType.QUESTION_BLOCK) {
                    newPlatform.containedPowerup = Powerup.PowerupType.MUSHROOM; // Default to mushroom
                    Gdx.app.log("LevelEditor", "Created question block with mushroom powerup");
                }

                executeCommand(new AddPlatformCommand(currentLevel, newPlatform));
            }
        }

        if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.S)) saveLevel();
        if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.L)) loadLevel();

        // Keyboard shortcuts
        if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_1)) { currentTool = EditorTool.PLATFORM; selectedPlatformType = Platform.PlatformType.GROUND; clearSelections();}
        if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_2)) { currentTool = EditorTool.PLATFORM; selectedPlatformType = Platform.PlatformType.GRAVEL_BLOCK; clearSelections();}
        if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_3)) { currentTool = EditorTool.PLATFORM; selectedPlatformType = Platform.PlatformType.QUESTION_BLOCK; clearSelections();}
        if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_4)) { currentTool = EditorTool.PLATFORM; selectedPlatformType = Platform.PlatformType.COIN; clearSelections();}
        if (Gdx.input.isKeyJustPressed(Input.Keys.G)) { currentTool = EditorTool.GOOMBA; clearSelections(); }
        if (Gdx.input.isKeyJustPressed(Input.Keys.K)) { currentTool = EditorTool.KOOPA; clearSelections(); } // NEW: Koopa shortcut
        if (Gdx.input.isKeyJustPressed(Input.Keys.M)) { currentTool = EditorTool.POWERUP; selectedPowerupType = Powerup.PowerupType.MUSHROOM; clearSelections(); }
        if (Gdx.input.isKeyJustPressed(Input.Keys.F)) { currentTool = EditorTool.POWERUP; selectedPowerupType = Powerup.PowerupType.FIRE_FLOWER; clearSelections(); }
        if (Gdx.input.isKeyJustPressed(Input.Keys.P)) { currentTool = EditorTool.GOAL_POST; clearSelections(); } // NEW: Goal post shortcut

        if (Gdx.input.isKeyJustPressed(Input.Keys.DEL) || Gdx.input.isKeyJustPressed(Input.Keys.BACKSPACE)) {
            if (selectedPlatform != null) {
                executeCommand(new RemovePlatformCommand(currentLevel, selectedPlatform));
                selectedPlatform = null;
            } else if (selectedEnemy != null) {
                executeCommand(new RemoveEnemyCommand(currentLevel, selectedEnemy));
                selectedEnemy = null;
            } else if (selectedPowerup != null) {
                executeCommand(new RemovePowerupCommand(currentLevel, selectedPowerup));
                selectedPowerup = null;
            } else if (selectedGoalPost != null) { // NEW: Delete goal post
                currentLevel.setGoalPostData(null);
                selectedGoalPost = null;
                hasUnappliedChanges = true;
            }
        }
    }

    private void clearSelections() {
        selectedPlatform = null;
        selectedEnemy = null;
        selectedPowerup = null;
        selectedGoalPost = null; // NEW
    }

    private void handleLeftClick(float snappedX, float snappedY) {
        Vector3 screenPos = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0);

        // Check UI buttons first
        for (int i = 0; i < platformTypeButtons.size; i++) {
            if (isScreenButtonClicked(platformTypeButtons.get(i), screenPos)) {
                currentTool = EditorTool.PLATFORM;
                selectedPlatformType = buttonPlatformTypes.get(i);
                clearSelections();
                return;
            }
        }
        if (goombaButton != null && isScreenButtonClicked(goombaButton, screenPos)) {
            currentTool = EditorTool.GOOMBA;
            clearSelections();
            return;
        }

        // NEW: Check Koopa button
        if (koopaButton != null && isScreenButtonClicked(koopaButton, screenPos)) {
            currentTool = EditorTool.KOOPA;
            clearSelections();
            return;
        }

        // Check powerup buttons
        for (int i = 0; i < powerupTypeButtons.size; i++) {
            if (isScreenButtonClicked(powerupTypeButtons.get(i), screenPos)) {
                currentTool = EditorTool.POWERUP;
                selectedPowerupType = buttonPowerupTypes.get(i);
                clearSelections();
                return;
            }
        }

        // NEW: Check goal post button
        if (goalPostButton != null && isScreenButtonClicked(goalPostButton, screenPos)) {
            currentTool = EditorTool.GOAL_POST;
            clearSelections();
            return;
        }

        if (saveButton != null && isScreenButtonClicked(saveButton, screenPos)) { saveLevel(); return; }
        if (loadButton != null && isScreenButtonClicked(loadButton, screenPos)) { loadLevel(); return; }
        if (clearButton != null && isScreenButtonClicked(clearButton, screenPos)) { clearLevel(); return; }
        if (previewButton != null && isScreenButtonClicked(previewButton, screenPos)) {
            currentUIMode = EditorUIMode.LEVEL_PREVIEW;
            clearSelections();
            isDragging = false;
            return;
        }
        if (playButton != null && isScreenButtonClicked(playButton, screenPos)) { return; }

        for (int i = 0; i < backgroundSelectorButtons.size; i++) {
            if (isScreenButtonClicked(backgroundSelectorButtons.get(i), screenPos)) {
                String newBgPath = availableBackgroundPaths.get(i);
                if (!newBgPath.equals(currentLevel.getBackgroundTexturePath())) {
                    currentLevel.setBackgroundTexturePath(newBgPath);
                    hasUnappliedChanges = true;
                }
                return;
            }
        }

        // If click is not on UI, it's in the game world
        if (mousePos.x > UI_PANEL_WIDTH) {
            clearSelections();
            boolean clickedExisting = false;

            // NEW: Check for clicking existing goal post first
            Level.GoalPostData goalPostData = currentLevel.getGoalPostData();
            if (goalPostData != null) {
                Rectangle goalPostRect = new Rectangle(goalPostData.x, goalPostData.y, GoalPost.GOAL_POST_WIDTH, GoalPost.GOAL_POST_HEIGHT);
                if (goalPostRect.contains(mousePos.x, mousePos.y)) {
                    selectedGoalPost = goalPostData;
                    clickedExisting = true;
                    currentTool = EditorTool.GOAL_POST;
                }
            }

            if (!clickedExisting) {
                // Check for clicking existing powerups
                for (Level.PowerupData powerup : currentLevel.getPowerupData()) {
                    Rectangle rect = new Rectangle(powerup.x, powerup.y, GRID_SIZE, GRID_SIZE);
                    if (rect.contains(mousePos.x, mousePos.y)) {
                        selectedPowerup = powerup;
                        clickedExisting = true;
                        currentTool = EditorTool.POWERUP;
                        try {
                            selectedPowerupType = Powerup.PowerupType.valueOf(powerup.type);
                        } catch (IllegalArgumentException e) {
                            selectedPowerupType = Powerup.PowerupType.MUSHROOM; // fallback
                        }
                        break;
                    }
                }
            }

            if (!clickedExisting) {
                // Check for clicking existing enemies
                for (Level.EnemyData enemy : currentLevel.getEnemyData()) {
                    Rectangle rect = new Rectangle(enemy.x, enemy.y, GRID_SIZE, GRID_SIZE);
                    if (rect.contains(mousePos.x, mousePos.y)) {
                        selectedEnemy = enemy;
                        clickedExisting = true;
                        currentTool = EditorTool.GOOMBA;
                        break;
                    }
                }
            }

            if (!clickedExisting) {
                // Check for clicking existing platforms
                for (Level.PlatformData platform : currentLevel.getPlatformData()) {
                    Rectangle rect = new Rectangle(platform.x, platform.y, platform.width, platform.height);
                    if (rect.contains(mousePos.x, mousePos.y)) {
                        selectedPlatform = platform;
                        clickedExisting = true;
                        currentTool = EditorTool.PLATFORM;
                        selectedPlatformType = platform.type;
                        break;
                    }
                }
            }

            // If nothing existing was clicked, try to place new element
            if (!clickedExisting) {
                if (currentTool == EditorTool.PLATFORM) {
                    boolean shiftPressed = Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT);
                    if (selectedPlatformType == Platform.PlatformType.GROUND || shiftPressed) {
                        isDragging = true;
                        dragStartX = snappedX;
                        dragStartY = snappedY;
                        placementPreviewRect.set(snappedX, snappedY, GRID_SIZE, GRID_SIZE);
                    } else {
                        Level.PlatformData newPlatform = new Level.PlatformData(
                            snappedX, snappedY, GRID_SIZE, GRID_SIZE, selectedPlatformType
                        );

                        // FIXED: Automatically assign powerups to question blocks for testing
                        if (selectedPlatformType == Platform.PlatformType.QUESTION_BLOCK) {
                            newPlatform.containedPowerup = Powerup.PowerupType.MUSHROOM; // Default to mushroom
                            Gdx.app.log("LevelEditor", "Created question block with mushroom powerup");
                        }

                        executeCommand(new AddPlatformCommand(currentLevel, newPlatform));
                    }
                } else if (currentTool == EditorTool.GOOMBA) {
                    Level.EnemyData newEnemy = new Level.EnemyData(snappedX, snappedY, "GOOMBA");
                    executeCommand(new AddEnemyCommand(currentLevel, newEnemy));
                } else if (currentTool == EditorTool.KOOPA) { // NEW: Koopa placement
                    Level.EnemyData newEnemy = new Level.EnemyData(snappedX, snappedY, "KOOPA");
                    executeCommand(new AddEnemyCommand(currentLevel, newEnemy));
                } else if (currentTool == EditorTool.POWERUP) {
                    Level.PowerupData newPowerup = new Level.PowerupData(snappedX, snappedY, selectedPowerupType.name());
                    executeCommand(new AddPowerupCommand(currentLevel, newPowerup));
                } else if (currentTool == EditorTool.GOAL_POST) { // NEW: Place goal post
                    currentLevel.setGoalPost(snappedX, snappedY);
                    hasUnappliedChanges = true;
                }
            }
        }
    }

    private void handleRightClick(float snappedX, float snappedY) {
        if (mousePos.x <= UI_PANEL_WIDTH) return;

        // NEW: Try removing goal post first
        Level.GoalPostData goalPostData = currentLevel.getGoalPostData();
        if (goalPostData != null) {
            Rectangle goalPostRect = new Rectangle(goalPostData.x, goalPostData.y, GoalPost.GOAL_POST_WIDTH, GoalPost.GOAL_POST_HEIGHT);
            if (goalPostRect.contains(mousePos.x, mousePos.y)) {
                currentLevel.setGoalPostData(null);
                if (goalPostData == selectedGoalPost) selectedGoalPost = null;
                hasUnappliedChanges = true;
                return;
            }
        }

        // Try removing powerups
        for (int i = currentLevel.getPowerupData().size - 1; i >= 0; i--) {
            Level.PowerupData powerup = currentLevel.getPowerupData().get(i);
            Rectangle rect = new Rectangle(powerup.x, powerup.y, GRID_SIZE, GRID_SIZE);
            if (rect.contains(mousePos.x, mousePos.y)) {
                executeCommand(new RemovePowerupCommand(currentLevel, powerup));
                if (powerup == selectedPowerup) selectedPowerup = null;
                return;
            }
        }

        // Try removing enemies
        for (int i = currentLevel.getEnemyData().size - 1; i >= 0; i--) {
            Level.EnemyData enemy = currentLevel.getEnemyData().get(i);
            Rectangle rect = new Rectangle(enemy.x, enemy.y, GRID_SIZE, GRID_SIZE);
            if (rect.contains(mousePos.x, mousePos.y)) {
                executeCommand(new RemoveEnemyCommand(currentLevel, enemy));
                if (enemy == selectedEnemy) selectedEnemy = null;
                return;
            }
        }

        // Try removing platforms
        for (int i = currentLevel.getPlatformData().size - 1; i >= 0; i--) {
            Level.PlatformData platform = currentLevel.getPlatformData().get(i);
            Rectangle rect = new Rectangle(platform.x, platform.y, platform.width, platform.height);
            if (rect.contains(mousePos.x, mousePos.y)) {
                executeCommand(new RemovePlatformCommand(currentLevel, platform));
                if (platform == selectedPlatform) selectedPlatform = null;
                return;
            }
        }
    }

    private boolean isScreenButtonClicked(Rectangle button, Vector3 screenPos) {
        float GdxYtoUIY = Gdx.graphics.getHeight() - screenPos.y;
        return button.contains(screenPos.x, GdxYtoUIY);
    }

    public void renderEditorElements(SpriteBatch batch, OrthographicCamera camera) {
        // 1. Draw Grid
        shapeRenderer.setProjectionMatrix(camera.combined);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(0.3f, 0.3f, 0.3f, 0.5f);
        float viewLeft = camera.position.x - camera.viewportWidth / 2f * camera.zoom;
        float viewRight = camera.position.x + camera.viewportWidth / 2f * camera.zoom;
        float viewBottom = camera.position.y - camera.viewportHeight / 2f * camera.zoom;
        float viewTop = camera.position.y + camera.viewportHeight / 2f * camera.zoom;
        for (float x = Math.round(viewLeft / GRID_SIZE) * GRID_SIZE; x < viewRight; x += GRID_SIZE) {
            shapeRenderer.line(x, viewBottom, x, viewTop);
        }
        for (float y = Math.round(viewBottom / GRID_SIZE) * GRID_SIZE; y < viewTop; y += GRID_SIZE) {
            shapeRenderer.line(viewLeft, y, viewRight, y);
        }
        shapeRenderer.end();

        // 2. Draw existing entities
        batch.setProjectionMatrix(camera.combined);
        batch.begin();

        // Draw enemies (Goombas and Koopas)
        if (goombaPreviewTexture != null) {
            for (Level.EnemyData enemyData : currentLevel.getEnemyData()) {
                if ("GOOMBA".equals(enemyData.type)) {
                    batch.draw(goombaPreviewTexture, enemyData.x, enemyData.y, GRID_SIZE, GRID_SIZE);
                }
            }
        }

        // NEW: Draw Koopas
        if (koopaPreviewTexture != null) {
            for (Level.EnemyData enemyData : currentLevel.getEnemyData()) {
                if ("KOOPA".equals(enemyData.type)) {
                    batch.draw(koopaPreviewTexture, enemyData.x, enemyData.y, GRID_SIZE, GRID_SIZE * 1.5f); // Taller than Goomba
                }
            }
        }

        // Draw powerups
        for (Level.PowerupData powerupData : currentLevel.getPowerupData()) {
            try {
                Powerup.PowerupType type = Powerup.PowerupType.valueOf(powerupData.type);
                Texture texture = powerupPreviewTextures.get(type);
                if (texture != null) {
                    batch.draw(texture, powerupData.x, powerupData.y, GRID_SIZE, GRID_SIZE);
                }
            } catch (IllegalArgumentException e) {
                // Invalid powerup type, skip
            }
        }

        // NEW: Draw goal post
        Level.GoalPostData goalPostData = currentLevel.getGoalPostData();
        if (goalPostData != null && goalPostPreviewTexture != null) {
            batch.draw(goalPostPreviewTexture, goalPostData.x, goalPostData.y, GoalPost.GOAL_POST_WIDTH, GoalPost.GOAL_POST_HEIGHT);
        }

        batch.end();

        // 3. Draw Selection Highlights
        shapeRenderer.setProjectionMatrix(camera.combined);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        if (selectedPlatform != null) {
            shapeRenderer.setColor(Color.YELLOW);
            shapeRenderer.rect(selectedPlatform.x, selectedPlatform.y, selectedPlatform.width, selectedPlatform.height);
        }
        if (selectedEnemy != null) {
            shapeRenderer.setColor(Color.CYAN);
            shapeRenderer.rect(selectedEnemy.x, selectedEnemy.y, GRID_SIZE, GRID_SIZE);
        }
        if (selectedPowerup != null) {
            shapeRenderer.setColor(Color.MAGENTA);
            shapeRenderer.rect(selectedPowerup.x, selectedPowerup.y, GRID_SIZE, GRID_SIZE);
        }
        if (selectedGoalPost != null) { // NEW: Goal post selection highlight
            shapeRenderer.setColor(Color.GREEN);
            shapeRenderer.rect(selectedGoalPost.x, selectedGoalPost.y, GoalPost.GOAL_POST_WIDTH, GoalPost.GOAL_POST_HEIGHT);
        }
        shapeRenderer.end();

        // 4. Draw Placement Preview
        if (showPlacementPreview && mousePos.x > UI_PANEL_WIDTH && placementPreviewRect.width > 0 && placementPreviewRect.height > 0) {
            if (currentTool == EditorTool.PLATFORM && isDragging ||
                currentTool != EditorTool.PLATFORM ||
                (currentTool == EditorTool.PLATFORM && !isDragging && !Gdx.input.isButtonPressed(Input.Buttons.LEFT))) {

                shapeRenderer.setProjectionMatrix(camera.combined);
                shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
                shapeRenderer.setColor(0.5f, 0.5f, 1f, 0.5f);
                shapeRenderer.rect(placementPreviewRect.x, placementPreviewRect.y, placementPreviewRect.width, placementPreviewRect.height);
                shapeRenderer.end();

                // Draw texture preview
                batch.setProjectionMatrix(camera.combined);
                batch.begin();
                batch.setColor(1, 1, 1, 0.5f);

                if (currentTool == EditorTool.GOOMBA && goombaPreviewTexture != null) {
                    batch.draw(goombaPreviewTexture, placementPreviewRect.x, placementPreviewRect.y, GRID_SIZE, GRID_SIZE);
                } else if (currentTool == EditorTool.KOOPA && koopaPreviewTexture != null) { // NEW: Koopa preview
                    batch.draw(koopaPreviewTexture, placementPreviewRect.x, placementPreviewRect.y, GRID_SIZE, GRID_SIZE * 1.5f);
                } else if (currentTool == EditorTool.POWERUP) {
                    Texture texture = powerupPreviewTextures.get(selectedPowerupType);
                    if (texture != null) {
                        batch.draw(texture, placementPreviewRect.x, placementPreviewRect.y, GRID_SIZE, GRID_SIZE);
                    }
                } else if (currentTool == EditorTool.GOAL_POST && goalPostPreviewTexture != null) { // NEW: Goal post preview
                    batch.draw(goalPostPreviewTexture, placementPreviewRect.x, placementPreviewRect.y, GoalPost.GOAL_POST_WIDTH, GoalPost.GOAL_POST_HEIGHT);
                }

                batch.setColor(1, 1, 1, 1f);
                batch.end();
            }
        }

        // 5. Draw UI Panel
        drawUIScreenPanel(batch);
    }

    private void drawUIScreenPanel(SpriteBatch batch) {
        batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        shapeRenderer.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());

        // 1. Draw Panel Background
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0.1f, 0.1f, 0.1f, 0.9f);
        shapeRenderer.rect(0, 0, UI_PANEL_WIDTH, Gdx.graphics.getHeight());
        shapeRenderer.end();

        // 2. Draw Text
        batch.begin();
        font.setColor(Color.WHITE);
        font.getData().setScale(0.9f);

        float textX = 15f;
        float titleX = 10f;
        float currentDrawingY = Gdx.graphics.getHeight() - 10f;
        float sectionTitleVisualHeight = font.getCapHeight() * font.getData().scaleY;
        float spaceBelowTitle = 10f;
        float spaceBelowButtonBlock = 18f;
        float buttonTextPaddingY = 4f;

        // --- Platforms Section ---
        font.draw(batch, "Platforms:", titleX, currentDrawingY);
        currentDrawingY -= (sectionTitleVisualHeight + spaceBelowTitle);
        for (int i = 0; i < platformTypeButtons.size; i++) {
            Rectangle button = platformTypeButtons.get(i);
            Platform.PlatformType type = buttonPlatformTypes.get(i);
            font.draw(batch, type.toString(), textX, button.y + font.getCapHeight() + buttonTextPaddingY);
        }
        if (!platformTypeButtons.isEmpty()) {
            currentDrawingY = platformTypeButtons.peek().y - spaceBelowButtonBlock;
        } else {
            currentDrawingY -= spaceBelowButtonBlock;
        }

        // --- Enemies Section ---
        font.draw(batch, "Enemies:", titleX, currentDrawingY);
        currentDrawingY -= (sectionTitleVisualHeight + spaceBelowTitle);
        if (goombaButton != null) {
            font.draw(batch, "Goomba (G)", textX, goombaButton.y + font.getCapHeight() + buttonTextPaddingY);
        }
        if (koopaButton != null) { // NEW: Koopa button text
            font.draw(batch, "Koopa (K)", textX, koopaButton.y + font.getCapHeight() + buttonTextPaddingY);
            currentDrawingY = koopaButton.y - spaceBelowButtonBlock;
        } else if (goombaButton != null) {
            currentDrawingY = goombaButton.y - spaceBelowButtonBlock;
        } else {
            currentDrawingY -= spaceBelowButtonBlock;
        }

        // --- Powerups Section ---
        font.draw(batch, "Powerups:", titleX, currentDrawingY);
        currentDrawingY -= (sectionTitleVisualHeight + spaceBelowTitle);
        for (int i = 0; i < powerupTypeButtons.size; i++) {
            Rectangle button = powerupTypeButtons.get(i);
            Powerup.PowerupType type = buttonPowerupTypes.get(i);
            String displayName = type.getName();
            if (type == Powerup.PowerupType.MUSHROOM) displayName += " (M)";
            else if (type == Powerup.PowerupType.FIRE_FLOWER) displayName += " (F)";
            font.draw(batch, displayName, textX, button.y + font.getCapHeight() + buttonTextPaddingY);
        }
        Rectangle lastPowerupButton = null;
        if (!powerupTypeButtons.isEmpty()) {
            lastPowerupButton = powerupTypeButtons.peek();
            currentDrawingY = lastPowerupButton.y - spaceBelowButtonBlock;
        } else {
            currentDrawingY -= spaceBelowButtonBlock;
        }

        // --- NEW: Goal Post Section ---
        font.draw(batch, "Goal Post:", titleX, currentDrawingY);
        currentDrawingY -= (sectionTitleVisualHeight + spaceBelowTitle);
        if (goalPostButton != null) {
            font.draw(batch, "Goal Post (End Level)", textX, goalPostButton.y + font.getCapHeight() + buttonTextPaddingY);
            currentDrawingY = goalPostButton.y - spaceBelowButtonBlock;
        } else {
            currentDrawingY -= spaceBelowButtonBlock;
        }

        // --- Controls Section ---
        font.draw(batch, "Controls:", titleX, currentDrawingY);
        currentDrawingY -= (sectionTitleVisualHeight + spaceBelowTitle);
        Rectangle[] controlButtons = {saveButton, loadButton, clearButton, previewButton, playButton};
        String[] controlLabels = {"Save (Ctrl+S)", "Load (Ctrl+L)", "Clear Level", "Preview Level", "Play Mode (P)"};
        Rectangle lastControlButton = null;
        for (int i = 0; i < controlButtons.length; i++) {
            if (controlButtons[i] != null) {
                font.draw(batch, controlLabels[i], textX, controlButtons[i].y + font.getCapHeight() + buttonTextPaddingY);
                lastControlButton = controlButtons[i];
            }
        }
        if (lastControlButton != null) {
            currentDrawingY = lastControlButton.y - spaceBelowButtonBlock;
        } else {
            currentDrawingY -= spaceBelowButtonBlock;
        }

        // --- Backgrounds Section ---
        font.draw(batch, "Backgrounds:", titleX, currentDrawingY);
        currentDrawingY -= (sectionTitleVisualHeight + spaceBelowTitle);
        Rectangle lastBackgroundButton = null;
        for (int i = 0; i < backgroundSelectorButtons.size; i++) {
            Rectangle button = backgroundSelectorButtons.get(i);
            String bgName = availableBackgroundNames.get(i);
            font.draw(batch, bgName, textX, button.y + font.getCapHeight() + buttonTextPaddingY);
            lastBackgroundButton = button;
        }
        if (lastBackgroundButton != null) {
            currentDrawingY = lastBackgroundButton.y - spaceBelowButtonBlock;
        } else {
            currentDrawingY -= spaceBelowButtonBlock;
        }

        // --- Instructions ---
        float instructionStartY = 200f;
        if(lastBackgroundButton != null) instructionStartY = Math.min(instructionStartY, lastBackgroundButton.y - 25f);
        else if (lastControlButton != null) instructionStartY = Math.min(instructionStartY, lastControlButton.y - 25f);
        else if (goalPostButton != null) instructionStartY = Math.min(instructionStartY, goalPostButton.y - 25f);
        else if (lastPowerupButton != null) instructionStartY = Math.min(instructionStartY, lastPowerupButton.y - 25f);
        else if (goombaButton != null) instructionStartY = Math.min(instructionStartY, goombaButton.y - 25f);
        else if (!platformTypeButtons.isEmpty()) instructionStartY = Math.min(instructionStartY, platformTypeButtons.peek().y - 25f);

        float lineHeight = 18f;
        if (instructionStartY > lineHeight * 12) {
            String toolInfo = "Tool: " + currentTool.toString();
            if (currentTool == EditorTool.PLATFORM) {
                toolInfo += " (" + selectedPlatformType.toString() + ")";
            } else if (currentTool == EditorTool.POWERUP) {
                toolInfo += " (" + selectedPowerupType.getName() + ")";
            }
            font.draw(batch, toolInfo, titleX, instructionStartY); instructionStartY -= lineHeight;
            font.draw(batch, "Ctrl+Z: Undo, Ctrl+Y: Redo", titleX, instructionStartY); instructionStartY -= lineHeight;
            font.draw(batch, "LMB: Place/Select", titleX, instructionStartY); instructionStartY -= lineHeight;
            font.draw(batch, "Shift+Drag: Resize Ground", titleX, instructionStartY); instructionStartY -= lineHeight;
            font.draw(batch, "RMB: Remove", titleX, instructionStartY); instructionStartY -= lineHeight;
            font.draw(batch, "Arrows/WASD: Move Cam", titleX, instructionStartY); instructionStartY -= lineHeight;
            font.draw(batch, "1-4: Platforms, G: Goomba", titleX, instructionStartY); instructionStartY -= lineHeight;
            font.draw(batch, "K: Koopa, M: Mushroom, F: Fire", titleX, instructionStartY); instructionStartY -= lineHeight; // NEW: Updated instructions
            font.draw(batch, "P: Goal Post", titleX, instructionStartY); instructionStartY -= lineHeight; // NEW
            font.draw(batch, "DEL/Bksp: Delete Selected", titleX, instructionStartY);
        }
        batch.end();

        // 3. Draw Button Borders
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        // Platforms
        for (int i = 0; i < platformTypeButtons.size; i++) {
            Rectangle button = platformTypeButtons.get(i);
            Platform.PlatformType type = buttonPlatformTypes.get(i);
            shapeRenderer.setColor((currentTool == EditorTool.PLATFORM && type == selectedPlatformType) ? Color.GREEN : Color.WHITE);
            shapeRenderer.rect(button.x, button.y, button.width, button.height);
        }
        // Enemies
        if (goombaButton != null) {
            shapeRenderer.setColor((currentTool == EditorTool.GOOMBA) ? Color.GREEN : Color.WHITE);
            shapeRenderer.rect(goombaButton.x, goombaButton.y, goombaButton.width, goombaButton.height);
        }
        // NEW: Koopa button border
        if (koopaButton != null) {
            shapeRenderer.setColor((currentTool == EditorTool.KOOPA) ? Color.GREEN : Color.WHITE);
            shapeRenderer.rect(koopaButton.x, koopaButton.y, koopaButton.width, koopaButton.height);
        }
        // Powerups
        for (int i = 0; i < powerupTypeButtons.size; i++) {
            Rectangle button = powerupTypeButtons.get(i);
            Powerup.PowerupType type = buttonPowerupTypes.get(i);
            shapeRenderer.setColor((currentTool == EditorTool.POWERUP && type == selectedPowerupType) ? Color.GREEN : Color.WHITE);
            shapeRenderer.rect(button.x, button.y, button.width, button.height);
        }
        // NEW: Goal Post
        if (goalPostButton != null) {
            shapeRenderer.setColor((currentTool == EditorTool.GOAL_POST) ? Color.GREEN : Color.WHITE);
            shapeRenderer.rect(goalPostButton.x, goalPostButton.y, goalPostButton.width, goalPostButton.height);
        }
        // Controls
        Color[] controlColors = {Color.WHITE, Color.WHITE, Color.WHITE, Color.ORANGE, Color.LIME};
        for (int i = 0; i < controlButtons.length; i++) {
            if (controlButtons[i] != null) {
                shapeRenderer.setColor(controlColors[i]);
                shapeRenderer.rect(controlButtons[i].x, controlButtons[i].y, controlButtons[i].width, controlButtons[i].height);
            }
        }
        // Backgrounds
        for (int i = 0; i < backgroundSelectorButtons.size; i++) {
            Rectangle button = backgroundSelectorButtons.get(i);
            shapeRenderer.setColor(availableBackgroundPaths.get(i).equals(currentLevel.getBackgroundTexturePath()) ? Color.CYAN : Color.LIGHT_GRAY);
            shapeRenderer.rect(button.x, button.y, button.width, button.height);
        }
        shapeRenderer.end();

        font.getData().setScale(1.0f);
    }

    public void renderPreviewNotification(SpriteBatch batch) {
        batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        batch.begin();
        notificationFont.setColor(Color.YELLOW);
        if (notificationFont != null) {
            notificationFont.draw(batch, "Preview Mode - Press ESC to exit", 20, Gdx.graphics.getHeight() - 20);
        }
        batch.end();
    }

    private void saveLevel() {
        Json json = new Json();
        FileHandle dir = Gdx.files.local("levels/");
        if (!dir.exists()) {
            dir.mkdirs();
        }
        FileHandle file = Gdx.files.local("levels/" + currentLevel.getName() + ".json");
        file.writeString(json.prettyPrint(currentLevel), false);
        Gdx.app.log("LevelEditor", "Level saved: " + file.path());
        hasUnappliedChanges = false;
    }

    private void loadLevel() {
        String levelName = currentLevel.getName();
        FileHandle file = Gdx.files.local("levels/" + levelName + ".json");
        if (file.exists()) {
            Json json = new Json();
            try {
                currentLevel = json.fromJson(Level.class, file.readString());
                undoStack.clear(); redoStack.clear();
                hasUnappliedChanges = false;
                clearSelections();
                hasUnappliedChanges = true;
                Gdx.app.log("LevelEditor", "Level loaded: " + file.path());
            } catch (Exception e) {
                Gdx.app.error("LevelEditor", "Failed to load/parse level: " + file.path(), e);
            }
        } else {
            Gdx.app.log("LevelEditor", "Level file not found: " + file.path());
        }
    }

    private void clearLevel() {
        Array<Level.PlatformData> platformsToBackup = new Array<>(currentLevel.getPlatformData());
        Level.PlatformData defaultGroundInstance = new Level.PlatformData(
            0, 0, GRID_SIZE * DEFAULT_GROUND_WIDTH_MULTIPLIER, GRID_SIZE * DEFAULT_GROUND_HEIGHT_MULTIPLIER, Platform.PlatformType.GROUND
        );

        executeCommand(new ClearLevelCommand(currentLevel, platformsToBackup, defaultGroundInstance));
        // Clear enemies, powerups, and goal post manually for simplicity
        currentLevel.getEnemyData().clear();
        currentLevel.getPowerupData().clear();
        currentLevel.setGoalPostData(null); // NEW: Clear goal post

        hasUnappliedChanges = true;
    }

    public Level getCurrentLevel() { return currentLevel; }
    public EditorUIMode getCurrentUIMode() { return currentUIMode; }
    public boolean hasUnappliedChanges() { return hasUnappliedChanges; }
    public void clearChangesFlag() { hasUnappliedChanges = false; }

    public boolean isPlayButtonClicked() {
        Vector3 screenPos = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0);
        return playButton != null && Gdx.input.isButtonJustPressed(Input.Buttons.LEFT) &&
            isScreenButtonClicked(playButton, screenPos);
    }

    public void dispose() {
        if (shapeRenderer != null) shapeRenderer.dispose();
        if (font != null) font.dispose();
        if (notificationFont != null) notificationFont.dispose();
        if (goombaPreviewTexture != null) goombaPreviewTexture.dispose();
        if (koopaPreviewTexture != null) koopaPreviewTexture.dispose(); // NEW: Dispose Koopa texture
        if (goalPostPreviewTexture != null) goalPostPreviewTexture.dispose(); // NEW

        // Dispose powerup preview textures
        if (powerupPreviewTextures != null) {
            for (Texture texture : powerupPreviewTextures.values()) {
                if (texture != null) texture.dispose();
            }
            powerupPreviewTextures.clear();
        }
    }
}

================
File: src/main/java/io/github/game/Main.gwt.xml
================
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit 2.11.0//EN" "https://www.gwtproject.org/doctype/2.11.0/gwt-module.dtd">
<module>
  <!-- Paths to source are relative to this file and separated by slashes ('/'). -->
  <source path="" />

  <!-- Reflection includes may be needed for your code or library code. Each value is separated by periods ('.'). -->
  <!-- You can include a full package by not including the name of a type at the end. -->

</module>

================
File: src/main/java/io/github/game/Main.java
================
// File: core/src/main/java/io/github/game/Main.java
package io.github.game;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.badlogic.gdx.utils.viewport.Viewport;

// Import specific enemy classes
import io.github.game.enemies.Enemy;
import io.github.game.enemies.Goomba;
import io.github.game.enemies.Koopa;

public class Main extends ApplicationAdapter {
    // World and Game Mechanics Constants
    private static final float WORLD_WIDTH = 800;
    private static final float WORLD_HEIGHT = 480;
    private static final float GRAVITY = -900f;
    private static final float MOVE_SPEED = 200f;
    private static final float JUMP_INITIAL_IMPULSE = 380f;
    private static final float JUMP_HOLD_GRAVITY_MULTIPLIER = 0.40f;
    private static final float MAX_JUMP_HOLD_TIME = 0.22f;
    public static final float SCALED_BLOCK_SIZE = 32f;
    private static final float PLAYER_STOMP_BOUNCE_VELOCITY = 250f;

    // Game States
    public enum GameMode {
        WORLD_MAP,
        PLAYING_LEVEL,
        LEVEL_EDITOR // Debug only
    }

    // Core Game Objects
    private SpriteBatch batch;
    private OrthographicCamera camera;
    private Viewport viewport;
    private Player player;
    private Background background;
    private Array<Platform> activePlatforms;
    private Array<Enemy> activeEnemies;// FIXED: Key methods for Main.java to replace existing methods

    private void loadLevelFromWorldMap(String levelName) {
        Gdx.app.log("Main", "Loading level: " + levelName);

        // Get the level file name from the world map
        String levelFileName = worldMap.getCurrentLevelFileName();
        if (levelFileName == null || levelFileName.isEmpty()) {
            Gdx.app.error("Main", "No level file name provided for: " + levelName);
            currentGameMode = GameMode.WORLD_MAP;
            return;
        }

        // Load the level using the world map's level loading system
        try {
            currentLevel = worldMap.loadLevelByFileName(levelFileName);
            if (currentLevel != null) {
                loadCurrentLevelData();
                currentGameMode = GameMode.PLAYING_LEVEL;

                // FIXED: Use enhanced GameStateManager method to enter level
                // Get current node info for proper state management
                WorldMapNode currentNode = null;
                for (WorldMapNode node : worldMap.getNodes()) {
                    if (node.getLevelName().equals(levelName)) {
                        currentNode = node;
                        break;
                    }
                }

                if (currentNode != null) {
                    gameStateManager.enterLevel(levelName, currentNode.getWorldNumber(), currentNode.getLevelNumber());
                } else {
                    // Fallback if node not found
                    gameStateManager.enterLevel(levelName, 1, 1);
                }

                // Play level music
                if (currentLevel.getBackgroundMusic() != null && !currentLevel.getBackgroundMusic().isEmpty()) {
                    soundManager.playMusic(currentLevel.getBackgroundMusic(), currentLevel.getMusicVolume());
                } else {
                    soundManager.stopMusic();
                }
            } else {
                Gdx.app.error("Main", "Failed to load level: " + levelName);
                currentGameMode = GameMode.WORLD_MAP;
                soundManager.stopMusic();
            }
        } catch (Exception e) {
            Gdx.app.error("Main", "Error loading level: " + levelName, e);
            currentGameMode = GameMode.WORLD_MAP;
            soundManager.stopMusic();
        }
    }

    // FIXED: Enhanced return to world map method
    private void returnToWorldMap() {
        currentGameMode = GameMode.WORLD_MAP;
        soundManager.stopMusic();

        // FIXED: Use enhanced GameStateManager method to exit to world map
        gameStateManager.exitToWorldMap();

        levelCompleted = false;
        gamePaused = false;

        // Ensure world map edit mode is disabled when returning
        if (worldMap.isEditMode()) {
            worldMap.setEditMode(false);
        }

        Gdx.app.log("Main", "Returned to World Map. Lives preserved: " + gameStateManager.getPersistentLives());
    }
    // FIXED: Enhanced level completion handling - simplified for world map return only
    private void handleLevelCompletion() {
        if (!levelCompleted) {
            levelCompleted = true;

            // Simply complete the level - world map will handle progression
            gameStateManager.completeLevel();
            soundManager.stopMusic();

            // Update world map progress
            if (currentLevel != null) {
                worldMap.completeLevel(currentLevel.getName());
            }

            Gdx.app.log("Game", "Level Completed! Returning to world map in 5 seconds...");
        }
    }


    // FIXED: Enhanced render level method with better state management
    private void renderLevel(float deltaTime) {
        // Handle game state updates
        gameStateManager.update(deltaTime);

        // FIXED: Enhanced game over and level complete handling
        if (gameStateManager.isGameOver()) {
            if (gameStateManager.isRetryClicked()) {
                gameStateManager.resetLevel(); // Use enhanced reset that preserves world map progress
                respawnPlayerAndResetLevel();
            } else if (gameStateManager.isQuitClicked()) {
                returnToWorldMap();
            } else if (gameStateManager.isWorldMapClicked()) { // NEW: Handle world map button
                returnToWorldMap();
            }
        }

        // FIXED: Simplified level complete handling - only world map return
        if (gameStateManager.isLevelComplete()) {
            if (gameStateManager.isWorldMapCompleteClicked()) {
                returnToWorldMap();
            }
        }

        if (!gamePaused && !levelCompleted && gameStateManager.isPlaying()) {
            updateGameLogic(deltaTime);
        } else {
            player.update(deltaTime);
            for (int i = activeEnemies.size - 1; i >= 0; i--) {
                Enemy enemy = activeEnemies.get(i);
                if (enemy.getCurrentState() == Enemy.EnemyState.STOMPED) {
                    enemy.update(deltaTime, activePlatforms, player);
                    if (!enemy.isAlive()) {
                        activeEnemies.removeIndex(i);
                    }
                }
            }
            for (int i = activePowerups.size - 1; i >= 0; i--) {
                Powerup powerup = activePowerups.get(i);
                powerup.update(deltaTime, activePlatforms);
                if (!powerup.isActive()) {
                    powerup.dispose();
                    activePowerups.removeIndex(i);
                }
            }
            if (goalPost != null) {
                goalPost.update(deltaTime);
            }
        }

        // FIXED: Enhanced player death handling
        if (player.getCurrentState() == Player.State.DEATH && player.getStateTimer() > Player.DEATH_ANIMATION_DURATION) {
            gameStateManager.loseLife();
            if (!gameStateManager.isGameOver()) {
                respawnPlayerAndResetLevel();
            }
        }

        // Camera following logic (unchanged)
        if (!levelCompleted && gameStateManager.isPlaying()) {
            camera.position.x = player.getPosition().x + Player.PLAYER_WIDTH / 2f + 100f;
            camera.position.y = Math.max(WORLD_HEIGHT / 2f, player.getPosition().y + Player.PLAYER_HEIGHT / 2f - WORLD_HEIGHT / 4f + 50f);
            camera.position.x = Math.max(camera.viewportWidth / 2f, camera.position.x);
            camera.position.y = Math.max(camera.viewportHeight / 2f, camera.position.y);
        }
        camera.update();

        batch.setProjectionMatrix(camera.combined);
        batch.begin();
        background.render(batch, camera);
        for (Platform item : activePlatforms) item.render(batch);
        for (Enemy enemy : activeEnemies) enemy.render(batch);
        for (Powerup powerup : activePowerups) powerup.render(batch);
        if (goalPost != null) goalPost.render(batch);
        player.render(batch);
        batch.end();

        gameStateManager.renderUI(batch, camera);
    }


    // FIXED: Enhanced respawn method that works with persistent stats
    private void respawnPlayerAndResetLevel() {
        gamePaused = false;
        levelCompleted = false;
        if (currentLevel == null) return;

        player.respawn(currentLevel.getPlayerStartX(), currentLevel.getPlayerStartY());

        // Reset enemies
        activeEnemies.clear();
        if (goombaWalkFrame1Tex != null && goombaWalkFrame2Tex != null && goombaSquashedTex != null) {
            for (Level.EnemyData data : currentLevel.getEnemyData()) {
                if ("GOOMBA".equals(data.type)) {
                    activeEnemies.add(new Goomba(goombaWalkFrame1Tex, goombaWalkFrame2Tex, goombaSquashedTex, data.x, data.y));
                } else if ("KOOPA".equals(data.type)) {
                    if (koopaWalkFrame1Tex != null && koopaWalkFrame2Tex != null && koopaShellIdleTex != null &&
                        koopaShellMove1Tex != null && koopaShellMove2Tex != null &&
                        koopaShellMove3Tex != null && koopaShellMove4Tex != null) {
                        activeEnemies.add(new Koopa(koopaWalkFrame1Tex, koopaWalkFrame2Tex, koopaShellIdleTex,
                            koopaShellMove1Tex, koopaShellMove2Tex, koopaShellMove3Tex, koopaShellMove4Tex,
                            data.x, data.y));
                    }
                }
            }
        }

        // Reset powerups
        for (Powerup powerup : activePowerups) {
            powerup.dispose();
        }
        activePowerups.clear();
        for (Level.PowerupData data : currentLevel.getPowerupData()) {
            try {
                Powerup.PowerupType type = Powerup.PowerupType.valueOf(data.type);
                activePowerups.add(new Powerup(type, data.x, data.y));
            } catch (IllegalArgumentException e) {
                Gdx.app.error("RespawnLevel", "Unknown powerup type: " + data.type);
            }
        }

        // Reset goal post
        if (goalPost != null) {
            goalPost.dispose();
        }
        goalPost = currentLevel.createGoalPost();

        // Reset platforms
        activePlatforms.clear();
        activePlatforms.addAll(currentLevel.createPlatforms());

        camera.position.x = player.getPosition().x + Player.PLAYER_WIDTH / 2f + 100f;
        camera.position.y = Math.max(WORLD_HEIGHT / 2f, player.getPosition().y + Player.PLAYER_HEIGHT / 2f);
        camera.update();

        if (currentLevel.getBackgroundMusic() != null && !currentLevel.getBackgroundMusic().isEmpty()) {
            soundManager.playMusic(currentLevel.getBackgroundMusic(), currentLevel.getMusicVolume());
        } else {
            soundManager.stopMusic();
        }
        playerIsHoldingJumpKey = false;
        playerJumpHoldTimer = 0f;

        Gdx.app.log("Main", "Level respawned. Lives: " + gameStateManager.getLives());
    }
    private Array<Powerup> activePowerups;
    private GoalPost goalPost;

    // Individual textures for Goomba
    private Texture goombaWalkFrame1Tex;
    private Texture goombaWalkFrame2Tex;
    private Texture goombaSquashedTex;

    // Individual textures for Koopa
    private Texture koopaWalkFrame1Tex;
    private Texture koopaWalkFrame2Tex;
    private Texture koopaShellIdleTex;
    private Texture koopaShellMove1Tex;
    private Texture koopaShellMove2Tex;
    private Texture koopaShellMove3Tex;
    private Texture koopaShellMove4Tex;

    // Game Systems
    private WorldMap worldMap; // NEW: World map system
    private LevelEditor levelEditor; // DEBUG ONLY
    private GameStateManager gameStateManager;
    private GameMode currentGameMode;
    private Level currentLevel; // Current level being played

    // Debug Mode - FIXED: Better debug mode detection
    private boolean debugMode = false;
    private boolean gamePaused = false;
    private boolean levelCompleted = false;
    private boolean showDebugInfo = false; // NEW: Toggle for debug info display

    // Utility
    private SoundManager soundManager;
    private Texture playerIdleTexture;

    // Player jump state variables
    private boolean playerIsHoldingJumpKey = false;
    private float playerJumpHoldTimer = 0f;

    @Override
    public void create() {
        camera = new OrthographicCamera();
        viewport = new FitViewport(WORLD_WIDTH, WORLD_HEIGHT, camera);
        camera.position.set(WORLD_WIDTH / 2f, WORLD_HEIGHT / 2f, 0);

        batch = new SpriteBatch();
        soundManager = SoundManager.getInstance();
        player = new Player(150, Platform.GROUND_TILE_SIZE * 2);

        // FIXED: Better debug mode detection
        debugMode = checkDebugMode();
        Gdx.app.log("Main", "Debug mode: " + (debugMode ? "ENABLED" : "DISABLED"));

        try {
            playerIdleTexture = new Texture(Gdx.files.internal("mario_sprites/playables/mario/mario_idle.png"));
            loadEnemyTextures();
        } catch (Exception e) {
            Gdx.app.error("MainCreate", "Failed to load essential textures", e);
        }

        background = new Background();
        activePlatforms = new Array<>();
        activeEnemies = new Array<>();
        activePowerups = new Array<>();

        gameStateManager = new GameStateManager();

        // Initialize world map system - FIXED: Pass debug mode properly
        worldMap = new WorldMap(debugMode);
        currentGameMode = GameMode.WORLD_MAP;

        // Initialize level editor only in debug mode
        if (debugMode) {
            levelEditor = new LevelEditor();
            Gdx.app.log("Main", "Debug mode enabled - Level editor available (F1), World map editor available (F2)");
        }

        Gdx.app.log("Main", "Game initialized. Starting on world map.");

        // NEW: Show debug controls info
        if (debugMode) {
            Gdx.app.log("Main", "=== DEBUG CONTROLS ===");
            Gdx.app.log("Main", "F1: Level Editor");
            Gdx.app.log("Main", "F2: World Map Editor");
            Gdx.app.log("Main", "F3: Toggle Debug Info");
            Gdx.app.log("Main", "ESC: Return to World Map");
            Gdx.app.log("Main", "======================");
        }
    }

    private boolean checkDebugMode() {
        // FIXED: Multiple ways to enable debug mode

        // 1. Check system property
        String debugProperty = System.getProperty("debug");
        if ("true".equals(debugProperty)) {
            Gdx.app.log("Main", "Debug mode enabled via system property");
            return true;
        }

        // 2. Check for debug file
        if (Gdx.files.local("debug.txt").exists()) {
            Gdx.app.log("Main", "Debug mode enabled via debug.txt file");
            return true;
        }

        // 3. Check for development environment (existence of levels directory)
        if (Gdx.files.local("levels/").exists()) {
            Gdx.app.log("Main", "Debug mode enabled - levels directory detected");
            return true;
        }

        // 4. Hardcoded for development (change to false for release)
        boolean hardcodedDebug = true; // SET TO FALSE FOR RELEASE
        if (hardcodedDebug) {
            Gdx.app.log("Main", "Debug mode enabled - hardcoded for development");
            return true;
        }

        return false;
    }

    private void loadEnemyTextures() {
        // Load Goomba Textures
        goombaWalkFrame1Tex = new Texture(Gdx.files.internal("mario_sprites/enemies/goomba_walk_0.png"));
        goombaWalkFrame2Tex = new Texture(Gdx.files.internal("mario_sprites/enemies/goomba_walk_1.png"));

        if (Gdx.files.internal("mario_sprites/enemies/goomba_squashed.png").exists()) {
            goombaSquashedTex = new Texture(Gdx.files.internal("mario_sprites/enemies/goomba_squashed.png"));
        } else {
            goombaSquashedTex = goombaWalkFrame1Tex;
            Gdx.app.log("MainCreate", "goomba_squashed.png not found, using goomba_walk_0.png as placeholder.");
        }

        // Load Koopa Textures
        koopaWalkFrame1Tex = new Texture(Gdx.files.internal("mario_sprites/enemies/koopa/koopa_walk_0.png"));
        koopaWalkFrame2Tex = new Texture(Gdx.files.internal("mario_sprites/enemies/koopa/koopa_walk_1.png"));
        koopaShellIdleTex = new Texture(Gdx.files.internal("mario_sprites/enemies/koopa/red_shell_idle.png"));
        koopaShellMove1Tex = new Texture(Gdx.files.internal("mario_sprites/enemies/koopa/red_shell_move_0.png"));
        koopaShellMove2Tex = new Texture(Gdx.files.internal("mario_sprites/enemies/koopa/red_shell_move_1.png"));
        koopaShellMove3Tex = new Texture(Gdx.files.internal("mario_sprites/enemies/koopa/red_shell_move_2.png"));
        koopaShellMove4Tex = new Texture(Gdx.files.internal("mario_sprites/enemies/koopa/red_shell_move_3.png"));
    }


    private Level loadLevelByName(String levelName) {
        // Map level names to actual level files
        String fileName = mapLevelNameToFile(levelName);

        try {
            if (Gdx.files.local("levels/" + fileName).exists()) {
                com.badlogic.gdx.utils.Json json = new com.badlogic.gdx.utils.Json();
                return json.fromJson(Level.class, Gdx.files.local("levels/" + fileName).readString());
            } else {
                // Create a default level if file doesn't exist
                return createDefaultLevel(levelName);
            }
        } catch (Exception e) {
            Gdx.app.error("Main", "Failed to load level file: " + fileName, e);
            return createDefaultLevel(levelName);
        }
    }

    private String mapLevelNameToFile(String levelName) {
        // Map world map level names to actual level files
        switch (levelName) {
            case "Level 1-1": return "level_1_1.json";
            case "Level 1-2": return "level_1_2.json";
            case "Level 1-3": return "level_1_3.json";
            case "Level 1-4": return "level_1_4.json";
            case "Level 2-1": return "level_2_1.json";
            case "Level 2-2": return "level_2_2.json";
            case "Level 2-3": return "level_2_3.json";
            case "Level 2-4": return "level_2_4.json";
            case "Level 3-1": return "level_3_1.json";
            case "Level 3-2": return "level_3_2.json";
            case "Level 3-3": return "level_3_3.json";
            case "Level 3-4": return "level_3_4.json";
            case "Level 4-1": return "level_4_1.json";
            case "Level 4-2": return "level_4_2.json";
            case "Level 4-3": return "level_4_3.json";
            case "Level 4-4": return "level_4_4.json";
            case "Warp Zone": return "warp_zone.json";
            default: return "default_level.json";
        }
    }

    private Level createDefaultLevel(String levelName) {
        Gdx.app.log("Main", "Creating default level for: " + levelName);

        Level level = new Level(levelName);

        // Add basic ground platform
        Level.PlatformData ground = new Level.PlatformData(
            0, 0, 32f * 20, 32f * 2, Platform.PlatformType.GROUND
        );
        level.addPlatform(ground);

        // Add some basic platforms and enemies based on level name
        if (levelName.contains("1-")) {
            // World 1 style - simple grass levels
            addWorld1Elements(level);
        } else if (levelName.contains("2-")) {
            // World 2 style - desert levels
            addWorld2Elements(level);
        } else if (levelName.contains("3-")) {
            // World 3 style - water levels
            addWorld3Elements(level);
        } else if (levelName.contains("4-")) {
            // World 4 style - ice levels
            addWorld4Elements(level);
        }

        // Add goal post at the end
        level.setGoalPost(32f * 18, 32f * 2);

        return level;
    }

    private void addWorld1Elements(Level level) {
        // Add some basic platforms
        level.addPlatform(new Level.PlatformData(200, 96, 32, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(300, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(400, 96, 96, 32, Platform.PlatformType.GRAVEL_BLOCK));

        // Add some enemies
        level.addEnemy(new Level.EnemyData(250, 64, "GOOMBA"));
        level.addEnemy(new Level.EnemyData(350, 64, "GOOMBA"));

        // Add some powerups
        level.addPowerup(new Level.PowerupData(300, 160, "MUSHROOM"));
    }

    private void addWorld2Elements(Level level) {
        // Desert theme - more challenging
        level.addPlatform(new Level.PlatformData(150, 128, 32, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(250, 160, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(350, 96, 128, 32, Platform.PlatformType.GRAVEL_BLOCK));

        // Add Koopa enemies for variety
        level.addEnemy(new Level.EnemyData(200, 64, "KOOPA"));
        level.addEnemy(new Level.EnemyData(300, 64, "GOOMBA"));
        level.addEnemy(new Level.EnemyData(400, 128, "KOOPA"));
    }

    private void addWorld3Elements(Level level) {
        // Water theme
        level.addPlatform(new Level.PlatformData(180, 128, 64, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(300, 160, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(420, 128, 64, 32, Platform.PlatformType.GRAVEL_BLOCK));

        level.addEnemy(new Level.EnemyData(220, 160, "GOOMBA"));
        level.addEnemy(new Level.EnemyData(460, 160, "KOOPA"));

        level.addPowerup(new Level.PowerupData(300, 192, "FIRE_FLOWER"));
    }

    private void addWorld4Elements(Level level) {
        // Ice theme - most challenging
        level.addPlatform(new Level.PlatformData(160, 160, 32, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(240, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(320, 160, 32, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(400, 96, 96, 32, Platform.PlatformType.GRAVEL_BLOCK));

        level.addEnemy(new Level.EnemyData(200, 192, "KOOPA"));
        level.addEnemy(new Level.EnemyData(280, 64, "GOOMBA"));
        level.addEnemy(new Level.EnemyData(360, 192, "KOOPA"));
        level.addEnemy(new Level.EnemyData(440, 128, "GOOMBA"));

        level.addPowerup(new Level.PowerupData(240, 160, "STAR"));
    }

    private void loadCurrentLevelData() {
        if (currentLevel == null) return;

        activePlatforms.clear();
        activePlatforms.addAll(currentLevel.createPlatforms());

        activeEnemies.clear();
        if (goombaWalkFrame1Tex != null && goombaWalkFrame2Tex != null && goombaSquashedTex != null) {
            for (Level.EnemyData data : currentLevel.getEnemyData()) {
                if ("GOOMBA".equals(data.type)) {
                    activeEnemies.add(new Goomba(goombaWalkFrame1Tex, goombaWalkFrame2Tex, goombaSquashedTex, data.x, data.y));
                } else if ("KOOPA".equals(data.type)) {
                    if (koopaWalkFrame1Tex != null && koopaWalkFrame2Tex != null && koopaShellIdleTex != null &&
                        koopaShellMove1Tex != null && koopaShellMove2Tex != null &&
                        koopaShellMove3Tex != null && koopaShellMove4Tex != null) {
                        activeEnemies.add(new Koopa(koopaWalkFrame1Tex, koopaWalkFrame2Tex, koopaShellIdleTex,
                            koopaShellMove1Tex, koopaShellMove2Tex, koopaShellMove3Tex, koopaShellMove4Tex,
                            data.x, data.y));
                    }
                }
            }
        }

        // Load powerups from level data
        activePowerups.clear();
        for (Level.PowerupData data : currentLevel.getPowerupData()) {
            try {
                Powerup.PowerupType type = Powerup.PowerupType.valueOf(data.type);
                activePowerups.add(new Powerup(type, data.x, data.y));
            } catch (IllegalArgumentException e) {
                Gdx.app.error("LoadLevelData", "Unknown powerup type: " + data.type);
            }
        }

        // Load goal post
        if (goalPost != null) {
            goalPost.dispose();
        }
        goalPost = currentLevel.createGoalPost();
        levelCompleted = false;

        background.setTexture(currentLevel.getBackgroundTexturePath());
        player.respawn(currentLevel.getPlayerStartX(), currentLevel.getPlayerStartY());
        player.getVelocity().set(0,0);

        gamePaused = false;
    }

    @Override
    public void render() {
        Gdx.gl.glClearColor(0.4f, 0.7f, 1, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        float deltaTime = Gdx.graphics.getDeltaTime();

        handleGlobalInput();

        switch (currentGameMode) {
            case WORLD_MAP:
                renderWorldMap(deltaTime);
                break;
            case PLAYING_LEVEL:
                renderLevel(deltaTime);
                break;
            case LEVEL_EDITOR:
                if (debugMode) {
                    renderLevelEditor(deltaTime);
                } else {
                    currentGameMode = GameMode.WORLD_MAP;
                }
                break;
        }
    }

    private void handleGlobalInput() {
        // FIXED: Comprehensive global debug controls
        if (debugMode) {
            // F1: Level Editor
            if (Gdx.input.isKeyJustPressed(Input.Keys.F1)) {
                if (currentGameMode != GameMode.LEVEL_EDITOR) {
                    currentGameMode = GameMode.LEVEL_EDITOR;
                    soundManager.stopMusic();
                    Gdx.app.log("Main", "Switched to Level Editor (Debug Mode)");
                } else {
                    returnToWorldMap();
                }
            }

            // FIXED: F2: World Map Editor
            if (Gdx.input.isKeyJustPressed(Input.Keys.F2)) {
                if (currentGameMode == GameMode.WORLD_MAP) {
                    // Toggle world map edit mode
                    worldMap.toggleEditMode();
                    if (worldMap.isEditMode()) {
                        Gdx.app.log("Main", "World Map Edit Mode ENABLED");
                        Gdx.app.log("Main", "Controls: Click/drag nodes, WASD camera, F3 save, ESC/F2 exit");
                    } else {
                        Gdx.app.log("Main", "World Map Edit Mode DISABLED");
                    }
                } else {
                    // Switch to world map first
                    returnToWorldMap();
                    Gdx.app.log("Main", "Returned to World Map. Press F2 again to enter edit mode.");
                }
            }

            // NEW: F3: Toggle debug info display
            if (Gdx.input.isKeyJustPressed(Input.Keys.F3)) {
                showDebugInfo = !showDebugInfo;
                Gdx.app.log("Main", "Debug info display: " + (showDebugInfo ? "ON" : "OFF"));
            }
        }

        // ESC to return to world map from level or level editor
        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            if (currentGameMode == GameMode.PLAYING_LEVEL ||
                (currentGameMode == GameMode.LEVEL_EDITOR && debugMode)) {
                returnToWorldMap();
            } else if (currentGameMode == GameMode.WORLD_MAP && worldMap.isEditMode()) {
                // Exit world map edit mode
                worldMap.setEditMode(false);
                Gdx.app.log("Main", "Exited World Map Edit Mode");
            }
        }
    }



    private void renderWorldMap(float deltaTime) {
        // FIXED: Pass camera to world map for proper edit mode functionality
        worldMap.update(deltaTime, camera);

        // Check if player selected a level
        if (worldMap.isLevelSelectionMode()) {
            String selectedLevel = worldMap.getCurrentLevelName();
            if (selectedLevel != null) {
                loadLevelFromWorldMap(selectedLevel);
                worldMap.setLevelSelectionMode(false);
            }
        }

        worldMap.render(batch, camera);

        // NEW: Render debug info if enabled
        if (debugMode && showDebugInfo) {
            renderWorldMapDebugInfo();
        }
    }

    // NEW: Debug info for world map
    private void renderWorldMapDebugInfo() {
        batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        batch.begin();

        // You would need a font here - this is just conceptual
        // In a real implementation, you'd use a BitmapFont

        batch.end();
    }

    private void renderLevelEditor(float deltaTime) {
        if (!debugMode || levelEditor == null) {
            currentGameMode = GameMode.WORLD_MAP;
            return;
        }

        if (levelEditor.hasUnappliedChanges()) {
            // Load level editor changes if needed
            currentLevel = levelEditor.getCurrentLevel();
            loadCurrentLevelData();
            levelEditor.clearChangesFlag();
        }

        levelEditor.update(camera);

        if (levelEditor.getCurrentUIMode() == LevelEditor.EditorUIMode.EDITING) {
            camera.update();
            batch.setProjectionMatrix(camera.combined);
            batch.begin();
            background.render(batch, camera);
            for (Platform item : activePlatforms) item.render(batch);
            if (goalPost != null) goalPost.render(batch);
            batch.end();
            levelEditor.renderEditorElements(batch, camera);
        } else if (levelEditor.getCurrentUIMode() == LevelEditor.EditorUIMode.LEVEL_PREVIEW) {
            Level editorLevel = levelEditor.getCurrentLevel();
            background.setTexture(editorLevel.getBackgroundTexturePath());

            float targetX = editorLevel.getPlayerStartX() + Player.PLAYER_WIDTH / 2f;
            float targetY = editorLevel.getPlayerStartY() + Player.PLAYER_HEIGHT / 2f;
            camera.position.set(targetX + 100, Math.max(WORLD_HEIGHT / 2f, targetY + 50), 0);
            camera.update();

            batch.setProjectionMatrix(camera.combined);
            batch.begin();
            background.render(batch, camera);
            for (Platform p : activePlatforms) p.render(batch);
            for (Enemy enemy : activeEnemies) enemy.render(batch);
            for (Powerup powerup : activePowerups) powerup.render(batch);
            if (goalPost != null) goalPost.render(batch);
            if (playerIdleTexture != null) {
                batch.draw(playerIdleTexture, editorLevel.getPlayerStartX(), editorLevel.getPlayerStartY(), Player.PLAYER_WIDTH, Player.PLAYER_HEIGHT);
            }
            batch.end();
            levelEditor.renderPreviewNotification(batch);
        }
    }

    private void updateGameLogic(float deltaTime) {
        if (player.getCurrentState() == Player.State.DEATH) {
            gamePaused = true;
            return;
        }

        handlePlayerInput(deltaTime);

        float effectiveGravity = GRAVITY;
        boolean jumpKeyIsCurrentlyHeld = Gdx.input.isKeyPressed(Input.Keys.UP) ||
            Gdx.input.isKeyPressed(Input.Keys.W) ||
            Gdx.input.isKeyPressed(Input.Keys.SPACE);

        if (playerIsHoldingJumpKey && jumpKeyIsCurrentlyHeld && player.getVelocity().y > 0 && playerJumpHoldTimer < MAX_JUMP_HOLD_TIME) {
            effectiveGravity = GRAVITY * JUMP_HOLD_GRAVITY_MULTIPLIER;
            playerJumpHoldTimer += deltaTime;
        } else {
            playerIsHoldingJumpKey = false;
        }
        player.getVelocity().y += effectiveGravity * deltaTime;

        player.getPosition().x += player.getVelocity().x * deltaTime;
        player.getBounds().setX(player.getPosition().x);
        checkHorizontalCollisions(player, activePlatforms);

        player.getPosition().y += player.getVelocity().y * deltaTime;
        player.getBounds().setY(player.getPosition().y);
        checkVerticalCollisions(player, activePlatforms);

        player.update(deltaTime);
        collectCoins();

        // Update enemies
        for (int i = activeEnemies.size - 1; i >= 0; i--) {
            Enemy enemy = activeEnemies.get(i);
            enemy.update(deltaTime, activePlatforms, player);
            if (!enemy.isAlive() && enemy.getCurrentState() == Enemy.EnemyState.DEAD) {
                activeEnemies.removeIndex(i);
            }
        }

        checkShellEnemyCollisions();
        checkPlayerEnemyCollisions();

        // Update powerups
        for (int i = activePowerups.size - 1; i >= 0; i--) {
            Powerup powerup = activePowerups.get(i);
            powerup.update(deltaTime, activePlatforms);
            if (!powerup.isActive()) {
                powerup.dispose();
                activePowerups.removeIndex(i);
            }
        }
        checkPlayerPowerupCollisions();

        // Update goal post and check completion
        if (goalPost != null) {
            goalPost.update(deltaTime);
            if (goalPost.checkPlayerCollision(player.getBounds())) {
                handleLevelCompletion();
            }
        }

        if (player.getPosition().y < -Player.PLAYER_HEIGHT * 2 && player.getCurrentState() != Player.State.DEATH) {
            player.die();
        }
    }

    // All the existing methods remain the same
    private void handlePlayerInput(float deltaTime) {
        if (player.getCurrentState() == Player.State.DEATH || levelCompleted || !gameStateManager.isPlaying()) return;

        if (Gdx.input.isKeyPressed(Input.Keys.RIGHT) || Gdx.input.isKeyPressed(Input.Keys.D)) {
            player.getVelocity().x = MOVE_SPEED;
            player.setFacingRight(false);
            if (player.isGrounded()) player.setCurrentState(Player.State.WALKING);
        } else if (Gdx.input.isKeyPressed(Input.Keys.LEFT) || Gdx.input.isKeyPressed(Input.Keys.A)) {
            player.getVelocity().x = -MOVE_SPEED;
            player.setFacingRight(true);
            if (player.isGrounded()) player.setCurrentState(Player.State.WALKING);
        } else {
            player.getVelocity().x = 0;
            if (player.isGrounded() && player.getCurrentState() == Player.State.WALKING) {
                player.setCurrentState(Player.State.IDLE);
            }
        }

        boolean jumpKeyPressedThisFrame = Gdx.input.isKeyJustPressed(Input.Keys.UP) ||
            Gdx.input.isKeyJustPressed(Input.Keys.W) ||
            Gdx.input.isKeyJustPressed(Input.Keys.SPACE);

        if (jumpKeyPressedThisFrame && player.isGrounded()) {
            player.getVelocity().y = JUMP_INITIAL_IMPULSE;
            player.setGrounded(false);
            player.setCurrentState(Player.State.JUMPING);
            soundManager.playJump();
            playerIsHoldingJumpKey = true;
            playerJumpHoldTimer = 0f;
        }

        boolean duckKeyPressed = Gdx.input.isKeyPressed(Input.Keys.DOWN) || Gdx.input.isKeyPressed(Input.Keys.S);
        if (duckKeyPressed) {
            if (player.isGrounded() && player.getCurrentState() != Player.State.DUCKING) {
                player.setCurrentState(Player.State.DUCKING);
                player.getVelocity().x *= 0.5f;
            }
        } else {
            if (player.getCurrentState() == Player.State.DUCKING) {
                player.setCurrentState(player.getVelocity().x != 0 ? Player.State.WALKING : Player.State.IDLE);
            }
        }
    }

    private void checkHorizontalCollisions(Player gamePlayer, Array<Platform> platforms) {
        Rectangle playerRect = gamePlayer.getBounds();
        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue;
            Rectangle platformRect = platform.getBounds();
            if (playerRect.overlaps(platformRect)) {
                if (gamePlayer.getVelocity().x > 0) {
                    gamePlayer.getPosition().x = platformRect.x - playerRect.width;
                } else if (gamePlayer.getVelocity().x < 0) {
                    gamePlayer.getPosition().x = platformRect.x + platformRect.width;
                }
                gamePlayer.getVelocity().x = 0;
                gamePlayer.getBounds().setX(gamePlayer.getPosition().x);
            }
        }
    }

    private void checkVerticalCollisions(Player gamePlayer, Array<Platform> platforms) {
        gamePlayer.setGrounded(false);
        Rectangle playerRect = gamePlayer.getBounds();
        float playerOldY = gamePlayer.getPosition().y - (gamePlayer.getVelocity().y * Gdx.graphics.getDeltaTime());

        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue;
            Rectangle platformRect = platform.getBounds();

            if (playerRect.overlaps(platformRect)) {
                if (gamePlayer.getVelocity().y <= 0 && playerOldY + playerRect.height * 0.5f >= platformRect.y + platformRect.height) {
                    gamePlayer.getPosition().y = platformRect.y + platformRect.height;
                    gamePlayer.getVelocity().y = 0;
                    gamePlayer.setGrounded(true);
                    if (gamePlayer.getCurrentState() == Player.State.JUMPING || gamePlayer.getCurrentState() == Player.State.FALLING) {
                        gamePlayer.setCurrentState(player.getVelocity().x == 0 ? Player.State.IDLE : Player.State.WALKING);
                    }
                } else if (gamePlayer.getVelocity().y > 0 && playerOldY <= platformRect.y) {
                    if (platform.getType() == Platform.PlatformType.QUESTION_BLOCK && !platform.hasBeenHit()) {
                        if (platform.hit()) {
                            Powerup.PowerupType containedPowerup = platform.getContainedPowerup();
                            if (containedPowerup != null) {
                                float powerupX = platformRect.x;
                                float powerupY = platformRect.y + platformRect.height + 5f;
                                Powerup newPowerup = new Powerup(containedPowerup, powerupX, powerupY);
                                newPowerup.getVelocity().y = 150f;
                                activePowerups.add(newPowerup);
                                soundManager.playPowerup();
                            } else {
                                gameStateManager.collectCoin();
                                gameStateManager.addScore(200);
                                soundManager.playCoinCollect();
                            }
                        }
                    }

                    gamePlayer.getPosition().y = platformRect.y - playerRect.height;
                    gamePlayer.getVelocity().y = 0;
                    playerIsHoldingJumpKey = false;
                    if(gamePlayer.getCurrentState() == Player.State.JUMPING) gamePlayer.setCurrentState(Player.State.FALLING);
                }
                gamePlayer.getBounds().setY(gamePlayer.getPosition().y);
            }
        }
    }

    private void checkPlayerPowerupCollisions() {
        Rectangle playerRect = player.getBounds();
        for (int i = activePowerups.size - 1; i >= 0; i--) {
            Powerup powerup = activePowerups.get(i);
            if (powerup.checkCollision(playerRect)) {
                handlePowerupCollection(powerup);
                powerup.collect();
                soundManager.playPowerup();
            }
        }
    }

    private void handlePowerupCollection(Powerup powerup) {
        switch (powerup.getType()) {
            case MUSHROOM:
                player.powerUp();
                gameStateManager.addScore(1000);
                break;
            case FIRE_FLOWER:
                player.powerUp();
                gameStateManager.addScore(1000);
                break;
            case STAR:
                gameStateManager.addScore(1000);
                break;
            case CHICKEN:
                gameStateManager.addScore(500);
                break;
            default:
                gameStateManager.addScore(100);
                break;
        }
    }

    private void checkShellEnemyCollisions() {
        for (int i = 0; i < activeEnemies.size; i++) {
            Enemy enemy1 = activeEnemies.get(i);

            if (enemy1 instanceof Koopa) {
                Koopa koopa1 = (Koopa) enemy1;
                if (koopa1.isMovingShell()) {
                    for (int j = activeEnemies.size - 1; j >= 0; j--) {
                        if (i == j) continue;

                        Enemy enemy2 = activeEnemies.get(j);
                        if (!enemy2.isAlive()) continue;

                        if (enemy1.getBounds().overlaps(enemy2.getBounds())) {
                            if (enemy2 instanceof Koopa) {
                                Koopa koopa2 = (Koopa) enemy2;
                                if (!koopa2.isShell()) {
                                    koopa2.onStompedBy(player);
                                } else {
                                    enemy2.onStompedBy(player);
                                    activeEnemies.removeIndex(j);
                                    if (j < i) i--;
                                }
                            } else {
                                enemy2.onStompedBy(player);
                                gameStateManager.addScore(100);
                                soundManager.playEnemyStomp();
                            }
                        }
                    }
                }
            }
        }
    }

    private void checkPlayerEnemyCollisions() {
        if (player.getCurrentState() == Player.State.DEATH) return;

        Rectangle playerRect = player.getBounds();
        for (Enemy enemy : activeEnemies) {
            if (!enemy.isAlive() || enemy.getCurrentState() == Enemy.EnemyState.STOMPED) continue;

            if (playerRect.overlaps(enemy.getBounds())) {
                boolean isStomp = player.getVelocity().y < 0 &&
                    (player.getBounds().y > enemy.getBounds().y + enemy.getBounds().height * 0.5f);
                if (isStomp) {
                    enemy.onStompedBy(player);
                    gameStateManager.addScore(100);
                    player.getVelocity().y = PLAYER_STOMP_BOUNCE_VELOCITY;
                    player.setGrounded(false);
                } else {
                    if (enemy.onCollisionWith(player)) {
                        if (player.getPowerState() != Player.PowerState.SMALL) {
                            player.powerDown();
                            if (player.getCurrentState() == Player.State.DEATH) {
                                gamePaused = true;
                            }
                        } else {
                            player.die();
                            gamePaused = true;
                        }
                        break;
                    }
                }
            }
        }
    }


    private void collectCoins() {
        Rectangle playerRect = player.getBounds();
        for (int i = activePlatforms.size - 1; i >= 0; i--) {
            Platform item = activePlatforms.get(i);
            if (item.getType() == Platform.PlatformType.COIN && playerRect.overlaps(item.getBounds())) {
                activePlatforms.removeIndex(i);
                gameStateManager.collectCoin();
                soundManager.playCoinCollect();
            }
        }
    }

    @Override
    public void resize(int width, int height) {
        viewport.update(width, height, true);
        if (levelEditor != null) {
            levelEditor.resize(width, height);
        }
    }

    @Override
    public void dispose() {
        if (batch != null) batch.dispose();
        if (player != null) player.dispose();
        if (playerIdleTexture != null) playerIdleTexture.dispose();
        if (background != null) background.dispose();

        Platform.disposeSharedTextures();
        if (activePlatforms != null) activePlatforms.clear();

        // Dispose enemy textures
        if (goombaWalkFrame1Tex != null) goombaWalkFrame1Tex.dispose();
        if (goombaWalkFrame2Tex != null) goombaWalkFrame2Tex.dispose();
        if (goombaSquashedTex != null && goombaSquashedTex != goombaWalkFrame1Tex) {
            goombaSquashedTex.dispose();
        }

        if (koopaWalkFrame1Tex != null) koopaWalkFrame1Tex.dispose();
        if (koopaWalkFrame2Tex != null) koopaWalkFrame2Tex.dispose();
        if (koopaShellIdleTex != null) koopaShellIdleTex.dispose();
        if (koopaShellMove1Tex != null) koopaShellMove1Tex.dispose();
        if (koopaShellMove2Tex != null) koopaShellMove2Tex.dispose();
        if (koopaShellMove3Tex != null) koopaShellMove3Tex.dispose();
        if (koopaShellMove4Tex != null) koopaShellMove4Tex.dispose();

        if (activeEnemies != null) {
            for (Enemy enemy : activeEnemies) {
                enemy.dispose();
            }
            activeEnemies.clear();
        }

        if (activePowerups != null) {
            for (Powerup powerup : activePowerups) {
                powerup.dispose();
            }
            activePowerups.clear();
        }

        if (goalPost != null) {
            goalPost.dispose();
        }
        GoalPost.disposeStaticTextures();

        if (worldMap != null) worldMap.dispose();
        if (levelEditor != null) levelEditor.dispose();
        if (soundManager != null) soundManager.dispose();
        if (gameStateManager != null) gameStateManager.dispose();
    }
}

================
File: src/main/java/io/github/game/Platform.java
================
// File: core/src/main/java/io/github/game/Platform.java
package io.github.game;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.ObjectMap;
import com.badlogic.gdx.Gdx;

public class Platform {
    private Rectangle bounds;
    private PlatformType type;
    private Texture singleBlockTexture;
    private Powerup.PowerupType containedPowerup; // UPDATED: Now properly typed
    private boolean hasBeenHit;
    private String uniqueId;

    // Visual size of each ground tile component
    public static final int GROUND_TILE_SIZE = 32;

    // Static textures for ground composition
    private static Texture texGrassCornerLeft;
    private static Texture texGrassMiddle;
    private static Texture texGrassCornerRight;
    private static Texture texDirtMiddle;
    private static Texture texQuestionBlockUsed; // UPDATED: Changed from Empty to Used

    // Static map for textures
    private static ObjectMap<PlatformType, Texture> otherBlockTextures;

    public enum PlatformType {
        GROUND,
        GRAVEL_BLOCK,
        QUESTION_BLOCK,
        COIN
    }

    static {
        try {
            // Load ground composition textures
            texGrassCornerLeft = new Texture("mario_sprites/world/grass_left_corner.png");
            texGrassMiddle = new Texture("mario_sprites/world/grass_middle.png");
            texGrassCornerRight = new Texture("mario_sprites/world/grass_right_corner.png");
            texDirtMiddle = new Texture("mario_sprites/world/dirt_middle.png");

            // Initialize map and load other block textures
            otherBlockTextures = new ObjectMap<>();
            otherBlockTextures.put(PlatformType.GRAVEL_BLOCK, new Texture("mario_sprites/world/gravel.png"));

            String qbPath = "mario_sprites/world/question_block.png";
            if (Gdx.files.internal(qbPath).exists()) {
                otherBlockTextures.put(PlatformType.QUESTION_BLOCK, new Texture(qbPath));
                Gdx.app.log("Platform", "Successfully loaded question block texture: " + qbPath);
            } else {
                System.err.println("Warning: Texture not found: " + qbPath);
                if (otherBlockTextures.containsKey(PlatformType.GRAVEL_BLOCK)) {
                    otherBlockTextures.put(PlatformType.QUESTION_BLOCK, otherBlockTextures.get(PlatformType.GRAVEL_BLOCK));
                }
            }

            // FIXED: Load used question block texture with proper path and better error handling
            String usedQbPath = "mario_sprites/world/used_question_block.png";
            if (Gdx.files.internal(usedQbPath).exists()) {
                texQuestionBlockUsed = new Texture(usedQbPath);
                Gdx.app.log("Platform", "Successfully loaded used question block texture: " + usedQbPath);
            } else {
                // Try alternative paths
                String[] altPaths = {
                    "mario_sprites/world/question_block_empty.png",
                    "mario_sprites/world/empty_question_block.png",
                    "mario_sprites/world/hit_question_block.png"
                };

                boolean loaded = false;
                for (String altPath : altPaths) {
                    if (Gdx.files.internal(altPath).exists()) {
                        texQuestionBlockUsed = new Texture(altPath);
                        Gdx.app.log("Platform", "Loaded used question block from alternative path: " + altPath);
                        loaded = true;
                        break;
                    }
                }

                if (!loaded) {
                    // Use gravel as fallback for used question block
                    texQuestionBlockUsed = otherBlockTextures.get(PlatformType.GRAVEL_BLOCK);
                    Gdx.app.error("Platform", "Used question block texture not found at: " + usedQbPath + " or alternative paths. Using gravel as fallback.");
                }
            }

            String coinPath = "mario_sprites/world/coin.png";
            if (Gdx.files.internal(coinPath).exists()) {
                otherBlockTextures.put(PlatformType.COIN, new Texture(coinPath));
            } else {
                System.err.println("Warning: Texture not found: " + coinPath);
            }

        } catch (Exception e) {
            System.err.println("Fatal error loading platform textures: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public static Texture getTextureForType(PlatformType type) {
        if (type == PlatformType.GROUND) {
            return null;
        }
        return otherBlockTextures.get(type);
    }

    public Platform(float x, float y, float width, float height, PlatformType type) {
        this.bounds = new Rectangle(x, y, width, height);
        this.type = type;
        this.hasBeenHit = false;
        this.containedPowerup = null; // UPDATED: Initialize as null
        this.uniqueId = x + "_" + y + "_" + type;

        if (type != PlatformType.GROUND) {
            this.singleBlockTexture = getTextureForType(type);

            if (this.singleBlockTexture == null) {
                System.err.println("Warning: Texture for type " + type + " is missing.");
                if (type != PlatformType.GRAVEL_BLOCK && getTextureForType(PlatformType.GRAVEL_BLOCK) != null) {
                    this.singleBlockTexture = getTextureForType(PlatformType.GRAVEL_BLOCK);
                }
            }
        }
    }

    // UPDATED: Properly typed setter and getter for contained powerup
    public void setContainedPowerup(Powerup.PowerupType powerup) {
        this.containedPowerup = powerup;
    }

    public Powerup.PowerupType getContainedPowerup() {
        return containedPowerup;
    }

    public boolean hit() {
        if (type == PlatformType.QUESTION_BLOCK && !hasBeenHit) {
            hasBeenHit = true;
            Gdx.app.log("Platform", "Question block hit! Changing to used texture.");
            return true; // Successfully hit for the first time
        }
        return false; // Already hit or not a question block
    }

    public boolean hasBeenHit() {
        return hasBeenHit;
    }

    public String getUniqueId() {
        return uniqueId;
    }

    public void render(SpriteBatch batch) {
        switch (type) {
            case GROUND:
                renderGroundPlatform(batch);
                break;
            case GRAVEL_BLOCK:
            case COIN:
                renderSingleScaledBlock(batch);
                break;
            case QUESTION_BLOCK:
                renderQuestionBlock(batch);
                break;
            default:
                if (singleBlockTexture != null) {
                    batch.draw(singleBlockTexture, bounds.x, bounds.y, bounds.width, bounds.height);
                }
                break;
        }
    }

    private void renderQuestionBlock(SpriteBatch batch) {
        Texture textureToDraw;
        if (hasBeenHit && texQuestionBlockUsed != null) {
            textureToDraw = texQuestionBlockUsed; // FIXED: Use the used texture when hit
        } else if (singleBlockTexture != null) {
            textureToDraw = singleBlockTexture; // Use normal question block texture
        } else {
            return;
        }
        batch.draw(textureToDraw, bounds.x, bounds.y, bounds.width, bounds.height);
    }

    private void renderGroundPlatform(SpriteBatch batch) {
        if (texGrassCornerLeft == null || texGrassMiddle == null || texGrassCornerRight == null || texDirtMiddle == null) {
            System.err.println("Cannot render GROUND: one or more essential ground textures are missing.");
            return;
        }

        int numCols = (int) (bounds.width / GROUND_TILE_SIZE);
        int numRows = (int) (bounds.height / GROUND_TILE_SIZE);

        for (int row = 0; row < numRows; row++) {
            for (int col = 0; col < numCols; col++) {
                float tileX = bounds.x + col * GROUND_TILE_SIZE;
                float tileY = bounds.y + (numRows - 1 - row) * GROUND_TILE_SIZE;

                Texture currentTileToDraw;
                if (row == 0) {
                    if (numCols == 1) {
                        currentTileToDraw = texGrassMiddle;
                    } else if (col == 0) {
                        currentTileToDraw = texGrassCornerLeft;
                    } else if (col == numCols - 1) {
                        currentTileToDraw = texGrassCornerRight;
                    } else {
                        currentTileToDraw = texGrassMiddle;
                    }
                } else {
                    currentTileToDraw = texDirtMiddle;
                }
                batch.draw(currentTileToDraw, tileX, tileY, GROUND_TILE_SIZE, GROUND_TILE_SIZE);
            }
        }
    }

    private void renderSingleScaledBlock(SpriteBatch batch) {
        if (singleBlockTexture == null) {
            return;
        }
        batch.draw(singleBlockTexture, bounds.x, bounds.y, bounds.width, bounds.height);
    }

    public Rectangle getBounds() {
        return bounds;
    }

    public static void disposeSharedTextures() {
        if (texGrassCornerLeft != null) texGrassCornerLeft.dispose();
        if (texGrassMiddle != null) texGrassMiddle.dispose();
        if (texGrassCornerRight != null) texGrassCornerRight.dispose();
        if (texDirtMiddle != null) texDirtMiddle.dispose();
        if (texQuestionBlockUsed != null) texQuestionBlockUsed.dispose(); // UPDATED

        if (otherBlockTextures != null) {
            for (Texture tex : otherBlockTextures.values()) {
                if (tex != null) tex.dispose();
            }
            otherBlockTextures.clear();
        }
        System.out.println("Platform shared textures disposed.");
    }

    public void dispose() {
        // No operation needed here as textures are static and shared.
    }

    public PlatformType getType() {
        return type;
    }
}

================
File: src/main/java/io/github/game/Player.java
================
// File: core/src/main/java/io/github/game/Player.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;

public class Player {

    private Texture deathTexture;
    public static final float DEATH_ANIMATION_DURATION = 1.5f;

    public enum State {
        IDLE, FALLING, WALKING, RUNNING, JUMPING, DUCKING, OPENING_DOOR, FULL_SPEED_JUMPING, DEATH, GROUND_POUNDING, GOING_DOWN_PIPE;
    }

    public enum PowerState {
        SMALL, BIG, FIRE
    }

    private Vector2 position;
    private Vector2 velocity;
    private boolean facingRight;
    private boolean grounded;
    private State currentState;
    private State previousState;
    private PowerState powerState;
    private float stateTimer;

    public static final int PLAYER_WIDTH = 32;
    public static final int PLAYER_HEIGHT = 48;

    // UPDATED: Different collision sizes for different power states
    public static final int SMALL_MARIO_WIDTH = 28;
    public static final int SMALL_MARIO_HEIGHT = 30;
    public static final int BIG_MARIO_WIDTH = 30;
    public static final int BIG_MARIO_HEIGHT = 48;

    private Rectangle bounds;

    // NEW: Separate texture sets for different power states
    // Small Mario textures
    private Texture smallIdleTexture;
    private Texture smallDuckTexture;
    private Texture smallJumpTexture;
    private Texture smallWalkTexture0;
    private Texture smallWalkTexture1;
    private Texture smallWalkTexture2;
    private Texture smallFallTexture;
    private Texture smallPipeTexture;
    private Texture smallLookUpTexture;
    private Animation<Texture> smallWalkAnimation;

    // Big Mario textures
    private Texture bigIdleTexture;
    private Texture bigDuckTexture;
    private Texture bigJumpTexture;
    private Texture bigWalkTexture0;
    private Texture bigWalkTexture1;
    private Texture bigWalkTexture2;
    private Texture bigFallTexture;
    private Texture bigPipeTexture;
    private Texture bigLookUpTexture;
    private Animation<Texture> bigWalkAnimation;

    // Shared death texture (works for both states)
    private Texture marioDeathTexture;

    // NEW: Power-up transition state
    private boolean isTransitioning = false;
    private float transitionTimer = 0f;
    private static final float TRANSITION_DURATION = 1.0f;
    private PowerState targetPowerState;

    // NEW: Stop ducking
    public void stopDucking() {
        if (isDucking) {
            // Check if there's enough space above to stand up
            if (canStandUp()) {
                isDucking = false;
                updateBounds();

                // Return to appropriate state based on movement
                if (Math.abs(velocity.x) > 0) {
                    setCurrentState(State.WALKING);
                } else {
                    setCurrentState(State.IDLE);
                }

                Gdx.app.log("Player", "Mario stopped ducking. New height: " + bounds.height);
            } else {
                // Can't stand up yet, stay ducking
                Gdx.app.log("Player", "Can't stand up - not enough space above");
            }
        }
    }

    // NEW: Check if Mario can stand up (no obstacles above)
    private boolean canStandUp() {
        if (!isDucking) return true;

        // Calculate what the bounds would be if standing
        float standingHeight = (powerState == PowerState.SMALL) ? SMALL_MARIO_HEIGHT : BIG_MARIO_HEIGHT;
        float heightDifference = standingHeight - bounds.height;

        // Create a test rectangle for the space above Mario
        Rectangle testBounds = new Rectangle(
            bounds.x,
            bounds.y + bounds.height,
            bounds.width,
            heightDifference
        );

        // This would need to check against platforms - for now return true
        // In a full implementation, you'd check testBounds against all solid platforms
        return true;
    }

    // UPDATED: Enhanced update method with ducking support
    public void update(float deltaTime){
        stateTimer = currentState == previousState ? stateTimer + deltaTime : 0;
        previousState = currentState;

        // Handle power-up transition
        if (isTransitioning) {
            transitionTimer += deltaTime;
            if (transitionTimer >= TRANSITION_DURATION) {
                isTransitioning = false;
                transitionTimer = 0f;
            }
        }

        if (currentState == State.DEATH) {
            // Apply death physics (vertical jump and fall)
            velocity.y += DEATH_GRAVITY * deltaTime;
            position.y += velocity.y * deltaTime;
            bounds.setPosition(position.x, position.y);
        } else {
            // Existing update logic for non-death states
            bounds.setPosition(position.x, position.y);

            // Handle ducking state transitions
            if (currentState == State.DUCKING && !isDucking) {
                // Was ducking but no longer in ducking state
                startDucking();
            } else if (currentState != State.DUCKING && isDucking && grounded) {
                // No longer in ducking state but still flagged as ducking
                stopDucking();
            }

            // Condition for falling state based on vertical velocity and not being grounded
            if (velocity.y < 0 && !grounded && currentState != State.FALLING &&
                currentState != State.DUCKING && currentState != State.GOING_DOWN_PIPE) {
                setCurrentState(State.FALLING);
            }
        }
    }

    // UPDATED: Enhanced render method with ducking support
    public void render(SpriteBatch batch){
        Texture currentFrame = getFrame();

        boolean flipX = !facingRight; // Player faces right by default, flip if not facingRight

        // UPDATED: Render with appropriate size based on power state AND ducking
        float renderWidth = PLAYER_WIDTH;
        float renderHeight = PLAYER_HEIGHT;

        // Adjust render size for ducking
        if (isDucking) {
            renderHeight = renderHeight * 0.5f; // Half height when ducking
        }

        // Adjust render position to center the sprite on the collision box
        float offsetX = (renderWidth - bounds.width) / 2f;
        float offsetY = 0; // Keep aligned to bottom for ground contact

        // Handle transition effect (flashing between states)
        if (isTransitioning) {
            // Flash effect during transition
            float flashSpeed = 10f;
            boolean showAlternate = ((int)(transitionTimer * flashSpeed) % 2) == 0;

            if (showAlternate && targetPowerState != PowerState.SMALL) {
                // Show transition state briefly
                batch.setColor(1f, 1f, 1f, 0.7f);
            }
        }

        // Standard drawing logic
        batch.draw(
            currentFrame,
            flipX ? position.x - offsetX + renderWidth : position.x - offsetX,
            position.y + offsetY,
            flipX ? -renderWidth : renderWidth,
            renderHeight
        );

        // Reset color after transition effect
        if (isTransitioning) {
            batch.setColor(Color.WHITE);
        }
    }

    // UPDATED: Enhanced setCurrentState to handle ducking properly
    public void setCurrentState(State newState) {
        if (this.currentState != newState) {
            State oldState = this.currentState;
            this.currentState = newState;
            this.stateTimer = 0; // Reset state timer on state change

            // Handle ducking state changes
            if (newState == State.DUCKING && !isDucking) {
                startDucking();
            } else if (oldState == State.DUCKING && newState != State.DUCKING) {
                stopDucking();
            }
        }
    }

    // UPDATED: Method to change power state with ducking consideration
    public void setPowerState(PowerState newPowerState) {
        if (this.powerState != newPowerState) {
            PowerState oldPowerState = this.powerState;
            startPowerTransition(newPowerState);

            // If we were ducking, maintain ducking with new size
            if (isDucking) {
                updateBounds(); // Recalculate ducking bounds for new power state
                Gdx.app.log("Player", "Power state changed while ducking. New duck height: " + bounds.height);
            }
        }
    }

    // NEW: Getter for ducking state
    public boolean isDucking() {
        return isDucking;
    }

    // UPDATED: Enhanced respawn method
    public void respawn(float x, float y) {
        position.set(x, y);
        velocity.set(0, 0);
        setCurrentState(State.IDLE);
        setPowerState(PowerState.SMALL); // Reset to small Mario on respawn
        isDucking = false; // Make sure not ducking on respawn
        grounded = true; // Assume respawn on ground
        facingRight = true; // Default facing direction
        stateTimer = 0f;
        isTransitioning = false; // Reset any transition
        transitionTimer = 0f;
        updateBounds(); // Make sure bounds are correct
        bounds.setPosition(position.x, position.y);
        Gdx.app.log("Player", "Mario respawned as SMALL");
    }

    // UPDATED: Enhanced getFrame method to handle ducking textures
    public Texture getFrame() {
        // Use death texture for death state (same for all power states)
        if (currentState == State.DEATH) {
            return marioDeathTexture;
        }

        // Choose texture set based on power state
        boolean useBigMario = (powerState == PowerState.BIG || powerState == PowerState.FIRE);

        switch(currentState){
            case WALKING:
                // Don't show walking animation while ducking
                if (isDucking) {
                    return useBigMario ? bigDuckTexture : smallDuckTexture;
                }
                return useBigMario ? bigWalkAnimation.getKeyFrame(stateTimer, true)
                    : smallWalkAnimation.getKeyFrame(stateTimer, true);
            case JUMPING:
                // Can't duck while jumping
                return useBigMario ? bigJumpTexture : smallJumpTexture;
            case DUCKING:
                return useBigMario ? bigDuckTexture : smallDuckTexture;
            case FALLING:
                // Can't duck while falling
                return useBigMario ? bigFallTexture : smallFallTexture;
            case IDLE:
            default:
                // Show ducking texture if ducking, even in idle state
                if (isDucking) {
                    return useBigMario ? bigDuckTexture : smallDuckTexture;
                }
                return useBigMario ? bigIdleTexture : smallIdleTexture;
        }
    }

    // NEW: Method to check if Mario can move while ducking
    public boolean canMoveWhileDucking() {
        return isDucking && grounded;
    }

    // NEW: Get the height difference between normal and ducking states
    public float getDuckingHeightDifference() {
        if (powerState == PowerState.SMALL) {
            return SMALL_MARIO_HEIGHT - SMALL_MARIO_DUCK_HEIGHT;
        } else {
            return BIG_MARIO_HEIGHT - BIG_MARIO_DUCK_HEIGHT;
        }
    }
    // Added for Mario-style death animation
    private static final float DEATH_JUMP_VELOCITY = 350f;
    private static final float DEATH_GRAVITY = -900f;

    public Player(float x, float y){
        position = new Vector2(x,y);
        velocity = new Vector2(0, 0);
        facingRight = true; // Player starts facing right
        grounded = false;
        currentState = State.IDLE;
        previousState = State.IDLE;
        powerState = PowerState.SMALL; // Start as small Mario

        // Initialize bounds based on power state
        updateBounds();

        // Load all texture sets
        loadSmallMarioTextures();
        loadBigMarioTextures();
        loadSharedTextures();

        // Create animations
        createAnimations();
    }

    // NEW: Load Small Mario textures
    private void loadSmallMarioTextures() {
        try {
            smallIdleTexture = new Texture("mario_sprites/playables/mario/mario_idle.png");
            smallWalkTexture0 = new Texture("mario_sprites/playables/mario/mario_walk_0.png");
            smallWalkTexture1 = new Texture("mario_sprites/playables/mario/mario_walk_1.png");
            smallWalkTexture2 = new Texture("mario_sprites/playables/mario/mario_walk_2.png");
            smallDuckTexture = new Texture("mario_sprites/playables/mario/mario_duck.png");
            smallJumpTexture = new Texture("mario_sprites/playables/mario/mario_jump.png");
            smallLookUpTexture = new Texture("mario_sprites/playables/mario/mario_look_up.png");
            smallPipeTexture = new Texture("mario_sprites/playables/mario/mario_pipe.png");
            smallFallTexture = new Texture("mario_sprites/playables/mario/mario_fall.png");

            Gdx.app.log("Player", "Successfully loaded Small Mario textures");
        } catch (Exception e) {
            Gdx.app.error("Player", "Failed to load some Small Mario textures", e);
        }
    }

    // NEW: Load Big Mario textures
    private void loadBigMarioTextures() {
        try {
            bigIdleTexture = new Texture("mario_sprites/playables/big_mario/big_mario_idle.png");
            bigWalkTexture0 = new Texture("mario_sprites/playables/big_mario/big_mario_walk_0.png");
            bigWalkTexture1 = new Texture("mario_sprites/playables/big_mario/big_mario_walk_1.png");
            bigWalkTexture2 = new Texture("mario_sprites/playables/big_mario/big_mario_walk_2.png");
            bigDuckTexture = new Texture("mario_sprites/playables/big_mario/big_mario_duck.png");
            bigJumpTexture = new Texture("mario_sprites/playables/big_mario/big_mario_jump.png");
            bigLookUpTexture = new Texture("mario_sprites/playables/big_mario/big_mario_look_up.png");
            bigPipeTexture = new Texture("mario_sprites/playables/big_mario/big_mario_pipe.png");
            bigFallTexture = new Texture("mario_sprites/playables/big_mario/big_mario_fall.png");

            Gdx.app.log("Player", "Successfully loaded Big Mario textures");
        } catch (Exception e) {
            Gdx.app.error("Player", "Failed to load some Big Mario textures, using Small Mario textures as fallback", e);
            // Use small mario textures as fallback
            bigIdleTexture = smallIdleTexture;
            bigWalkTexture0 = smallWalkTexture0;
            bigWalkTexture1 = smallWalkTexture1;
            bigWalkTexture2 = smallWalkTexture2;
            bigDuckTexture = smallDuckTexture;
            bigJumpTexture = smallJumpTexture;
            bigLookUpTexture = smallLookUpTexture;
            bigPipeTexture = smallPipeTexture;
            bigFallTexture = smallFallTexture;
        }
    }

    // NEW: Load shared textures (like death)
    private void loadSharedTextures() {
        try {
            // Try to load mario death texture
            String deathSpritePath = "mario_sprites/playables/mario/mario_death.png";
            if (Gdx.files.internal(deathSpritePath).exists()) {
                marioDeathTexture = new Texture(Gdx.files.internal(deathSpritePath));
            } else {
                marioDeathTexture = smallFallTexture; // Use fall texture as fallback
                Gdx.app.log("Player", "mario_death.png not found, using fall texture for death animation.");
            }
        } catch (Exception e) {
            Gdx.app.error("Player", "Failed to load shared textures", e);
            marioDeathTexture = smallFallTexture;
        }
    }

    // NEW: Create animations for both power states
    private void createAnimations() {
        // Small Mario walk animation
        Array<Texture> smallWalkFrames = new Array<>();
        smallWalkFrames.add(smallWalkTexture0);
        smallWalkFrames.add(smallWalkTexture1);
        smallWalkFrames.add(smallWalkTexture2);
        smallWalkAnimation = new Animation<>(0.1f, smallWalkFrames, Animation.PlayMode.LOOP);

        // Big Mario walk animation
        Array<Texture> bigWalkFrames = new Array<>();
        bigWalkFrames.add(bigWalkTexture0);
        bigWalkFrames.add(bigWalkTexture1);
        bigWalkFrames.add(bigWalkTexture2);
        bigWalkAnimation = new Animation<>(0.1f, bigWalkFrames, Animation.PlayMode.LOOP);
    }

    // UPDATED: Method to update bounds based on power state AND ducking state
    private void updateBounds() {
        float width, height;

        // Determine base width and height
        switch (powerState) {
            case SMALL:
                width = SMALL_MARIO_WIDTH;
                height = isDucking ? SMALL_MARIO_DUCK_HEIGHT : SMALL_MARIO_HEIGHT;
                break;
            case BIG:
            case FIRE:
                width = BIG_MARIO_WIDTH;
                height = isDucking ? BIG_MARIO_DUCK_HEIGHT : BIG_MARIO_HEIGHT;
                break;
            default:
                width = SMALL_MARIO_WIDTH;
                height = isDucking ? SMALL_MARIO_DUCK_HEIGHT : SMALL_MARIO_HEIGHT;
                break;
        }

        if (bounds == null) {
            bounds = new Rectangle(position.x, position.y, width, height);
        } else {
            // When changing size, keep the bottom position consistent
            float oldBottom = bounds.y;
            bounds.width = width;
            bounds.height = height;
            bounds.y = oldBottom; // Keep Mario grounded
            bounds.x = position.x;
        }

        // Store bounds for ducking state management
        if (isDucking) {
            duckingBounds = new Rectangle(bounds);
        } else {
            normalBounds = new Rectangle(bounds);
        }
    }

    // NEW: Start ducking
    public void startDucking() {
        if (!isDucking && grounded) { // Can only duck when on ground
            isDucking = true;
            updateBounds();
            setCurrentState(State.DUCKING);

            // Reduce horizontal velocity when ducking
            velocity.x *= 0.3f;

            Gdx.app.log("Player", "Mario started ducking. New height: " + bounds.height);
        }
    }

    // NEW: Method to start power state transition
    private void startPowerTransition(PowerState newPowerState) {
        if (this.powerState != newPowerState) {
            this.targetPowerState = newPowerState;
            this.isTransitioning = true;
            this.transitionTimer = 0f;

            // Immediately update bounds for gameplay
            this.powerState = newPowerState;
            updateBounds();
        }
    }
    public PowerState getPowerState() {
        return powerState;
    }

    // Method to power up Mario
    public void powerUp() {
        switch (powerState) {
            case SMALL:
                setPowerState(PowerState.BIG);
                SoundManager.getInstance().playGrow();
                Gdx.app.log("Player", "Mario powered up to BIG");
                break;
            case BIG:
                setPowerState(PowerState.FIRE);
                SoundManager.getInstance().playPowerup();
                Gdx.app.log("Player", "Mario powered up to FIRE");
                break;
            case FIRE:
                // Already at max power, just give points
                SoundManager.getInstance().playItemGet();
                Gdx.app.log("Player", "Mario already at max power");
                break;
        }
    }

    // Method to power down Mario (when hit by enemy)
    public void powerDown() {
        switch (powerState) {
            case FIRE:
                setPowerState(PowerState.BIG);
                SoundManager.getInstance().playGrow(); // You might want a different sound here
                Gdx.app.log("Player", "Mario powered down to BIG");
                break;
            case BIG:
                setPowerState(PowerState.SMALL);
                SoundManager.getInstance().playGrow(); // You might want a different sound here
                Gdx.app.log("Player", "Mario powered down to SMALL");
                break;
            case SMALL:
                // Already small, Mario dies
                die();
                return;
        }
    }

    public void die() {
        if (currentState != State.DEATH) {
            setCurrentState(State.DEATH);
            velocity.y = DEATH_JUMP_VELOCITY; // Mario-style upward pop
            velocity.x = 0; // Stop horizontal movement
            grounded = false; // Player is in the air
            stateTimer = 0f; // Reset timer for the death sequence duration
            SoundManager.getInstance().playPlayerDeath(); // Play death sound
            Gdx.app.log("Player", "Mario died");
        }
    }


    // NEW: Check if player is currently transitioning between power states
    public boolean isTransitioning() {
        return isTransitioning;
    }

    // Existing getters and setters...
    public Vector2 getPosition() {
        return position;
    }

    public void setPosition(Vector2 position) {
        this.position = position;
        bounds.setPosition(position.x, position.y);
    }

    public Vector2 getVelocity() {
        return velocity;
    }

    public void setVelocity(Vector2 velocity) {
        this.velocity = velocity;
    }

    public boolean isFacingRight() {
        return facingRight;
    }

    public void setFacingRight(boolean facingRight) {
        this.facingRight = facingRight;
    }

    public boolean isGrounded() {
        return grounded;
    }

    public void setGrounded(boolean grounded) {
        this.grounded = grounded;
    }

    public State getCurrentState() {
        return currentState;
    }


    public State getPreviousState() {
        return previousState;
    }

    public void setPreviousState(State previousState) {
        this.previousState = previousState;
    }

    public float getStateTimer() {
        return stateTimer;
    }

    public void setStateTimer(float stateTimer) {
        this.stateTimer = stateTimer;
    }

    public Rectangle getBounds() {
        return bounds;
    }

    public void setBounds(Rectangle bounds) {
        this.bounds = bounds;
    }

    // UPDATED: Dispose method to handle all textures
    public void dispose(){
        // Small Mario textures
        if (smallIdleTexture != null) smallIdleTexture.dispose();
        if (smallWalkTexture0 != null) smallWalkTexture0.dispose();
        if (smallWalkTexture1 != null) smallWalkTexture1.dispose();
        if (smallWalkTexture2 != null) smallWalkTexture2.dispose();
        if (smallJumpTexture != null) smallJumpTexture.dispose();
        if (smallFallTexture != null) smallFallTexture.dispose();
        if (smallDuckTexture != null) smallDuckTexture.dispose();
        if (smallLookUpTexture != null) smallLookUpTexture.dispose();
        if (smallPipeTexture != null) smallPipeTexture.dispose();

        // Big Mario textures (only dispose if different from small mario)
        if (bigIdleTexture != null && bigIdleTexture != smallIdleTexture) bigIdleTexture.dispose();
        if (bigWalkTexture0 != null && bigWalkTexture0 != smallWalkTexture0) bigWalkTexture0.dispose();
        if (bigWalkTexture1 != null && bigWalkTexture1 != smallWalkTexture1) bigWalkTexture1.dispose();
        if (bigWalkTexture2 != null && bigWalkTexture2 != smallWalkTexture2) bigWalkTexture2.dispose();
        if (bigJumpTexture != null && bigJumpTexture != smallJumpTexture) bigJumpTexture.dispose();
        if (bigFallTexture != null && bigFallTexture != smallFallTexture) bigFallTexture.dispose();
        if (bigDuckTexture != null && bigDuckTexture != smallDuckTexture) bigDuckTexture.dispose();
        if (bigLookUpTexture != null && bigLookUpTexture != smallLookUpTexture) bigLookUpTexture.dispose();
        if (bigPipeTexture != null && bigPipeTexture != smallPipeTexture) bigPipeTexture.dispose();

        // Shared textures
        if (marioDeathTexture != null && marioDeathTexture != smallFallTexture) {
            marioDeathTexture.dispose();
        }
    }

    // Legacy getters for compatibility (now delegate to appropriate power state)
    public Texture getIdleTexture() {
        return powerState == PowerState.SMALL ? smallIdleTexture : bigIdleTexture;
    }

    public Texture getDuckTexture() {
        return powerState == PowerState.SMALL ? smallDuckTexture : bigDuckTexture;
    }

    public Texture getJumpTexture() {
        return powerState == PowerState.SMALL ? smallJumpTexture : bigJumpTexture;
    }

    public Texture getWalkTexture0() {
        return powerState == PowerState.SMALL ? smallWalkTexture0 : bigWalkTexture0;
    }

    public Texture getWalkTexture1() {
        return powerState == PowerState.SMALL ? smallWalkTexture1 : bigWalkTexture1;
    }

    public Texture getFallTexture() {
        return powerState == PowerState.SMALL ? smallFallTexture : bigFallTexture;
    }

    public Texture getPipeTexture() {
        return powerState == PowerState.SMALL ? smallPipeTexture : bigPipeTexture;
    }

    public Texture getLookUpTexture() {
        return powerState == PowerState.SMALL ? smallLookUpTexture : bigLookUpTexture;
    }

    public Animation<Texture> getWalkAnimation() {
        return powerState == PowerState.SMALL ? smallWalkAnimation : bigWalkAnimation;
    }
    private boolean isDucking = false;
    private Rectangle normalBounds; // Store normal bounds when ducking
    private Rectangle duckingBounds; // Store ducking bounds
    public static final int SMALL_MARIO_DUCK_HEIGHT = 15; // Half of normal small mario height
    public static final int BIG_MARIO_DUCK_HEIGHT = 24;   // Half of normal big mario height

    // Legacy setters (no longer needed but kept for compatibility)
    public void setIdleTexture(Texture idleTexture) { /* No-op */ }
    public void setDuckTexture(Texture duckTexture) { /* No-op */ }
    public void setJumpTexture(Texture jumpTexture) { /* No-op */ }
    public void setWalkTexture0(Texture walkTexture0) { /* No-op */ }
    public void setWalkTexture1(Texture walkTexture1) { /* No-op */ }
    public void setFallTexture(Texture fallTexture) { /* No-op */ }
    public void setPipeTexture(Texture pipeTexture) { /* No-op */ }
    public void setLookUpTexture(Texture lookUpTexture) { /* No-op */ }
    public void setWalkAnimation(Animation<Texture> walkAnimation) { /* No-op */ }
}

================
File: src/main/java/io/github/game/Powerup.java
================
package io.github.game;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;

public class Powerup {
    public enum PowerupType {
        CHICKEN("Chicken Power", "mario_sprites/items/chicken.png"),
        MUSHROOM("Mushroom", "mario_sprites/items/mushroom.png"),
        FIRE_FLOWER("Fire Flower", "mario_sprites/items/fire_flower.png"),
        STAR("Star", "mario_sprites/items/star.png");

        private final String name;
        private final String texturePath;

        PowerupType(String name, String texturePath) {
            this.name = name;
            this.texturePath = texturePath;
        }

        public String getName() {
            return name;
        }

        public String getTexturePath() {
            return texturePath;
        }
    }

    private PowerupType type;
    private Vector2 position;
    private Vector2 velocity;
    private Rectangle bounds;
    private Texture texture;
    private boolean active;
    private float animationTimer;

    public Vector2 getVelocity() {
        return velocity;
    }

    public static final float POWERUP_SIZE = 32f;
    private static final float SPAWN_VELOCITY = 50f;
    private static final float MOVE_SPEED = 50f;

    public Powerup(PowerupType type, float x, float y) {
        this.type = type;
        this.position = new Vector2(x, y);
        this.velocity = new Vector2(MOVE_SPEED, SPAWN_VELOCITY);
        this.bounds = new Rectangle(x, y, POWERUP_SIZE, POWERUP_SIZE);
        this.active = true;
        this.animationTimer = 0;

        // Try to load texture, use placeholder if not found
        try {
            this.texture = new Texture(type.getTexturePath());
        } catch (Exception e) {
            // Use coin texture as placeholder if powerup texture doesn't exist
            try {
                this.texture = new Texture("mario_sprites/world/coin.png");
            } catch (Exception e2) {
                System.err.println("Warning: Could not load powerup texture: " + type.getTexturePath());
            }
        }
    }

    public void update(float deltaTime, Array<Platform> platforms) {
        if (!active) return;

        animationTimer += deltaTime;

        // Apply gravity
        velocity.y -= 400f * deltaTime;

        // Update position
        position.x += velocity.x * deltaTime;
        position.y += velocity.y * deltaTime;

        // Update bounds
        bounds.setPosition(position.x, position.y);

        // Check collisions with platforms
        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue;

            Rectangle platformBounds = platform.getBounds();
            if (bounds.overlaps(platformBounds)) {
                // Landing on top
                if (velocity.y < 0 && position.y > platformBounds.y) {
                    position.y = platformBounds.y + platformBounds.height;
                    velocity.y = 0;
                }
                // Hitting from side
                if (velocity.x > 0 && position.x < platformBounds.x) {
                    position.x = platformBounds.x - POWERUP_SIZE;
                    velocity.x = -MOVE_SPEED;
                } else if (velocity.x < 0 && position.x > platformBounds.x) {
                    position.x = platformBounds.x + platformBounds.width;
                    velocity.x = MOVE_SPEED;
                }
            }
        }

        // Remove if fallen off screen
        if (position.y < -100) {
            active = false;
        }
    }

    public void render(SpriteBatch batch) {
        if (!active || texture == null) return;

        // Add slight bobbing animation
        float yOffset = (float) Math.sin(animationTimer * 3) * 2;

        batch.draw(texture, position.x, position.y + yOffset, POWERUP_SIZE, POWERUP_SIZE);
    }

    public boolean checkCollision(Rectangle playerBounds) {
        return active && bounds.overlaps(playerBounds);
    }

    public void collect() {
        active = false;
        System.out.println(type.getName() + " collected!");
    }

    public PowerupType getType() {
        return type;
    }

    public boolean isActive() {
        return active;
    }

    public Vector2 getPosition() {
        return position;
    }

    public Rectangle getBounds() {
        return bounds;
    }

    public void dispose() {
        if (texture != null) {
            texture.dispose();
        }
    }
}

================
File: src/main/java/io/github/game/SoundManager.java
================
// File: core/src/main/java/io/github/game/SoundManager.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.utils.Disposable;

public class SoundManager implements Disposable {
    private static SoundManager instance;

    private Sound jumpSound;
    private Sound coinSound;
    private Sound growSound;
    private Sound itemGetSound;
    private Sound doorSound;
    private Sound powerupSound;
    private Sound playerDeathSound;
    private Sound enemyStompSound;

    private Music currentMusic;
    private String currentMusicPath;

    private float masterVolume = 0.5f; // Keep existing volume controls
    private float musicVolume = 0.5f;  // This seems to be a specific multiplier for music
    private boolean soundEnabled = true;
    private boolean musicEnabled = true;

    private SoundManager() {
        loadSounds();
    }

    public static SoundManager getInstance() {
        if (instance == null) {
            instance = new SoundManager();
        }
        return instance;
    }

    private void loadSounds() {
        try {
            jumpSound = Gdx.audio.newSound(Gdx.files.internal("sounds/jump.wav"));
            coinSound = Gdx.audio.newSound(Gdx.files.internal("sounds/coin.wav"));

            if (Gdx.files.internal("sounds/grow.wav").exists()) {
                growSound = Gdx.audio.newSound(Gdx.files.internal("sounds/grow.wav"));
            }
            if (Gdx.files.internal("sounds/item-get.wav").exists()) {
                itemGetSound = Gdx.audio.newSound(Gdx.files.internal("sounds/item-get.wav"));
            }
            if (Gdx.files.internal("sounds/door.wav").exists()) {
                doorSound = Gdx.audio.newSound(Gdx.files.internal("sounds/door.wav"));
            }
            if (Gdx.files.internal("sounds/powerup.wav").exists()) {
                powerupSound = Gdx.audio.newSound(Gdx.files.internal("sounds/powerup.wav"));
            }
            if (Gdx.files.internal("sounds/player_death.wav").exists()) {
                playerDeathSound = Gdx.audio.newSound(Gdx.files.internal("sounds/player_death.wav"));
            } else { Gdx.app.log("SoundManager", "player_death.wav not found."); }

            if (Gdx.files.internal("sounds/enemy_stomp.wav").exists()) {
                enemyStompSound = Gdx.audio.newSound(Gdx.files.internal("sounds/enemy_stomp.wav"));
            } else { Gdx.app.log("SoundManager", "enemy_stomp.wav not found."); }

        } catch (Exception e) {
            System.err.println("Error loading sounds: " + e.getMessage());
            // Consider setting soundEnabled = false here if critical sounds fail
        }
    }

    public void playMusic(String musicPath, float volume) {
        if (!musicEnabled || musicPath == null || musicPath.isEmpty()) return;

        if (currentMusic != null) {
            if (currentMusicPath != null && currentMusicPath.equals(musicPath) && currentMusic.isPlaying()) {
                currentMusic.setVolume(volume * this.musicVolume); // Adjust volume if same music
                return;
            }
            currentMusic.stop();
            currentMusic.dispose(); // Dispose old music before loading new
            currentMusic = null;
            currentMusicPath = null;
        }

        try {
            if (Gdx.files.internal(musicPath).exists()) {
                currentMusic = Gdx.audio.newMusic(Gdx.files.internal(musicPath));
                currentMusicPath = musicPath;
                currentMusic.setLooping(true);
                currentMusic.setVolume(volume * this.musicVolume); // Use the passed volume parameter
                currentMusic.play();
            } else {
                Gdx.app.error("SoundManager", "Music file not found: " + musicPath);
            }
        } catch (Exception e) {
            Gdx.app.error("SoundManager", "Error loading music: " + musicPath, e);
            if (currentMusic != null) currentMusic.dispose(); // Clean up if load failed
            currentMusic = null;
            currentMusicPath = null;
        }
    }

    // Method to play player death sound
    public void playPlayerDeath() {
        if (soundEnabled && playerDeathSound != null) {
            playerDeathSound.play(masterVolume);
        }
    }

    // Method to play enemy stomp sound
    public void playEnemyStomp() {
        if (soundEnabled && enemyStompSound != null) {
            enemyStompSound.play(masterVolume);
        }
    }


    public void stopMusic() {
        if (currentMusic != null) {
            currentMusic.stop();
        }
    }

    public void pauseMusic() {
        if (currentMusic != null) {
            currentMusic.pause();
        }
    }

    public void resumeMusic() {
        if (currentMusic != null && musicEnabled && !currentMusic.isPlaying()) {
            currentMusic.play();
        }
    }

    public void playJump() {
        if (soundEnabled && jumpSound != null) {
            jumpSound.play(masterVolume);
        }
    }

    public void playCoinCollect() {
        if (soundEnabled && coinSound != null) {
            coinSound.play(masterVolume * 0.8f);
        }
    }

    public void playPowerup() {
        if (soundEnabled) {
            if (powerupSound != null) {
                powerupSound.play(masterVolume);
            } else if (itemGetSound != null) { // Fallback
                itemGetSound.play(masterVolume);
            }
        }
    }

    public void playGrow() {
        if (soundEnabled && growSound != null) {
            growSound.play(masterVolume);
        }
    }

    public void playItemGet() {
        if (soundEnabled && itemGetSound != null) {
            itemGetSound.play(masterVolume);
        }
    }

    public void playDoor() {
        if (soundEnabled && doorSound != null) {
            doorSound.play(masterVolume * 0.7f);
        }
    }

    public void setMasterVolume(float volume) {
        this.masterVolume = Math.max(0f, Math.min(1f, volume));
        // Note: This does not retroactively change playing sound instances' volumes, only future ones.
        // LibGDX Sound instances don't typically have individual volume controls after play() without more complex pooling.
    }

    public float getMasterVolume() {
        return masterVolume;
    }

    public void setMusicVolume(float volume) {
        this.musicVolume = Math.max(0f, Math.min(1f, volume));
        if (currentMusic != null) {
            // This requires the 'volume' parameter in playMusic to be the level-specific volume
            // and this.musicVolume to be the global music volume setting.
            // For playMusic(String musicPath, float levelVolume), it would be:
            // currentMusic.setVolume(levelVolume * this.musicVolume);
            currentMusic.setVolume(currentMusic.getVolume() / (this.musicVolume == 0 ? 1 : this.musicVolume) * volume); // Re-calculate based on new global music volume
        }
    }

    public float getMusicVolume() {
        return musicVolume;
    }

    public void setSoundEnabled(boolean enabled) {
        this.soundEnabled = enabled;
    }

    public boolean isSoundEnabled() {
        return soundEnabled;
    }

    public void setMusicEnabled(boolean enabled) {
        this.musicEnabled = enabled;
        if (!enabled && currentMusic != null) {
            currentMusic.stop();
        } else if (enabled && currentMusic != null && !currentMusic.isPlaying()) {
            // Only play if it was previously stopped due to being disabled, and path is still valid
            if (currentMusicPath != null && Gdx.files.internal(currentMusicPath).exists()){
                currentMusic.play();
            }
        }
    }

    public boolean isMusicEnabled() {
        return musicEnabled;
    }

    @Override
    public void dispose() {
        if (jumpSound != null) jumpSound.dispose();
        if (coinSound != null) coinSound.dispose();
        if (growSound != null) growSound.dispose();
        if (itemGetSound != null) itemGetSound.dispose();
        if (doorSound != null) doorSound.dispose();
        if (powerupSound != null) powerupSound.dispose();
        if (playerDeathSound != null) playerDeathSound.dispose();
        if (enemyStompSound != null) enemyStompSound.dispose();

        if (currentMusic != null) {
            currentMusic.dispose();
            currentMusic = null;
        }
        currentMusicPath = null;
        instance = null; // Allow re-creation if needed
    }
}

================
File: src/main/java/io/github/game/WorldMap.java
================
// File: core/src/main/java/io/github/game/WorldMap.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Json;

public class WorldMap {

    private Texture worldMapTexture;
    private Array<WorldMapNode> nodes;
    private Array<Array<Vector2>> paths; // Paths connecting nodes
    private WorldMapNode currentSelectedNode;
    private WorldMapNode playerNode; // Current player position
    private Vector2 playerPosition;
    private Vector2 targetPosition;
    private boolean isMovingToTarget;
    private float moveSpeed = 120f;

    private BitmapFont font;
    private BitmapFont smallFont; // NEW: For UI elements
    private ShapeRenderer shapeRenderer;
    private Texture playerIconTexture;

    // Configuration system
    private WorldMapConfig config;

    // World map progress data
    private WorldMapProgress progress;
    private boolean levelSelectionMode = false;

    // Animation and effects
    private float animationTimer = 0f;
    private boolean showLevelInfo = false;

    // Debug mode for editing
    private boolean debugMode = false;
    private boolean editMode = false;
    private WorldMapNode selectedNodeForEdit = null;
    private Vector3 mousePos = new Vector3();
    private boolean wasMousePressed = false; // Track mouse state for release detection

    // NEW: Level assignment GUI
    private boolean showLevelAssignmentDialog = false;
    private WorldMapNode nodeForLevelAssignment = null;
    private Array<String> availableLevelFiles;
    private int selectedLevelFileIndex = -1;
    private Rectangle levelAssignmentDialogBounds;
    private Array<Rectangle> levelFileButtons;
    private Rectangle confirmAssignmentButton;
    private Rectangle cancelAssignmentButton;
    private float levelAssignmentScrollOffset = 0f;
    private float LEVEL_ASSIGNMENT_ITEM_HEIGHT = 35f;
    private final float LEVEL_ASSIGNMENT_DIALOG_WIDTH = 600f;
    private final float LEVEL_ASSIGNMENT_DIALOG_HEIGHT = 700f;

    // NEW: Node creation mode
    private boolean nodeCreationMode = false;
    private WorldMapNode.NodeType selectedNodeType = WorldMapNode.NodeType.LEVEL;

    public WorldMap() {
        this(false);
    }

    public WorldMap(boolean debugMode) {
        this.debugMode = debugMode;
        initialize();
    }

    private void initialize() {
        // Load configuration
        config = WorldMapConfig.loadFromFile();

        // Validate level files
        Array<String> missingFiles = config.validateLevelFiles();
        if (missingFiles.size > 0) {
            Gdx.app.log("WorldMap", "Missing level files detected:");
            for (String file : missingFiles) {
                Gdx.app.log("WorldMap", "  - " + file);
            }
            Gdx.app.log("WorldMap", "Consider creating these levels in the level editor (F1 in debug mode)");
        }

        // Load world map texture
        try {
            worldMapTexture = new Texture(config.worldMapTexturePath);
            Gdx.app.log("WorldMap", "Successfully loaded world map texture: " + config.worldMapTexturePath);
        } catch (Exception e) {
            Gdx.app.error("WorldMap", "Failed to load world map texture: " + config.worldMapTexturePath, e);
        }

        // Load player icon
        try {
            if (Gdx.files.internal("mario_sprites/playables/mario/mario_idle.png").exists()) {
                playerIconTexture = new Texture("mario_sprites/playables/mario/mario_idle.png");
            }
        } catch (Exception e) {
            Gdx.app.log("WorldMap", "Could not load player icon, will use simple rendering");
        }

        font = new BitmapFont();
        font.getData().setScale(1.2f);

        // NEW: Smaller font for UI
        smallFont = new BitmapFont();
        smallFont.getData().setScale(0.8f);

        shapeRenderer = new ShapeRenderer();

        nodes = new Array<>();
        paths = new Array<>();

        // Initialize world map progress
        progress = new WorldMapProgress();
        loadProgress();

        // Create the world map from configuration
        createWorldMapFromConfig();
        createPathsFromConfig();

        // Set move speed from config
        moveSpeed = config.playerMoveSpeed;

        // Set initial player position to first unlocked node
        setInitialPlayerPosition();

        // NEW: Initialize level assignment GUI
        initializeLevelAssignmentGUI();
        refreshAvailableLevelFiles();
    }

    private void initializeLevelAssignmentGUI() {
        availableLevelFiles = new Array<>();
        levelFileButtons = new Array<>();

        float screenWidth = Gdx.graphics.getWidth();
        float screenHeight = Gdx.graphics.getHeight();

        // FIXED: Scale dialog size based on screen size
        float scaleFactor = Math.min(screenWidth / 1920f, screenHeight / 1080f); // Scale based on common resolution
        scaleFactor = Math.max(scaleFactor, 0.8f); // Minimum scale factor

        float dialogWidth = 600f * scaleFactor; // Larger dialog
        float dialogHeight = 700f * scaleFactor; // Taller dialog

        // Center the dialog
        float dialogX = (screenWidth - dialogWidth) / 2f;
        float dialogY = (screenHeight - dialogHeight) / 2f;

        levelAssignmentDialogBounds = new Rectangle(dialogX, dialogY, dialogWidth, dialogHeight);

        // Buttons at bottom of dialog - scale these too
        float buttonWidth = 120f * scaleFactor;
        float buttonHeight = 40f * scaleFactor;
        float buttonSpacing = 20f * scaleFactor;

        confirmAssignmentButton = new Rectangle(
            dialogX + dialogWidth - buttonWidth * 2 - buttonSpacing - 10f * scaleFactor,
            dialogY + 15f * scaleFactor,
            buttonWidth, buttonHeight);

        cancelAssignmentButton = new Rectangle(
            dialogX + dialogWidth - buttonWidth - 10f * scaleFactor,
            dialogY + 15f * scaleFactor,
            buttonWidth, buttonHeight);

        // Update item height based on scaling
        LEVEL_ASSIGNMENT_ITEM_HEIGHT = 35f * scaleFactor;

        Gdx.app.log("WorldMap", "Initialized level assignment GUI with scale: " + scaleFactor);
    }


    // NEW: Refresh the list of available level files
    private void refreshAvailableLevelFiles() {
        availableLevelFiles.clear();

        // Scan the levels directory for .json files
        FileHandle levelsDir = Gdx.files.local("levels/");
        if (levelsDir.exists() && levelsDir.isDirectory()) {
            FileHandle[] levelFiles = levelsDir.list(".json");
            for (FileHandle file : levelFiles) {
                availableLevelFiles.add(file.name());
            }
        }

        // Add some default/template options
        availableLevelFiles.add("[Create New Level]");
        availableLevelFiles.add("[No Level Assigned]");

        Gdx.app.log("WorldMap", "Found " + (availableLevelFiles.size - 2) + " level files");

        // Recreate level file buttons
        updateLevelFileButtons();
    }

    // ENHANCED: Better button updating with proper coordinates
    private void updateLevelFileButtons() {
        levelFileButtons.clear();

        if (!showLevelAssignmentDialog) return;

        float scaleFactor = Math.min(Gdx.graphics.getWidth() / 1920f, Gdx.graphics.getHeight() / 1080f);
        scaleFactor = Math.max(scaleFactor, 0.8f);

        float listStartY = levelAssignmentDialogBounds.y + levelAssignmentDialogBounds.height - 100f * scaleFactor;
        float listHeight = levelAssignmentDialogBounds.height - 180f * scaleFactor; // More space for header and buttons
        int visibleItems = Math.max(1, (int)(listHeight / LEVEL_ASSIGNMENT_ITEM_HEIGHT));

        int startIndex = (int)(levelAssignmentScrollOffset / LEVEL_ASSIGNMENT_ITEM_HEIGHT);
        int endIndex = Math.min(startIndex + visibleItems, availableLevelFiles.size);

        for (int i = startIndex; i < endIndex; i++) {
            float buttonY = listStartY - (i - startIndex) * LEVEL_ASSIGNMENT_ITEM_HEIGHT;
            Rectangle button = new Rectangle(
                levelAssignmentDialogBounds.x + 10f * scaleFactor,
                buttonY - LEVEL_ASSIGNMENT_ITEM_HEIGHT,
                levelAssignmentDialogBounds.width - 20f * scaleFactor,
                LEVEL_ASSIGNMENT_ITEM_HEIGHT - 2f * scaleFactor
            );
            levelFileButtons.add(button);
        }
    }

    // Add these fields to handle scaling properly
    // NEW: Public methods for edit mode control
    public void toggleEditMode() {
        editMode = !editMode;
        if (editMode) {
            Gdx.app.log("WorldMap", "Edit mode enabled");
        } else {
            Gdx.app.log("WorldMap", "Edit mode disabled");
            selectedNodeForEdit = null;
            showLevelAssignmentDialog = false;
            nodeCreationMode = false;
            // Save configuration when exiting edit mode
            updateConfigFromNodes();
            config.saveToFile();
        }
    }

    public void setEditMode(boolean editMode) {
        this.editMode = editMode;
        if (!editMode) {
            selectedNodeForEdit = null;
            showLevelAssignmentDialog = false;
            nodeCreationMode = false;
        }
    }

    public boolean isEditMode() {
        return editMode;
    }

    private void createWorldMapFromConfig() {
        nodes.clear();

        for (int i = 0; i < config.nodes.size; i++) {
            WorldMapConfig.NodeConfig nodeConfig = config.nodes.get(i);

            // Convert string to enum
            WorldMapNode.NodeType nodeType;
            try {
                nodeType = WorldMapNode.NodeType.valueOf(nodeConfig.nodeType);
            } catch (IllegalArgumentException e) {
                Gdx.app.error("WorldMap", "Invalid node type: " + nodeConfig.nodeType + ", defaulting to LEVEL");
                nodeType = WorldMapNode.NodeType.LEVEL;
            }

            // Create the node
            WorldMapNode node = new WorldMapNode(
                nodeConfig.x, nodeConfig.y,
                nodeConfig.displayName,
                nodeType,
                nodeConfig.worldNumber,
                nodeConfig.levelNumber
            );

            // Set level file name for loading
            node.setLevelFileName(nodeConfig.levelFileName);

            // Set initial state based on config
            if (nodeConfig.startsUnlocked) {
                node.unlock();
            }

            nodes.add(node);
        }

        // Apply saved progress
        applyProgress();

        Gdx.app.log("WorldMap", "Created " + nodes.size + " nodes from configuration");
    }

    private void createPathsFromConfig() {
        paths.clear();

        for (WorldMapConfig.PathConfig pathConfig : config.paths) {
            if (pathConfig.fromNodeIndex >= 0 && pathConfig.fromNodeIndex < nodes.size &&
                pathConfig.toNodeIndex >= 0 && pathConfig.toNodeIndex < nodes.size) {

                WorldMapNode fromNode = nodes.get(pathConfig.fromNodeIndex);
                WorldMapNode toNode = nodes.get(pathConfig.toNodeIndex);

                Array<Vector2> path = new Array<>();
                Vector2 start = fromNode.getPosition().cpy();
                Vector2 end = toNode.getPosition().cpy();

                // Add start point
                path.add(start);

                // Add intermediate points if any
                for (WorldMapConfig.PathPoint point : pathConfig.intermediatePoints) {
                    path.add(new Vector2(point.x, point.y));
                }

                // Add end point
                path.add(end);

                paths.add(path);
            }
        }

        Gdx.app.log("WorldMap", "Created " + paths.size + " paths from configuration");
    }

    /**
     * Load a level by its file name. This integrates with the level editor system.
     */
    public Level loadLevelByFileName(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            Gdx.app.error("WorldMap", "Invalid level file name");
            return null;
        }

        try {
            FileHandle levelFile = Gdx.files.local("levels/" + fileName);
            if (levelFile.exists()) {
                Json json = new Json();
                Level level = json.fromJson(Level.class, levelFile.readString());
                Gdx.app.log("WorldMap", "Successfully loaded level: " + fileName);
                return level;
            } else {
                Gdx.app.log("WorldMap", "Level file not found: " + fileName + ", creating default level");
                return createDefaultLevelForNode(fileName);
            }
        } catch (Exception e) {
            Gdx.app.error("WorldMap", "Failed to load level: " + fileName, e);
            return createDefaultLevelForNode(fileName);
        }
    }

    /**
     * Create a default level when the JSON file doesn't exist.
     * This ensures the game doesn't crash and gives developers a starting point.
     */
    private Level createDefaultLevelForNode(String fileName) {
        String levelName = fileName.replace(".json", "").replace("_", " ");
        Level level = new Level(levelName);

        // Add basic ground
        Level.PlatformData ground = new Level.PlatformData(
            0, 0, 32f * 20, 32f * 2, Platform.PlatformType.GROUND
        );
        level.addPlatform(ground);

        // Add some basic elements based on file name
        if (fileName.contains("world_1")) {
            addBasicWorld1Elements(level);
        } else if (fileName.contains("world_2")) {
            addBasicWorld2Elements(level);
        } else if (fileName.contains("world_3")) {
            addBasicWorld3Elements(level);
        } else if (fileName.contains("world_4")) {
            addBasicWorld4Elements(level);
        } else if (fileName.contains("castle") || fileName.contains("fortress")) {
            addBasicCastleElements(level);
        } else if (fileName.contains("bonus") || fileName.contains("warp")) {
            addBasicSpecialElements(level);
        }

        // Add goal post
        level.setGoalPost(32f * 18, 32f * 2);

        // Save the default level for future editing
        saveDefaultLevel(level, fileName);

        return level;
    }

    private void addBasicWorld1Elements(Level level) {
        // Simple grass world
        level.addPlatform(new Level.PlatformData(200, 96, 32, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(300, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addEnemy(new Level.EnemyData(250, 64, "GOOMBA"));
        level.addPowerup(new Level.PowerupData(300, 160, "MUSHROOM"));
    }

    private void addBasicWorld2Elements(Level level) {
        // Desert world - more challenging
        level.addPlatform(new Level.PlatformData(150, 128, 64, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(300, 160, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addEnemy(new Level.EnemyData(200, 96, "KOOPA"));
        level.addEnemy(new Level.EnemyData(350, 64, "GOOMBA"));
    }

    private void addBasicWorld3Elements(Level level) {
        // Water world
        level.addPlatform(new Level.PlatformData(180, 128, 96, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(320, 160, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addEnemy(new Level.EnemyData(220, 160, "GOOMBA"));
        level.addPowerup(new Level.PowerupData(320, 192, "FIRE_FLOWER"));
    }

    private void addBasicWorld4Elements(Level level) {
        // Ice world - most challenging
        level.addPlatform(new Level.PlatformData(160, 160, 32, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(240, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(320, 96, 96, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addEnemy(new Level.EnemyData(200, 192, "KOOPA"));
        level.addEnemy(new Level.EnemyData(360, 128, "KOOPA"));
    }

    private void addBasicCastleElements(Level level) {
        // Castle/fortress level - boss fight style
        level.addPlatform(new Level.PlatformData(200, 96, 128, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(400, 128, 64, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addEnemy(new Level.EnemyData(250, 128, "KOOPA"));
        level.addEnemy(new Level.EnemyData(300, 128, "KOOPA"));
        level.addPowerup(new Level.PowerupData(232, 128, "FIRE_FLOWER"));
    }

    private void addBasicSpecialElements(Level level) {
        // Special level - bonus or warp zone
        level.addPlatform(new Level.PlatformData(150, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(250, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(350, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPowerup(new Level.PowerupData(200, 96, "STAR"));
        level.addPowerup(new Level.PowerupData(300, 96, "CHICKEN"));
    }

    private void saveDefaultLevel(Level level, String fileName) {
        try {
            Json json = new Json();
            FileHandle dir = Gdx.files.local("levels/");
            if (!dir.exists()) {
                dir.mkdirs();
            }
            FileHandle file = Gdx.files.local("levels/" + fileName);
            file.writeString(json.prettyPrint(level), false);
            Gdx.app.log("WorldMap", "Saved default level: " + fileName);
        } catch (Exception e) {
            Gdx.app.error("WorldMap", "Failed to save default level: " + fileName, e);
        }
    }



    public void update(float deltaTime) {
        animationTimer += deltaTime;

        // Update all nodes
        for (WorldMapNode node : nodes) {
            node.update(deltaTime);
        }

        if (debugMode && editMode) {
            // Edit mode input is handled separately with camera
            // This will be called from render method
        } else {
            handleInput();
            updatePlayerMovement(deltaTime);
        }
    }

    public void update(float deltaTime, OrthographicCamera camera) {
        animationTimer += deltaTime;

        // Update all nodes
        for (WorldMapNode node : nodes) {
            node.update(deltaTime);
        }

        if (debugMode && editMode) {
            updateEditMode(deltaTime, camera);
        } else {
            handleInput();
            updatePlayerMovement(deltaTime);
        }
    }

    private void handleInput() {
        if (isMovingToTarget) return; // Don't process input while moving

        // Arrow key navigation
        WorldMapNode newTarget = null;

        if (Gdx.input.isKeyJustPressed(Input.Keys.RIGHT) || Gdx.input.isKeyJustPressed(Input.Keys.D)) {
            newTarget = findNextNode(1, 0); // Move right
        } else if (Gdx.input.isKeyJustPressed(Input.Keys.LEFT) || Gdx.input.isKeyJustPressed(Input.Keys.A)) {
            newTarget = findNextNode(-1, 0); // Move left
        } else if (Gdx.input.isKeyJustPressed(Input.Keys.UP) || Gdx.input.isKeyJustPressed(Input.Keys.W)) {
            newTarget = findNextNode(0, 1); // Move up
        } else if (Gdx.input.isKeyJustPressed(Input.Keys.DOWN) || Gdx.input.isKeyJustPressed(Input.Keys.S)) {
            newTarget = findNextNode(0, -1); // Move down
        }

        if (newTarget != null && newTarget.isAccessible()) {
            moveToNode(newTarget);
        }

        // Enter level
        if (Gdx.input.isKeyJustPressed(Input.Keys.ENTER) || Gdx.input.isKeyJustPressed(Input.Keys.SPACE)) {
            if (currentSelectedNode != null && currentSelectedNode.isAccessible()) {
                enterLevel(currentSelectedNode);
            }
        }

        // Toggle level info
        if (Gdx.input.isKeyJustPressed(Input.Keys.I)) {
            showLevelInfo = !showLevelInfo;
        }
    }
    // File: core/src/main/java/io/github/game/WorldMap.java
// ENHANCED: Much more user-friendly world map editor

    public void updateEditMode(float deltaTime, OrthographicCamera camera) {
        if (!debugMode || !editMode) return;

        animationTimer += deltaTime;

        // Update all nodes
        for (WorldMapNode node : nodes) {
            node.update(deltaTime);
        }

        // ENHANCED: Much more reliable mouse coordinate handling
        Vector3 screenPos = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0);
        Vector3 worldPos = screenPos.cpy();
        camera.unproject(worldPos);

        boolean isMousePressed = Gdx.input.isButtonPressed(Input.Buttons.LEFT);
        boolean mouseJustPressed = Gdx.input.isButtonJustPressed(Input.Buttons.LEFT);
        boolean mouseJustReleased = wasMousePressed && !isMousePressed;
        boolean rightMouseJustPressed = Gdx.input.isButtonJustPressed(Input.Buttons.RIGHT);

        // Handle level assignment dialog input first
        if (showLevelAssignmentDialog) {
            handleLevelAssignmentDialogInput(camera);
            wasMousePressed = isMousePressed;
            return;
        }

        // ENHANCED: Much larger and more forgiving hit detection
        if (mouseJustPressed) {
            selectedNodeForEdit = null;
            float bestDistance = Float.MAX_VALUE;

            Gdx.app.log("WorldMap", "Mouse click at world position: (" + (int)worldPos.x + ", " + (int)worldPos.y + ")");

            // ENHANCED: Much more generous hit detection
            for (int i = 0; i < nodes.size; i++) {
                WorldMapNode node = nodes.get(i);
                Vector2 nodePos = node.getPosition();
                float distance = Vector2.dst(worldPos.x, worldPos.y, nodePos.x, nodePos.y);

                // ENHANCED: Much larger hit radius based on zoom level
                float baseRadius = (node.getType() == WorldMapNode.NodeType.CASTLE) ?
                    WorldMapNode.CASTLE_SIZE : WorldMapNode.NODE_SIZE;
                float hitRadius = Math.max(baseRadius * 2f, 80f) * camera.zoom; // Scale with zoom

                Gdx.app.log("WorldMap", "Node " + i + " (" + node.getLevelName() + ") at (" +
                    (int)nodePos.x + ", " + (int)nodePos.y + ") distance: " + (int)distance +
                    " hitRadius: " + (int)hitRadius);

                if (distance <= hitRadius && distance < bestDistance) {
                    selectedNodeForEdit = node;
                    bestDistance = distance;
                    Gdx.app.log("WorldMap", "Selected node: " + node.getLevelName());
                }
            }

            if (selectedNodeForEdit != null) {
                Gdx.app.log("WorldMap", "Final selection: " + selectedNodeForEdit.getLevelName() +
                    " at distance: " + (int)bestDistance);

                // Play selection sound for feedback
                SoundManager.getInstance().playJump();
            } else if (nodeCreationMode) {
                createNewNodeAt(worldPos.x, worldPos.y);
            } else {
                Gdx.app.log("WorldMap", "No node selected - try clicking closer to a node");
                Gdx.app.log("WorldMap", "TIP: Enable node creation mode with 'C' to create new nodes");
            }
        }

        // ENHANCED: Better right-click detection for level assignment
        if (rightMouseJustPressed) {
            WorldMapNode rightClickedNode = null;
            float bestDistance = Float.MAX_VALUE;

            for (WorldMapNode node : nodes) {
                Vector2 nodePos = node.getPosition();
                float distance = Vector2.dst(worldPos.x, worldPos.y, nodePos.x, nodePos.y);
                float baseRadius = (node.getType() == WorldMapNode.NodeType.CASTLE) ?
                    WorldMapNode.CASTLE_SIZE : WorldMapNode.NODE_SIZE;
                float hitRadius = Math.max(baseRadius * 2f, 80f) * camera.zoom;

                if (distance <= hitRadius && distance < bestDistance) {
                    rightClickedNode = node;
                    bestDistance = distance;
                }
            }

            if (rightClickedNode != null) {
                openLevelAssignmentDialog(rightClickedNode);
                SoundManager.getInstance().playDoor(); // Audio feedback
                Gdx.app.log("WorldMap", "Right-clicked node: " + rightClickedNode.getLevelName());
            }
        }

        // ENHANCED: Smoother dragging with snap-to-grid option
        if (isMousePressed && selectedNodeForEdit != null) {
            float newX = worldPos.x;
            float newY = worldPos.y;

            // ENHANCED: Optional snap-to-grid (hold SHIFT)
            if (Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT)) {
                float gridSize = 32f; // Snap to 32-pixel grid
                newX = Math.round(newX / gridSize) * gridSize;
                newY = Math.round(newY / gridSize) * gridSize;
            }

            selectedNodeForEdit.setPosition(newX, newY);

            // Update player position if this is the current node
            if (selectedNodeForEdit == currentSelectedNode) {
                playerPosition.set(newX, newY);
                targetPosition.set(newX, newY);
            }
        }

        if (mouseJustReleased) {
            if (selectedNodeForEdit != null) {
                Gdx.app.log("WorldMap", "Finished moving " + selectedNodeForEdit.getLevelName() + " to " +
                    "(" + (int)selectedNodeForEdit.getPosition().x + ", " + (int)selectedNodeForEdit.getPosition().y + ")");

                // Update configuration immediately
                updateConfigFromNodes();
                createPathsFromConfig();

                // Auto-save after each move
                config.saveToFile();
                Gdx.app.log("WorldMap", "Auto-saved configuration");
            }
            selectedNodeForEdit = null;
        }

        wasMousePressed = isMousePressed;
        handleEditModeKeyboard();
    }

    // ENHANCED: Much better keyboard handling with more features
    private void handleEditModeKeyboard() {
        // Toggle node creation mode with visual feedback
        if (Gdx.input.isKeyJustPressed(Input.Keys.C)) {
            nodeCreationMode = !nodeCreationMode;
            if (nodeCreationMode) {
                SoundManager.getInstance().playItemGet();
            } else {
                SoundManager.getInstance().playJump();
            }
            Gdx.app.log("WorldMap", "Node creation mode: " + (nodeCreationMode ? "ON (Click anywhere to create)" : "OFF"));
        }

        // ENHANCED: Easy node type selection with number keys
        if (nodeCreationMode) {
            WorldMapNode.NodeType oldType = selectedNodeType;

            if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_1)) {
                selectedNodeType = WorldMapNode.NodeType.LEVEL;
            } else if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_2)) {
                selectedNodeType = WorldMapNode.NodeType.CASTLE;
            } else if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_3)) {
                selectedNodeType = WorldMapNode.NodeType.FORTRESS;
            } else if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_4)) {
                selectedNodeType = WorldMapNode.NodeType.GHOST_HOUSE;
            } else if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_5)) {
                selectedNodeType = WorldMapNode.NodeType.SPECIAL;
            }

            if (oldType != selectedNodeType) {
                SoundManager.getInstance().playCoinCollect();
                Gdx.app.log("WorldMap", "Node type changed to: " + selectedNodeType);
            }
        }

        // ENHANCED: Better deletion with confirmation
        if (Gdx.input.isKeyJustPressed(Input.Keys.DEL) || Gdx.input.isKeyJustPressed(Input.Keys.BACKSPACE)) {
            if (selectedNodeForEdit != null) {
                // ENHANCED: Require holding SHIFT for deletion to prevent accidents
                if (Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT)) {
                    String nodeName = selectedNodeForEdit.getLevelName();
                    deleteNode(selectedNodeForEdit);
                    SoundManager.getInstance().playEnemyStomp(); // Deletion sound
                    Gdx.app.log("WorldMap", "DELETED node: " + nodeName);
                } else {
                    Gdx.app.log("WorldMap", "Hold SHIFT + DELETE to delete node: " + selectedNodeForEdit.getLevelName());
                }
            } else {
                Gdx.app.log("WorldMap", "No node selected for deletion. Click a node first.");
            }
        }

        // ENHANCED: Copy/duplicate node functionality
        if (Gdx.input.isKeyJustPressed(Input.Keys.V) && selectedNodeForEdit != null) {
            if (Gdx.input.isKeyPressed(Input.Keys.CONTROL_LEFT) || Gdx.input.isKeyPressed(Input.Keys.CONTROL_RIGHT)) {
                duplicateNode(selectedNodeForEdit);
            }
        }

        // Refresh level files
        if (Gdx.input.isKeyJustPressed(Input.Keys.R)) {
            refreshAvailableLevelFiles();
            SoundManager.getInstance().playItemGet();
            Gdx.app.log("WorldMap", "Refreshed level file list (" + availableLevelFiles.size + " files found)");
        }

        // ENHANCED: Quick save and load
        if (Gdx.input.isKeyJustPressed(Input.Keys.F3) ||
            (Gdx.input.isKeyPressed(Input.Keys.CONTROL_LEFT) && Gdx.input.isKeyJustPressed(Input.Keys.S))) {
            updateConfigFromNodes();
            config.saveToFile();
            SoundManager.getInstance().playDoor();
            Gdx.app.log("WorldMap", "*** World map configuration SAVED! ***");
        }

        // ENHANCED: Auto-backup
        if (Gdx.input.isKeyJustPressed(Input.Keys.F4)) {
            createBackup();
        }
    }

    // NEW: Duplicate node functionality
    private void duplicateNode(WorldMapNode originalNode) {
        float offsetX = 50f; // Offset the duplicate
        float offsetY = 0f;

        String newName = originalNode.getLevelName() + " Copy";
        WorldMapNode duplicate = new WorldMapNode(
            originalNode.getPosition().x + offsetX,
            originalNode.getPosition().y + offsetY,
            newName,
            originalNode.getType(),
            originalNode.getWorldNumber(),
            originalNode.getLevelNumber() + 100 // Offset level number
        );

        duplicate.setLevelFileName(originalNode.getLevelFileName());
        duplicate.unlock(); // Start unlocked for testing
        nodes.add(duplicate);

        selectedNodeForEdit = duplicate;
        SoundManager.getInstance().playItemGet();
        Gdx.app.log("WorldMap", "Duplicated node: " + newName);
    }

    // NEW: Create backup functionality
    private void createBackup() {
        try {
            updateConfigFromNodes();
            Json json = new Json();
            String timestamp = String.valueOf(System.currentTimeMillis());
            FileHandle backupFile = Gdx.files.local("config/worldmap_backup_" + timestamp + ".json");
            backupFile.writeString(json.prettyPrint(config), false);
            SoundManager.getInstance().playItemGet();
            Gdx.app.log("WorldMap", "Backup created: " + backupFile.name());
        } catch (Exception e) {
            Gdx.app.error("WorldMap", "Failed to create backup", e);
        }
    }


    // NEW: Enhanced edit mode UI rendering
    private void renderEditModeUI(SpriteBatch batch, OrthographicCamera camera) {
        // Draw mouse cursor indicator in world space
        Vector3 screenPos = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0);
        Vector3 worldPos = screenPos.cpy();
        camera.unproject(worldPos);

        // Draw cursor crosshair
        batch.end();
        shapeRenderer.setProjectionMatrix(camera.combined);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);

        // ENHANCED: Visual cursor in world space
        shapeRenderer.setColor(Color.CYAN);
        float crossSize = 20f * camera.zoom;
        shapeRenderer.line(worldPos.x - crossSize, worldPos.y, worldPos.x + crossSize, worldPos.y);
        shapeRenderer.line(worldPos.x, worldPos.y - crossSize, worldPos.x, worldPos.y + crossSize);

        // ENHANCED: Show hit radius for all nodes
        shapeRenderer.setColor(0.5f, 0.5f, 1f, 0.3f);
        for (WorldMapNode node : nodes) {
            Vector2 nodePos = node.getPosition();
            float baseRadius = (node.getType() == WorldMapNode.NodeType.CASTLE) ?
                WorldMapNode.CASTLE_SIZE : WorldMapNode.NODE_SIZE;
            float hitRadius = Math.max(baseRadius * 2f, 80f) * camera.zoom;
            shapeRenderer.circle(nodePos.x, nodePos.y, hitRadius, 20);
        }

        // ENHANCED: Highlight selected node more obviously
        if (selectedNodeForEdit != null) {
            shapeRenderer.setColor(Color.YELLOW);
            Gdx.gl.glLineWidth(4f);
            Vector2 pos = selectedNodeForEdit.getPosition();
            float size = (selectedNodeForEdit.getType() == WorldMapNode.NodeType.CASTLE) ?
                WorldMapNode.CASTLE_SIZE : WorldMapNode.NODE_SIZE;
            float highlightRadius = size + 15f;
            shapeRenderer.circle(pos.x, pos.y, highlightRadius, 16);

            // Draw selection arrows
            float arrowSize = 20f;
            shapeRenderer.line(pos.x - highlightRadius - arrowSize, pos.y, pos.x - highlightRadius, pos.y);
            shapeRenderer.line(pos.x + highlightRadius, pos.y, pos.x + highlightRadius + arrowSize, pos.y);
            shapeRenderer.line(pos.x, pos.y - highlightRadius - arrowSize, pos.x, pos.y - highlightRadius);
            shapeRenderer.line(pos.x, pos.y + highlightRadius, pos.x, pos.y + highlightRadius + arrowSize);
        }

        // ENHANCED: Show creation preview
        if (nodeCreationMode) {
            shapeRenderer.setColor(Color.GREEN);
            float previewSize = (selectedNodeType == WorldMapNode.NodeType.CASTLE) ?
                WorldMapNode.CASTLE_SIZE : WorldMapNode.NODE_SIZE;
            shapeRenderer.circle(worldPos.x, worldPos.y, previewSize, 12);

            // Pulsing effect
            float pulse = 1.0f + 0.3f * (float)Math.sin(animationTimer * 6f);
            shapeRenderer.circle(worldPos.x, worldPos.y, previewSize * pulse, 12);
        }

        shapeRenderer.end();
        Gdx.gl.glLineWidth(1f);
        batch.begin();
    }

    // ENHANCED: Much better edit mode instructions in renderUI
    private void renderEditModeInstructions(SpriteBatch batch) {
        if (!editMode) return;

        // ENHANCED: More comprehensive and organized instructions
        String[] basicInstructions = {
            "=== WORLD MAP EDITOR ===",
            "Mouse: Click nodes to select, drag to move",
            "Right-click: Assign level file to node",
            "WASD: Move camera around the map",
            "",
            "=== NODE CREATION ===",
            "C: Toggle creation mode " + (nodeCreationMode ? "[ON]" : "[OFF]"),
            "1-5: Select node type " + (nodeCreationMode ? "[" + selectedNodeType + "]" : ""),
            "Click empty space: Create new node",
            "",
            "=== NODE EDITING ===",
            "SHIFT + Drag: Snap to grid",
            "SHIFT + DEL: Delete selected node",
            "CTRL + V: Duplicate selected node",
            "",
            "=== FILE OPERATIONS ===",
            "F3 / CTRL+S: Save configuration",
            "F4: Create backup",
            "R: Refresh level file list",
            "F2 / ESC: Exit edit mode"
        };

        // Draw with better formatting
        smallFont.setColor(Color.WHITE);
        for (int i = 0; i < basicInstructions.length; i++) {
            String instruction = basicInstructions[i];
            if (instruction.startsWith("===")) {
                font.setColor(Color.CYAN);
                font.draw(batch, instruction, 20, 400 - (i * 18));
            } else if (instruction.isEmpty()) {
                continue; // Skip empty lines
            } else {
                smallFont.setColor(Color.LIGHT_GRAY);
                smallFont.draw(batch, instruction, 20, 400 - (i * 18));
            }
        }

        // Status information
        if (selectedNodeForEdit != null) {
            font.setColor(Color.YELLOW);
            font.draw(batch, "SELECTED: " + selectedNodeForEdit.getLevelName(),
                20, Gdx.graphics.getHeight() - 80);
            smallFont.setColor(Color.WHITE);
            smallFont.draw(batch, "Position: (" + (int)selectedNodeForEdit.getPosition().x +
                ", " + (int)selectedNodeForEdit.getPosition().y + ")", 20, Gdx.graphics.getHeight() - 110);
            if (selectedNodeForEdit.getLevelFileName() != null) {
                smallFont.draw(batch, "Level: " + selectedNodeForEdit.getLevelFileName(),
                    20, Gdx.graphics.getHeight() - 130);
            }
        }
    }

    // FIXED: Enhanced method to get next level with better logic
    public WorldMapNode getNextLevel(WorldMapNode currentNode) {
        if (currentNode == null) return null;

        int currentIndex = nodes.indexOf(currentNode, true);
        if (currentIndex == -1) return null;

        // First try to find via paths (proper world map progression)
        for (WorldMapConfig.PathConfig path : config.paths) {
            if (path.fromNodeIndex == currentIndex &&
                path.toNodeIndex >= 0 && path.toNodeIndex < nodes.size) {
                WorldMapNode nextNode = nodes.get(path.toNodeIndex);
                // Only return if the next node is accessible or can be unlocked
                if (nextNode.isAccessible() || nextNode.getState() == WorldMapNode.NodeState.LOCKED) {
                    return nextNode;
                }
            }
        }

        // Fallback: next in sequence (for linear progression)
        if (currentIndex + 1 < nodes.size) {
            WorldMapNode nextNode = nodes.get(currentIndex + 1);
            if (nextNode.isAccessible() || nextNode.getState() == WorldMapNode.NodeState.LOCKED) {
                return nextNode;
            }
        }

        return null; // No next level
    }


    // FIXED: Method to check if there's a next level available
    public boolean hasNextLevel(WorldMapNode currentNode) {
        WorldMapNode nextLevel = getNextLevel(currentNode);
        return nextLevel != null;
    }

    // FIXED: Enhanced method to advance to next level with proper unlocking
    public boolean advanceToNextLevel() {
        if (currentSelectedNode == null) return false;

        WorldMapNode nextLevel = getNextLevel(currentSelectedNode);
        if (nextLevel != null) {
            // If the next level is locked, unlock it first
            if (nextLevel.getState() == WorldMapNode.NodeState.LOCKED) {
                nextLevel.unlock();
                Gdx.app.log("WorldMap", "Unlocked next level: " + nextLevel.getLevelName());
            }

            // Move to the next level if it's accessible
            if (nextLevel.isAccessible()) {
                moveToNode(nextLevel);
                enterLevel(nextLevel);
                return true;
            }
        }
        return false;
    }

    // FIXED: Enhanced level completion with proper progression
    public void completeLevel(String levelName) {
        Gdx.app.log("WorldMap", "Completing level: " + levelName);

        for (WorldMapNode node : nodes) {
            if (node.getLevelName().equals(levelName)) {
                node.complete();
                Gdx.app.log("WorldMap", "Marked level as completed: " + levelName);

                // Unlock next level(s) based on paths
                unlockNextLevel(node);

                // Save progress after completing level
                saveProgress();
                break;
            }
        }
    }

    // FIXED: Better next level unlocking logic
    private void unlockNextLevel(WorldMapNode completedNode) {
        int completedIndex = nodes.indexOf(completedNode, true);
        boolean unlockedNext = false;

        Gdx.app.log("WorldMap", "Looking for next levels to unlock after completing: " + completedNode.getLevelName());

        // Check paths to find connected nodes
        for (int i = 0; i < config.paths.size; i++) {
            WorldMapConfig.PathConfig path = config.paths.get(i);
            if (path.fromNodeIndex == completedIndex) {
                // This path starts from the completed node, unlock the destination
                if (path.toNodeIndex >= 0 && path.toNodeIndex < nodes.size) {
                    WorldMapNode nextNode = nodes.get(path.toNodeIndex);
                    if (nextNode.getState() == WorldMapNode.NodeState.LOCKED) {
                        nextNode.unlock();
                        unlockedNext = true;
                        Gdx.app.log("WorldMap", "Unlocked next level via path: " + nextNode.getLevelName());
                    }
                }
            }
        }

        // FIXED: Fallback - if no path-based unlocking worked, unlock next node in sequence
        if (!unlockedNext && completedIndex + 1 < nodes.size) {
            WorldMapNode nextNode = nodes.get(completedIndex + 1);
            if (nextNode.getState() == WorldMapNode.NodeState.LOCKED) {
                nextNode.unlock();
                unlockedNext = true;
                Gdx.app.log("WorldMap", "Unlocked next level by sequence: " + nextNode.getLevelName());
            }
        }

        if (!unlockedNext) {
            Gdx.app.log("WorldMap", "No more levels to unlock after: " + completedNode.getLevelName());
        }
    }

    // FIXED: Enhanced method to set the initially selected node
    public void setCurrentSelectedNode(WorldMapNode node) {
        if (currentSelectedNode != null) {
            currentSelectedNode.setSelected(false);
        }

        currentSelectedNode = node;
        if (node != null) {
            node.setSelected(true);
            // Update player position to match selected node
            playerPosition = node.getPosition().cpy();
            targetPosition = playerPosition.cpy();
            playerNode = node;
            isMovingToTarget = false;
        }
    }

    // FIXED: Get level name that works with both display names and file names
    public String getCurrentLevelDisplayName() {
        return currentSelectedNode != null ? currentSelectedNode.getLevelName() : null;
    }

    // FIXED: Better initial player position setting that finds the first accessible node
    private void setInitialPlayerPosition() {
        // Find the first unlocked level and set player there
        WorldMapNode firstUnlocked = null;

        for (WorldMapNode node : nodes) {
            if (node.isAccessible()) {
                firstUnlocked = node;
                break;
            }
        }

        // If no unlocked nodes, unlock the first one
        if (firstUnlocked == null && nodes.size > 0) {
            nodes.get(0).unlock();
            firstUnlocked = nodes.get(0);
            Gdx.app.log("WorldMap", "No unlocked nodes found, unlocked first node: " + firstUnlocked.getLevelName());
        }

        if (firstUnlocked != null) {
            setCurrentSelectedNode(firstUnlocked);
            Gdx.app.log("WorldMap", "Set initial position to: " + firstUnlocked.getLevelName());
        }
    }

    // FIXED: Enhanced method to find accessible nodes in a direction
    private WorldMapNode findNextNode(int dirX, int dirY) {
        if (currentSelectedNode == null) return null;

        Vector2 currentPos = currentSelectedNode.getPosition();
        WorldMapNode closest = null;
        float closestDistance = Float.MAX_VALUE;

        for (WorldMapNode node : nodes) {
            if (node == currentSelectedNode) continue;
            if (!node.isAccessible()) continue; // Only move to accessible nodes

            Vector2 nodePos = node.getPosition();
            Vector2 direction = nodePos.cpy().sub(currentPos);

            // Avoid division by zero
            if (direction.len() == 0) continue;
            direction.nor();

            // Check if this node is in the desired direction
            boolean isInDirection = false;
            float threshold = 0.3f; // Directional threshold

            if (dirX > 0 && direction.x > threshold) isInDirection = true; // Right
            else if (dirX < 0 && direction.x < -threshold) isInDirection = true; // Left
            else if (dirY > 0 && direction.y > threshold) isInDirection = true; // Up
            else if (dirY < 0 && direction.y < -threshold) isInDirection = true; // Down

            if (isInDirection) {
                float distance = currentPos.dst(nodePos);
                if (distance < closestDistance) {
                    closest = node;
                    closestDistance = distance;
                }
            }
        }

        return closest;
    }

    // FIXED: Debug method to log world map state
    public void logWorldMapState() {
        Gdx.app.log("WorldMap", "=== WORLD MAP STATE ===");
        Gdx.app.log("WorldMap", "Total nodes: " + nodes.size);
        Gdx.app.log("WorldMap", "Current selected: " + (currentSelectedNode != null ? currentSelectedNode.getLevelName() : "None"));

        for (int i = 0; i < nodes.size; i++) {
            WorldMapNode node = nodes.get(i);
            String status = "";
            if (node == currentSelectedNode) status += "[CURRENT] ";
            status += node.getLevelName() + " (" + node.getState() + ")";
            if (node.getLevelFileName() != null) {
                status += " -> " + node.getLevelFileName();
            }
            Gdx.app.log("WorldMap", "Node " + i + ": " + status);
        }

        Gdx.app.log("WorldMap", "======================");
    }

    // NEW: Create a new node at the specified position
    private void createNewNodeAt(float x, float y) {
        // Find the next available world/level number
        int worldNum = 1;
        int levelNum = 1;

        // Simple logic: find highest world number and add 1
        for (WorldMapNode node : nodes) {
            if (node.getWorldNumber() >= worldNum) {
                worldNum = node.getWorldNumber();
                if (node.getLevelNumber() >= levelNum) {
                    levelNum = node.getLevelNumber() + 1;
                }
            }
        }

        if (levelNum > 4) { // Assume max 4 levels per world
            worldNum++;
            levelNum = 1;
        }

        String nodeName = worldNum + "-" + levelNum;
        if (selectedNodeType != WorldMapNode.NodeType.LEVEL) {
            nodeName = selectedNodeType.toString() + " " + worldNum;
        }

        WorldMapNode newNode = new WorldMapNode(x, y, nodeName, selectedNodeType, worldNum, levelNum);
        newNode.unlock(); // Start unlocked for testing
        nodes.add(newNode);

        // Add to configuration
        WorldMapConfig.NodeConfig nodeConfig = new WorldMapConfig.NodeConfig(
            x, y, nodeName.toLowerCase().replace(" ", "_") + ".json",
            nodeName, selectedNodeType.toString(), worldNum, levelNum, false);
        config.addNode(nodeConfig);

        selectedNodeForEdit = newNode;
        Gdx.app.log("WorldMap", "Created new node: " + nodeName + " at (" + (int)x + ", " + (int)y + ")");
    }

    // NEW: Delete a node
    private void deleteNode(WorldMapNode node) {
        if (nodes.size <= 1) {
            Gdx.app.log("WorldMap", "Cannot delete last node");
            return;
        }

        int nodeIndex = nodes.indexOf(node, true);
        if (nodeIndex >= 0) {
            nodes.removeIndex(nodeIndex);

            // Remove from configuration
            if (nodeIndex < config.nodes.size) {
                config.nodes.removeIndex(nodeIndex);
            }

            // Remove any paths involving this node
            for (int i = config.paths.size - 1; i >= 0; i--) {
                WorldMapConfig.PathConfig path = config.paths.get(i);
                if (path.fromNodeIndex == nodeIndex || path.toNodeIndex == nodeIndex) {
                    config.paths.removeIndex(i);
                } else {
                    // Adjust indices for remaining paths
                    if (path.fromNodeIndex > nodeIndex) path.fromNodeIndex--;
                    if (path.toNodeIndex > nodeIndex) path.toNodeIndex--;
                }
            }

            createPathsFromConfig();
            selectedNodeForEdit = null;

            Gdx.app.log("WorldMap", "Deleted node: " + node.getLevelName());
        }
    }

    // NEW: Open level assignment dialog
    private void openLevelAssignmentDialog(WorldMapNode node) {
        nodeForLevelAssignment = node;
        showLevelAssignmentDialog = true;
        selectedLevelFileIndex = -1;
        levelAssignmentScrollOffset = 0f;

        // Find current level file in the list
        if (node.getLevelFileName() != null) {
            for (int i = 0; i < availableLevelFiles.size; i++) {
                if (availableLevelFiles.get(i).equals(node.getLevelFileName())) {
                    selectedLevelFileIndex = i;
                    break;
                }
            }
        }

        updateLevelFileButtons();
        Gdx.app.log("WorldMap", "Opened level assignment dialog for: " + node.getLevelName());
    }

    // NEW: Handle input for level assignment dialog
    private void handleLevelAssignmentDialogInput(OrthographicCamera camera) {
        Vector3 screenPos = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0);
        // Don't unproject for UI elements - use screen coordinates

        boolean mouseJustPressed = Gdx.input.isButtonJustPressed(Input.Buttons.LEFT);

        if (mouseJustPressed) {
            // Check if clicking outside dialog to close
            if (!levelAssignmentDialogBounds.contains(screenPos.x, Gdx.graphics.getHeight() - screenPos.y)) {
                showLevelAssignmentDialog = false;
                return;
            }

            // Check level file buttons
            for (int i = 0; i < levelFileButtons.size; i++) {
                Rectangle button = levelFileButtons.get(i);
                if (button.contains(screenPos.x, Gdx.graphics.getHeight() - screenPos.y)) {
                    int startIndex = (int)(levelAssignmentScrollOffset / LEVEL_ASSIGNMENT_ITEM_HEIGHT);
                    selectedLevelFileIndex = startIndex + i;
                    Gdx.app.log("WorldMap", "Selected level file: " + availableLevelFiles.get(selectedLevelFileIndex));
                    break;
                }
            }

            // Check confirm button
            if (confirmAssignmentButton.contains(screenPos.x, Gdx.graphics.getHeight() - screenPos.y)) {
                confirmLevelAssignment();
            }

            // Check cancel button
            if (cancelAssignmentButton.contains(screenPos.x, Gdx.graphics.getHeight() - screenPos.y)) {
                showLevelAssignmentDialog = false;
            }
        }

        // Handle scrolling
        int scrollAmount = Gdx.input.getDeltaY();
        if (scrollAmount != 0) {
            levelAssignmentScrollOffset += scrollAmount * 20f;
            levelAssignmentScrollOffset = Math.max(0f, levelAssignmentScrollOffset);
            float maxScroll = Math.max(0f, availableLevelFiles.size * LEVEL_ASSIGNMENT_ITEM_HEIGHT - (LEVEL_ASSIGNMENT_DIALOG_HEIGHT - 120f));
            levelAssignmentScrollOffset = Math.min(maxScroll, levelAssignmentScrollOffset);
            updateLevelFileButtons();
        }

        // ESC to close dialog
        if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
            showLevelAssignmentDialog = false;
        }
    }

    // NEW: Confirm level assignment
    // NEW: Complete confirmLevelAssignment() method for WorldMap.java
// Replace the existing method with this implementation

    private void confirmLevelAssignment() {
        if (nodeForLevelAssignment == null || selectedLevelFileIndex < 0 || selectedLevelFileIndex >= availableLevelFiles.size) {
            return;
        }

        String selectedFile = availableLevelFiles.get(selectedLevelFileIndex);

        if ("[No Level Assigned]".equals(selectedFile)) {
            nodeForLevelAssignment.setLevelFileName(null);
            Gdx.app.log("WorldMap", "Removed level assignment from: " + nodeForLevelAssignment.getLevelName());
        } else if ("[Create New Level]".equals(selectedFile)) {
            // FULLY IMPLEMENTED: Create new level file and optionally open in editor
            String newFileName = createNewLevelFile(nodeForLevelAssignment);
            if (newFileName != null) {
                nodeForLevelAssignment.setLevelFileName(newFileName);
                Gdx.app.log("WorldMap", "Created and assigned new level file: " + newFileName);

                // Refresh the available level files list to include the new file
                refreshAvailableLevelFiles();

                // Optionally trigger level editor if in debug mode
                if (debugMode) {
                    Gdx.app.log("WorldMap", "New level created. You can edit it using F1 (Level Editor)");
                    // Note: We could add a flag here to automatically switch to level editor
                    // but for now we'll let the user manually switch
                }
            } else {
                Gdx.app.error("WorldMap", "Failed to create new level file");
                return; // Don't close dialog if creation failed
            }
        } else {
            nodeForLevelAssignment.setLevelFileName(selectedFile);
            Gdx.app.log("WorldMap", "Assigned level file '" + selectedFile + "' to node: " + nodeForLevelAssignment.getLevelName());
        }

        // Update configuration
        updateConfigFromNodes();
        config.saveToFile();

        showLevelAssignmentDialog = false;
    }

    // NEW: Method to create a new level file based on node properties
    private String createNewLevelFile(WorldMapNode node) {
        try {
            // Generate appropriate file name
            String baseName = node.getLevelName().toLowerCase()
                .replace(" ", "_")
                .replace("-", "_")
                .replaceAll("[^a-z0-9_]", ""); // Remove any other special characters
            String fileName = baseName + ".json";

            // Ensure levels directory exists
            FileHandle levelsDir = Gdx.files.local("levels/");
            if (!levelsDir.exists()) {
                levelsDir.mkdirs();
            }

            // Check if file already exists and generate unique name if needed
            FileHandle levelFile = Gdx.files.local("levels/" + fileName);
            int counter = 1;
            while (levelFile.exists()) {
                fileName = baseName + "_" + counter + ".json";
                levelFile = Gdx.files.local("levels/" + fileName);
                counter++;
            }

            // Create level based on node type and world
            Level newLevel = createLevelForNode(node);
            newLevel.setName(node.getLevelName());

            // Set appropriate background based on world number
            setLevelBackground(newLevel, node.getWorldNumber());

            // Set player start position
            newLevel.setPlayerStartX(150f);
            newLevel.setPlayerStartY(Platform.GROUND_TILE_SIZE * 2);

            // Set appropriate music based on world and node type
            setLevelMusic(newLevel, node.getWorldNumber(), node.getType());

            // Save the level
            Json json = new Json();
            levelFile.writeString(json.prettyPrint(newLevel), false);

            Gdx.app.log("WorldMap", "Successfully created new level file: " + fileName);
            return fileName;

        } catch (Exception e) {
            Gdx.app.error("WorldMap", "Failed to create new level file", e);
            return null;
        }
    }

    // NEW: Create level content based on node properties
    private Level createLevelForNode(WorldMapNode node) {
        Level level = new Level(node.getLevelName());

        // Add basic ground platform
        Level.PlatformData ground = new Level.PlatformData(
            0, 0, 32f * 25, 32f * 2, Platform.PlatformType.GROUND
        );
        level.addPlatform(ground);

        // Add content based on node type and world
        switch (node.getType()) {
            case LEVEL:
                createStandardLevel(level, node.getWorldNumber(), node.getLevelNumber());
                break;
            case CASTLE:
                createCastleLevel(level, node.getWorldNumber());
                break;
            case FORTRESS:
                createFortressLevel(level, node.getWorldNumber());
                break;
            case GHOST_HOUSE:
                createGhostHouseLevel(level, node.getWorldNumber());
                break;
            case SPECIAL:
                createSpecialLevel(level, node.getWorldNumber());
                break;
        }

        // Always add a goal post at the end
        level.setGoalPost(32f * 23, 32f * 2);

        return level;
    }

    private void createStandardLevel(Level level, int world, int levelNum) {
        // Base difficulty on world number
        float difficulty = world * 0.5f + levelNum * 0.3f;

        // Add platforms with increasing complexity
        level.addPlatform(new Level.PlatformData(200, 96, 32, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(300, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(450, 96, 64, 32, Platform.PlatformType.GRAVEL_BLOCK));

        if (world >= 2) {
            level.addPlatform(new Level.PlatformData(600, 160, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
            level.addPlatform(new Level.PlatformData(700, 128, 96, 32, Platform.PlatformType.GRAVEL_BLOCK));
        }

        // Add enemies based on world
        if (world == 1) {
            level.addEnemy(new Level.EnemyData(250, 64, "GOOMBA"));
            level.addEnemy(new Level.EnemyData(500, 128, "GOOMBA"));
        } else {
            level.addEnemy(new Level.EnemyData(250, 64, "GOOMBA"));
            level.addEnemy(new Level.EnemyData(400, 64, "KOOPA"));
            level.addEnemy(new Level.EnemyData(750, 160, "GOOMBA"));
        }

        // Add powerups
        level.addPowerup(new Level.PowerupData(300, 160, world == 1 ? "MUSHROOM" : "FIRE_FLOWER"));
        if (world >= 3) {
            level.addPowerup(new Level.PowerupData(600, 192, "STAR"));
        }
    }

    private void createCastleLevel(Level level, int world) {
        // Castle levels are more challenging
        level.addPlatform(new Level.PlatformData(200, 96, 128, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(400, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(500, 160, 96, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(650, 96, 64, 64, Platform.PlatformType.GRAVEL_BLOCK));

        // More enemies for castle
        level.addEnemy(new Level.EnemyData(250, 128, "KOOPA"));
        level.addEnemy(new Level.EnemyData(350, 128, "KOOPA"));
        level.addEnemy(new Level.EnemyData(550, 192, "GOOMBA"));
        level.addEnemy(new Level.EnemyData(680, 160, "KOOPA"));

        // Better powerups for castle
        level.addPowerup(new Level.PowerupData(400, 160, "FIRE_FLOWER"));
        level.addPowerup(new Level.PowerupData(232, 160, "STAR"));
    }

    private void createFortressLevel(Level level, int world) {
        // Similar to castle but different layout
        level.addPlatform(new Level.PlatformData(150, 128, 64, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(300, 160, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(400, 96, 32, 96, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(550, 128, 128, 32, Platform.PlatformType.GRAVEL_BLOCK));

        level.addEnemy(new Level.EnemyData(180, 160, "GOOMBA"));
        level.addEnemy(new Level.EnemyData(430, 128, "KOOPA"));
        level.addEnemy(new Level.EnemyData(600, 160, "KOOPA"));

        level.addPowerup(new Level.PowerupData(300, 192, "MUSHROOM"));
    }

    private void createGhostHouseLevel(Level level, int world) {
        // Spooky level with floating platforms
        level.addPlatform(new Level.PlatformData(180, 160, 64, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(320, 200, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(450, 140, 96, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(600, 180, 64, 32, Platform.PlatformType.GRAVEL_BLOCK));

        level.addEnemy(new Level.EnemyData(210, 192, "GOOMBA"));
        level.addEnemy(new Level.EnemyData(480, 172, "KOOPA"));
        level.addEnemy(new Level.EnemyData(630, 212, "GOOMBA"));

        level.addPowerup(new Level.PowerupData(320, 232, "STAR"));
    }

    private void createSpecialLevel(Level level, int world) {
        // Bonus/special level with lots of powerups
        level.addPlatform(new Level.PlatformData(150, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(250, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(350, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(450, 160, 64, 32, Platform.PlatformType.GRAVEL_BLOCK));
        level.addPlatform(new Level.PlatformData(550, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));
        level.addPlatform(new Level.PlatformData(650, 128, 32, 32, Platform.PlatformType.QUESTION_BLOCK));

        // Fewer enemies, more powerups
        level.addEnemy(new Level.EnemyData(480, 192, "GOOMBA"));

        level.addPowerup(new Level.PowerupData(200, 96, "CHICKEN"));
        level.addPowerup(new Level.PowerupData(300, 96, "STAR"));
        level.addPowerup(new Level.PowerupData(400, 96, "FIRE_FLOWER"));
        level.addPowerup(new Level.PowerupData(500, 96, "MUSHROOM"));
    }

    private void setLevelBackground(Level level, int world) {
        switch (world) {
            case 1:
                level.setBackgroundTexturePath("mario_sprites/backgrounds/background_0.png"); // Sky/grass
                break;
            case 2:
                level.setBackgroundTexturePath("mario_sprites/backgrounds/background_1.png"); // Desert/hills
                break;
            case 3:
                level.setBackgroundTexturePath("mario_sprites/backgrounds/background_2.png"); // Water/night
                break;
            case 4:
                level.setBackgroundTexturePath("mario_sprites/backgrounds/background_2.png"); // Ice/night
                break;
            default:
                level.setBackgroundTexturePath("mario_sprites/backgrounds/background_0.png");
                break;
        }
    }

    private void setLevelMusic(Level level, int world, WorldMapNode.NodeType nodeType) {
        // Set music based on world and node type
        String musicPath = "music/level1.mp3"; // Default
        float volume = 0.5f;

        switch (nodeType) {
            case CASTLE:
            case FORTRESS:
                musicPath = "music/castle.mp3";
                volume = 0.6f;
                break;
            case GHOST_HOUSE:
                musicPath = "music/ghost_house.mp3";
                volume = 0.4f;
                break;
            case SPECIAL:
                musicPath = "music/bonus.mp3";
                volume = 0.7f;
                break;
            default:
                musicPath = "music/level" + world + ".mp3";
                break;
        }

        level.setBackgroundMusic(musicPath);
        level.setMusicVolume(volume);
    }

    private void updateConfigFromNodes() {
        // Update the configuration with current node positions and level assignments
        config.nodes.clear();

        for (WorldMapNode node : nodes) {
            WorldMapConfig.NodeConfig nodeConfig = new WorldMapConfig.NodeConfig(
                node.getPosition().x, node.getPosition().y,
                node.getLevelFileName() != null ? node.getLevelFileName() : "",
                node.getLevelName(),
                node.getType().toString(),
                node.getWorldNumber(),
                node.getLevelNumber(),
                node.getState() == WorldMapNode.NodeState.UNLOCKED || node.getState() == WorldMapNode.NodeState.COMPLETED
            );
            config.addNode(nodeConfig);
        }

        // Recreate paths with new positions
        createPathsFromConfig();
    }

    private void moveToNode(WorldMapNode target) {
        if (currentSelectedNode != null) {
            currentSelectedNode.setSelected(false);
        }

        currentSelectedNode = target;
        target.setSelected(true);
        targetPosition = target.getPosition().cpy();
        isMovingToTarget = true;

        // Play movement sound
        SoundManager.getInstance().playJump(); // Reuse jump sound for map movement
    }

    private void updatePlayerMovement(float deltaTime) {
        if (isMovingToTarget) {
            Vector2 direction = targetPosition.cpy().sub(playerPosition).nor();
            float distance = playerPosition.dst(targetPosition);

            if (distance < 5f) {
                // Reached target
                playerPosition.set(targetPosition);
                playerNode = currentSelectedNode;
                isMovingToTarget = false;
            } else {
                // Move towards target
                playerPosition.add(direction.scl(moveSpeed * deltaTime));
            }
        }
    }

    private void enterLevel(WorldMapNode node) {
        Gdx.app.log("WorldMap", "Entering level: " + node.getLevelName());

        // Set the level selection mode with the level file name
        levelSelectionMode = true;

        // Play enter sound
        SoundManager.getInstance().playDoor();
    }

    public void render(SpriteBatch batch, OrthographicCamera camera) {
        // If in edit mode, call the special update method with camera
        if (debugMode && editMode) {
            float deltaTime = Gdx.graphics.getDeltaTime();
            updateEditMode(deltaTime, camera);
        }

        // Center camera on player with bounds from config
        if (!editMode) {
            camera.position.x = MathUtils.clamp(playerPosition.x, config.cameraMinX,
                Math.max(config.cameraMinX, config.mapWidth - config.cameraMinX));
            camera.position.y = MathUtils.clamp(playerPosition.y, config.cameraMinY,
                Math.max(config.cameraMinY, config.mapHeight - config.cameraMinY));
        } else {
            // In edit mode, allow free camera movement with mouse wheel or keys
            handleEditModeCameraMovement(camera);
        }
        camera.update();

        batch.setProjectionMatrix(camera.combined);
        batch.begin();

        // Draw world map background
        if (worldMapTexture != null) {
            batch.draw(worldMapTexture, 0, 0, config.mapWidth, config.mapHeight);
        }

        batch.end();

        // Draw paths
        renderPaths(camera);

        batch.begin();

        // Draw nodes
        for (WorldMapNode node : nodes) {
            node.render(batch);
        }

        // Highlight selected node for editing
        if (editMode && selectedNodeForEdit != null) {
            renderEditModeHighlight(batch, selectedNodeForEdit);
        }

        // Draw player icon (only when not in edit mode)
        if (!editMode) {
            renderPlayer(batch);
        }
        if (debugMode && editMode) {
            renderEditModeUI(batch, camera);
        }
        batch.end();

        // Draw UI
        renderUI(batch, camera);

        // NEW: Draw level assignment dialog
        if (showLevelAssignmentDialog) {
            renderLevelAssignmentDialog(batch);
        }
    }
// ADDITIONAL METHODS for WorldMap.java - Add these to the existing WorldMap class


    // FIXED: Get the currently selected node
    public WorldMapNode getCurrentSelectedNode() {
        return currentSelectedNode;
    }

    private void handleEditModeCameraMovement(OrthographicCamera camera) {
        float cameraSpeed = 300f * Gdx.graphics.getDeltaTime();

        // WASD camera movement in edit mode
        if (Gdx.input.isKeyPressed(Input.Keys.W)) {
            camera.position.y += cameraSpeed;
        }
        if (Gdx.input.isKeyPressed(Input.Keys.S)) {
            camera.position.y -= cameraSpeed;
        }
        if (Gdx.input.isKeyPressed(Input.Keys.A)) {
            camera.position.x -= cameraSpeed;
        }
        if (Gdx.input.isKeyPressed(Input.Keys.D)) {
            camera.position.x += cameraSpeed;
        }

        // Clamp camera to map bounds
        camera.position.x = MathUtils.clamp(camera.position.x, camera.viewportWidth/2,
            config.mapWidth - camera.viewportWidth/2);
        camera.position.y = MathUtils.clamp(camera.position.y, camera.viewportHeight/2,
            config.mapHeight - camera.viewportHeight/2);
    }

    private void renderEditModeHighlight(SpriteBatch batch, WorldMapNode node) {
        // Draw a bright cyan outline around the selected node
        float nodeSize = (node.getType() == WorldMapNode.NodeType.CASTLE) ?
            WorldMapNode.CASTLE_SIZE : WorldMapNode.NODE_SIZE;
        float highlightSize = nodeSize * 1.4f;

        Vector2 pos = node.getPosition();
        float highlightX = pos.x - highlightSize / 2;
        float highlightY = pos.y - highlightSize / 2;

        // Pulsing cyan highlight
        float pulse = 0.7f + 0.3f * (float)Math.sin(animationTimer * 8.0f);
        batch.setColor(0f, 1f, 1f, pulse); // Cyan

        // Draw the node texture again but larger as highlight
        Texture nodeTexture = getNodeTextureForType(node.getType());
        if (nodeTexture != null) {
            batch.draw(nodeTexture, highlightX, highlightY, highlightSize, highlightSize);
        }

        batch.setColor(Color.WHITE);
    }

    private Texture getNodeTextureForType(WorldMapNode.NodeType type) {
        switch (type) {
            case LEVEL:
                return WorldMapNode.getLevelNodeTexture();
            case CASTLE:
                return WorldMapNode.getCastleNodeTexture();
            case FORTRESS:
                return WorldMapNode.getFortressNodeTexture();
            case GHOST_HOUSE:
                return WorldMapNode.getSpookyNodeTexture();
            case SPECIAL:
                return WorldMapNode.getSpecialNodeTexture();
            default:
                return WorldMapNode.getLevelNodeTexture();
        }
    }

    private void renderPaths(OrthographicCamera camera) {
        shapeRenderer.setProjectionMatrix(camera.combined);

        // Draw path backgrounds (thicker, darker lines)
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        Gdx.gl.glLineWidth(8f);
        shapeRenderer.setColor(0.4f, 0.2f, 0.1f, 0.8f); // Dark brown

        for (Array<Vector2> path : paths) {
            for (int i = 0; i < path.size - 1; i++) {
                Vector2 point1 = path.get(i);
                Vector2 point2 = path.get(i + 1);
                shapeRenderer.line(point1.x, point1.y, point2.x, point2.y);
            }
        }
        shapeRenderer.end();

        // Draw path foregrounds (thinner, lighter lines)
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        Gdx.gl.glLineWidth(4f);
        shapeRenderer.setColor(0.8f, 0.6f, 0.3f, 1.0f); // Light brown/tan

        for (Array<Vector2> path : paths) {
            for (int i = 0; i < path.size - 1; i++) {
                Vector2 point1 = path.get(i);
                Vector2 point2 = path.get(i + 1);
                shapeRenderer.line(point1.x, point1.y, point2.x, point2.y);
            }
        }
        shapeRenderer.end();

        // In edit mode, show path connection points
        if (editMode) {
            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
            shapeRenderer.setColor(Color.YELLOW);

            for (Array<Vector2> path : paths) {
                for (Vector2 point : path) {
                    shapeRenderer.circle(point.x, point.y, 3f);
                }
            }
            shapeRenderer.end();
        }

        Gdx.gl.glLineWidth(1f); // Reset line width
    }

    private void renderPlayer(SpriteBatch batch) {
        float playerSize = 32f;
        float bounceOffset = 3f * (float)Math.sin(animationTimer * 4f);

        if (playerIconTexture != null) {
            batch.draw(playerIconTexture,
                playerPosition.x - playerSize/2,
                playerPosition.y - playerSize/2 + bounceOffset,
                playerSize, playerSize);
        } else {
            // Fallback: render simple colored rectangle using ShapeRenderer
            batch.end();
            shapeRenderer.setProjectionMatrix(batch.getProjectionMatrix());
            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
            shapeRenderer.setColor(Color.BLUE);
            shapeRenderer.rect(playerPosition.x - playerSize/2,
                playerPosition.y - playerSize/2 + bounceOffset,
                playerSize, playerSize);
            shapeRenderer.end();
            batch.begin();
        }
    }



    // ENHANCED: Much better level assignment dialog rendering with proper scaling
    private void renderLevelAssignmentDialog(SpriteBatch batch) {
        // Get current screen dimensions
        float screenWidth = Gdx.graphics.getWidth();
        float screenHeight = Gdx.graphics.getHeight();

        // Scale factor for better visibility
        float scaleFactor = Math.min(screenWidth / 1920f, screenHeight / 1080f);
        scaleFactor = Math.max(scaleFactor, 0.8f);

        // Switch to screen coordinates
        batch.getProjectionMatrix().setToOrtho2D(0, 0, screenWidth, screenHeight);

        // Draw semi-transparent overlay
        shapeRenderer.getProjectionMatrix().setToOrtho2D(0, 0, screenWidth, screenHeight);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0, 0, 0, 0.7f);
        shapeRenderer.rect(0, 0, screenWidth, screenHeight);
        shapeRenderer.end();

        // ENHANCED: Much more visible dialog background
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0.15f, 0.15f, 0.2f, 0.98f); // Darker, more opaque background
        shapeRenderer.rect(levelAssignmentDialogBounds.x, levelAssignmentDialogBounds.y,
            levelAssignmentDialogBounds.width, levelAssignmentDialogBounds.height);
        shapeRenderer.end();

        // ENHANCED: Thicker, more visible border
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(Color.CYAN);
        Gdx.gl.glLineWidth(4f * scaleFactor);
        shapeRenderer.rect(levelAssignmentDialogBounds.x, levelAssignmentDialogBounds.y,
            levelAssignmentDialogBounds.width, levelAssignmentDialogBounds.height);
        shapeRenderer.end();

        // ENHANCED: Draw header section
        float headerHeight = 60f * scaleFactor;
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0.2f, 0.3f, 0.5f, 1.0f); // Blue header
        shapeRenderer.rect(levelAssignmentDialogBounds.x,
            levelAssignmentDialogBounds.y + levelAssignmentDialogBounds.height - headerHeight,
            levelAssignmentDialogBounds.width, headerHeight);
        shapeRenderer.end();

        // Update and draw level file buttons with better visibility
        updateLevelFileButtons();
        for (int i = 0; i < levelFileButtons.size; i++) {
            Rectangle button = levelFileButtons.get(i);
            int startIndex = (int)(levelAssignmentScrollOffset / LEVEL_ASSIGNMENT_ITEM_HEIGHT);
            int fileIndex = startIndex + i;

            if (fileIndex >= availableLevelFiles.size) continue;

            // ENHANCED: Much more visible button backgrounds
            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
            if (fileIndex == selectedLevelFileIndex) {
                shapeRenderer.setColor(0.3f, 0.7f, 1f, 0.9f); // Bright blue for selected
            } else if (fileIndex % 2 == 0) {
                shapeRenderer.setColor(0.25f, 0.25f, 0.3f, 0.8f); // Alternating colors
            } else {
                shapeRenderer.setColor(0.2f, 0.2f, 0.25f, 0.8f);
            }
            shapeRenderer.rect(button.x, button.y, button.width, button.height);
            shapeRenderer.end();

            // Button border for better visibility
            shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
            shapeRenderer.setColor(fileIndex == selectedLevelFileIndex ? Color.WHITE : Color.GRAY);
            Gdx.gl.glLineWidth(1f);
            shapeRenderer.rect(button.x, button.y, button.width, button.height);
            shapeRenderer.end();
        }

        // ENHANCED: More visible confirm/cancel buttons
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0.2f, 0.8f, 0.2f, 0.9f); // Bright green for confirm
        shapeRenderer.rect(confirmAssignmentButton.x, confirmAssignmentButton.y,
            confirmAssignmentButton.width, confirmAssignmentButton.height);
        shapeRenderer.setColor(0.8f, 0.2f, 0.2f, 0.9f); // Bright red for cancel
        shapeRenderer.rect(cancelAssignmentButton.x, cancelAssignmentButton.y,
            cancelAssignmentButton.width, cancelAssignmentButton.height);
        shapeRenderer.end();

        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(Color.WHITE);
        Gdx.gl.glLineWidth(2f);
        shapeRenderer.rect(confirmAssignmentButton.x, confirmAssignmentButton.y,
            confirmAssignmentButton.width, confirmAssignmentButton.height);
        shapeRenderer.rect(cancelAssignmentButton.x, cancelAssignmentButton.y,
            cancelAssignmentButton.width, cancelAssignmentButton.height);
        shapeRenderer.end();

        Gdx.gl.glLineWidth(1f);

        // ENHANCED: Much better text rendering with scaling
        batch.begin();

        // Scale fonts for better visibility
        float fontScale = scaleFactor * 1.2f;
        float smallFontScale = scaleFactor;

        font.getData().setScale(fontScale);
        smallFont.getData().setScale(smallFontScale);

        // ENHANCED: More prominent dialog title
        font.setColor(Color.WHITE);
        String title = "ASSIGN LEVEL FILE";
        font.draw(batch, title, levelAssignmentDialogBounds.x + 20f * scaleFactor,
            levelAssignmentDialogBounds.y + levelAssignmentDialogBounds.height - 20f * scaleFactor);

        // Node information
        if (nodeForLevelAssignment != null) {
            smallFont.setColor(Color.YELLOW);
            String nodeInfo = "Node: " + nodeForLevelAssignment.getLevelName();
            smallFont.draw(batch, nodeInfo, levelAssignmentDialogBounds.x + 20f * scaleFactor,
                levelAssignmentDialogBounds.y + levelAssignmentDialogBounds.height - 45f * scaleFactor);

            // Current assignment with better visibility
            if (nodeForLevelAssignment.getLevelFileName() != null) {
                smallFont.setColor(Color.LIGHT_GRAY);
                String currentFile = "Current: " + nodeForLevelAssignment.getLevelFileName();
                smallFont.draw(batch, currentFile, levelAssignmentDialogBounds.x + 20f * scaleFactor,
                    levelAssignmentDialogBounds.y + levelAssignmentDialogBounds.height - 70f * scaleFactor);
            }
        }

        // ENHANCED: Much more visible level file list
        for (int i = 0; i < levelFileButtons.size; i++) {
            Rectangle button = levelFileButtons.get(i);
            int startIndex = (int)(levelAssignmentScrollOffset / LEVEL_ASSIGNMENT_ITEM_HEIGHT);
            int fileIndex = startIndex + i;

            if (fileIndex >= availableLevelFiles.size) continue;

            String fileName = availableLevelFiles.get(fileIndex);

            // ENHANCED: High contrast text colors
            if (fileIndex == selectedLevelFileIndex) {
                smallFont.setColor(Color.BLACK); // Black text on blue background
            } else {
                smallFont.setColor(Color.WHITE); // White text on dark background
            }

            // Add file type indicators
            String displayText = fileName;
            if (fileName.equals("[Create New Level]")) {
                displayText = "★ " + fileName;
                smallFont.setColor(Color.GREEN);
            } else if (fileName.equals("[No Level Assigned]")) {
                displayText = "✗ " + fileName;
                smallFont.setColor(Color.RED);
            } else if (fileName.endsWith(".json")) {
                displayText = "📄 " + fileName;
            }

            smallFont.draw(batch, displayText,
                button.x + 10f * scaleFactor,
                button.y + button.height - 8f * scaleFactor);
        }

        // ENHANCED: Better button labels
        font.setColor(Color.WHITE);
        font.draw(batch, "CONFIRM",
            confirmAssignmentButton.x + confirmAssignmentButton.width/2f - 35f * scaleFactor,
            confirmAssignmentButton.y + confirmAssignmentButton.height/2f + 5f * scaleFactor);
        font.draw(batch, "CANCEL",
            cancelAssignmentButton.x + cancelAssignmentButton.width/2f - 30f * scaleFactor,
            cancelAssignmentButton.y + cancelAssignmentButton.height/2f + 5f * scaleFactor);

        // ENHANCED: Better instructions
        smallFont.setColor(Color.LIGHT_GRAY);
        String instructions = "Click to select • Scroll to see more • ESC to cancel";
        smallFont.draw(batch, instructions,
            levelAssignmentDialogBounds.x + 20f * scaleFactor,
            levelAssignmentDialogBounds.y + 80f * scaleFactor);

        // Show total files found
        String totalFiles = availableLevelFiles.size + " files found";
        smallFont.draw(batch, totalFiles,
            levelAssignmentDialogBounds.x + 20f * scaleFactor,
            levelAssignmentDialogBounds.y + 60f * scaleFactor);

        // Reset font scales
        font.getData().setScale(1.2f);
        smallFont.getData().setScale(0.8f);

        batch.end();
    }

    private void renderUI(SpriteBatch batch, OrthographicCamera camera) {
        // Set up UI projection
        batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        batch.begin();

        font.setColor(Color.WHITE);

        // Draw current level info (only when not in edit mode)
        if (!editMode && currentSelectedNode != null) {
            String levelInfo = currentSelectedNode.getLevelName();
            String stateInfo = "State: " + currentSelectedNode.getState().toString();

            font.draw(batch, levelInfo, 20, Gdx.graphics.getHeight() - 20);
            font.draw(batch, stateInfo, 20, Gdx.graphics.getHeight() - 50);

            // Show level file name if available
            if (currentSelectedNode.getLevelFileName() != null) {
                font.setColor(Color.LIGHT_GRAY);
                font.draw(batch, "File: " + currentSelectedNode.getLevelFileName(), 20, Gdx.graphics.getHeight() - 80);
                font.setColor(Color.WHITE);
            }
        }

        // Edit mode info
        if (editMode) {
            font.setColor(Color.CYAN);
            font.draw(batch, "WORLD MAP EDIT MODE", 20, Gdx.graphics.getHeight() - 20);
            font.setColor(Color.WHITE);

            if (selectedNodeForEdit != null) {
                font.setColor(Color.YELLOW);
                font.draw(batch, "Selected: " + selectedNodeForEdit.getLevelName(), 20, Gdx.graphics.getHeight() - 50);
                font.draw(batch, "Position: (" + (int)selectedNodeForEdit.getPosition().x +
                    ", " + (int)selectedNodeForEdit.getPosition().y + ")", 20, Gdx.graphics.getHeight() - 80);

                // Show level assignment
                if (selectedNodeForEdit.getLevelFileName() != null) {
                    smallFont.setColor(Color.LIGHT_GRAY);
                    smallFont.draw(batch, "Level File: " + selectedNodeForEdit.getLevelFileName(),
                        20, Gdx.graphics.getHeight() - 110);
                }
                font.setColor(Color.WHITE);
            }

            // Node creation mode indicator
            if (nodeCreationMode) {
                font.setColor(Color.GREEN);
                font.draw(batch, "NODE CREATION MODE - " + selectedNodeType.toString(),
                    20, Gdx.graphics.getHeight() - 140);
                font.setColor(Color.WHITE);
            }

            // Edit mode instructions
            String[] editInstructions = {
                "Click and drag nodes to reposition them",
                "Right-click node to assign level file",
                "WASD: Move camera",
                "C: Toggle node creation mode",
                "1-5: Select node type (in creation mode)",
                "DEL: Delete selected node",
                "R: Refresh level file list",
                "F2: Exit Edit Mode",
                "F3: Save Configuration",
                "ESC: Exit Edit Mode"
            };

            for (int i = 0; i < editInstructions.length; i++) {
                smallFont.draw(batch, editInstructions[i], 20, 250 - (i * 20));
            }
        } else {
            // Normal mode controls
            String[] controls;
            if (debugMode) {
                controls = new String[]{
                    "Arrow Keys: Navigate",
                    "Enter/Space: Enter Level",
                    "I: Toggle Info",
                    "F1: Level Editor",
                    "F2: Edit World Map"
                };
            } else {
                controls = new String[]{
                    "Arrow Keys: Navigate",
                    "Enter/Space: Enter Level",
                    "I: Toggle Info"
                };
            }

            for (int i = 0; i < controls.length; i++) {
                font.draw(batch, controls[i], 20, 150 - (i * 25));
            }
        }

        // Draw additional level info if enabled (and not in edit mode)
        if (!editMode && showLevelInfo && currentSelectedNode != null) {
            String worldInfo = "World " + currentSelectedNode.getWorldNumber() +
                "-" + currentSelectedNode.getLevelNumber();
            String typeInfo = "Type: " + currentSelectedNode.getType().toString();

            font.draw(batch, worldInfo, 20, Gdx.graphics.getHeight() - 110);
            font.draw(batch, typeInfo, 20, Gdx.graphics.getHeight() - 140);
        }

        // Debug info
        if (debugMode) {
            font.setColor(Color.YELLOW);
            font.draw(batch, "DEBUG MODE", Gdx.graphics.getWidth() - 150, Gdx.graphics.getHeight() - 20);
            if (editMode) {
                font.setColor(Color.CYAN);
                font.draw(batch, "EDIT MODE", Gdx.graphics.getWidth() - 150, Gdx.graphics.getHeight() - 50);

                // Show mouse world coordinates
                Vector3 screenPos = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0);
                camera.unproject(screenPos);
                font.draw(batch, "Mouse: (" + (int)screenPos.x + ", " + (int)screenPos.y + ")",
                    Gdx.graphics.getWidth() - 200, Gdx.graphics.getHeight() - 80);
            }
            font.setColor(Color.WHITE);
        }

        // Configuration status
        if (debugMode) {
            font.setColor(Color.LIGHT_GRAY);
            font.draw(batch, "Nodes: " + nodes.size + " | Paths: " + paths.size + " | Levels: " + availableLevelFiles.size,
                Gdx.graphics.getWidth() - 300, 30);
            font.setColor(Color.WHITE);
        }

        batch.end();
    }



    private void saveProgress() {
        try {
            // Update progress object with current node states
            progress.completedLevels.clear();
            progress.unlockedLevels.clear();

            for (WorldMapNode node : nodes) {
                String nodeId = node.getWorldNumber() + "-" + node.getLevelNumber();
                if (node.getState() == WorldMapNode.NodeState.COMPLETED) {
                    progress.completedLevels.add(nodeId);
                    progress.unlockedLevels.add(nodeId); // Completed nodes are also unlocked
                } else if (node.getState() == WorldMapNode.NodeState.UNLOCKED) {
                    progress.unlockedLevels.add(nodeId);
                }
            }

            Json json = new Json();
            FileHandle file = Gdx.files.local("worldmap_progress.json");
            file.writeString(json.prettyPrint(progress), false);
            Gdx.app.log("WorldMap", "Progress saved");
        } catch (Exception e) {
            Gdx.app.error("WorldMap", "Failed to save progress", e);
        }
    }

    private void loadProgress() {
        try {
            FileHandle file = Gdx.files.local("worldmap_progress.json");
            if (file.exists()) {
                Json json = new Json();
                progress = json.fromJson(WorldMapProgress.class, file.readString());
                Gdx.app.log("WorldMap", "Progress loaded");
            }
        } catch (Exception e) {
            Gdx.app.log("WorldMap", "No existing progress found, starting fresh");
            progress = new WorldMapProgress();
        }
    }

    private void applyProgress() {
        // Apply saved progress to nodes
        for (WorldMapNode node : nodes) {
            String nodeId = node.getWorldNumber() + "-" + node.getLevelNumber();
            if (progress.completedLevels.contains(nodeId, false)) {
                node.complete();
            } else if (progress.unlockedLevels.contains(nodeId, false)) {
                node.unlock();
            }
        }
    }

    // Getters
    public String getCurrentLevelName() {
        return currentSelectedNode != null ? currentSelectedNode.getLevelName() : null;
    }

    public String getCurrentLevelFileName() {
        return currentSelectedNode != null ? currentSelectedNode.getLevelFileName() : null;
    }

    public boolean isLevelSelectionMode() {
        return levelSelectionMode;
    }

    public void setLevelSelectionMode(boolean mode) {
        this.levelSelectionMode = mode;
    }

    public WorldMapConfig getConfig() {
        return config;
    }

    public Array<WorldMapNode> getNodes() {
        return nodes;
    }

    private float getMapWidth() {
        return config.mapWidth;
    }

    private float getMapHeight() {
        return config.mapHeight;
    }

    public void dispose() {
        if (worldMapTexture != null) worldMapTexture.dispose();
        if (playerIconTexture != null) playerIconTexture.dispose();
        if (font != null) font.dispose();
        if (smallFont != null) smallFont.dispose(); // NEW
        if (shapeRenderer != null) shapeRenderer.dispose();
        WorldMapNode.disposeStaticTextures();
    }

    // Inner class for progress tracking
    public static class WorldMapProgress {
        public Array<String> completedLevels = new Array<>();
        public Array<String> unlockedLevels = new Array<>();

        public WorldMapProgress() {
            // Start with first level unlocked
            unlockedLevels.add("1-1");
        }
    }
}

================
File: src/main/java/io/github/game/WorldMapConfig.java
================
// File: core/src/main/java/io/github/game/WorldMapConfig.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;

/**
 * Configuration class for world map layout and level assignments.
 * This allows easy editing of world map node positions and level assignments.
 */
public class WorldMapConfig implements Json.Serializable {

    public static class NodeConfig {
        public float x, y; // Position on world map
        public String levelFileName; // JSON file name for this level
        public String displayName; // Display name on world map
        public String nodeType; // LEVEL, CASTLE, FORTRESS, GHOST_HOUSE, SPECIAL
        public int worldNumber;
        public int levelNumber;
        public boolean startsUnlocked; // If this node should be unlocked at start

        // Default constructor for JSON serialization
        public NodeConfig() {}

        public NodeConfig(float x, float y, String levelFileName, String displayName,
                          String nodeType, int worldNumber, int levelNumber, boolean startsUnlocked) {
            this.x = x;
            this.y = y;
            this.levelFileName = levelFileName;
            this.displayName = displayName;
            this.nodeType = nodeType;
            this.worldNumber = worldNumber;
            this.levelNumber = levelNumber;
            this.startsUnlocked = startsUnlocked;
        }
    }

    public static class PathConfig {
        public int fromNodeIndex;
        public int toNodeIndex;
        public Array<PathPoint> intermediatePoints; // For curved paths

        public PathConfig() {
            intermediatePoints = new Array<>();
        }

        public PathConfig(int fromNodeIndex, int toNodeIndex) {
            this.fromNodeIndex = fromNodeIndex;
            this.toNodeIndex = toNodeIndex;
            this.intermediatePoints = new Array<>();
        }
    }

    public static class PathPoint {
        public float x, y;

        public PathPoint() {}

        public PathPoint(float x, float y) {
            this.x = x;
            this.y = y;
        }
    }

    // World map configuration
    public String worldMapTexturePath = "mario_sprites/world_map/worldmap.png";
    public float mapWidth = 800f;
    public float mapHeight = 600f;
    public float playerMoveSpeed = 120f;

    // Node configurations
    public Array<NodeConfig> nodes;

    // Path configurations
    public Array<PathConfig> paths;

    // Camera settings
    public float cameraMinX = 400f; // Half viewport width
    public float cameraMaxX = 400f; // mapWidth - half viewport width
    public float cameraMinY = 240f; // Half viewport height
    public float cameraMaxY = 360f; // mapHeight - half viewport height

    public WorldMapConfig() {
        nodes = new Array<>();
        paths = new Array<>();
        createDefaultConfiguration();
    }

    /**
     * Creates the default world map configuration.
     * FIXED: Use consistent naming convention that matches Main.java
     */
    private void createDefaultConfiguration() {
        // WORLD 1 - Grass World (4 levels + castle) - FIXED naming
        nodes.add(new NodeConfig(120, 180, "level_1_1.json", "Level 1-1", "LEVEL", 1, 1, true)); // Start unlocked
        nodes.add(new NodeConfig(220, 160, "level_1_2.json", "Level 1-2", "LEVEL", 1, 2, false));
        nodes.add(new NodeConfig(320, 200, "level_1_3.json", "Level 1-3", "LEVEL", 1, 3, false));
        nodes.add(new NodeConfig(420, 180, "level_1_4.json", "Level 1-4", "CASTLE", 1, 4, false));

        // WORLD 2 - Desert World (4 levels + castle) - FIXED naming
        nodes.add(new NodeConfig(480, 220, "level_2_1.json", "Level 2-1", "LEVEL", 2, 1, false));
        nodes.add(new NodeConfig(520, 280, "level_2_2.json", "Level 2-2", "LEVEL", 2, 2, false));
        nodes.add(new NodeConfig(560, 240, "level_2_3.json", "Level 2-3", "LEVEL", 2, 3, false));
        nodes.add(new NodeConfig(620, 200, "level_2_4.json", "Level 2-4", "CASTLE", 2, 4, false));

        // WORLD 3 - Water World (4 levels + castle) - FIXED naming
        nodes.add(new NodeConfig(150, 350, "level_3_1.json", "Level 3-1", "LEVEL", 3, 1, false));
        nodes.add(new NodeConfig(250, 370, "level_3_2.json", "Level 3-2", "LEVEL", 3, 2, false));
        nodes.add(new NodeConfig(350, 390, "level_3_3.json", "Level 3-3", "LEVEL", 3, 3, false));
        nodes.add(new NodeConfig(450, 350, "level_3_4.json", "Level 3-4", "CASTLE", 3, 4, false));

        // WORLD 4 - Ice World (4 levels + castle) - FIXED naming
        nodes.add(new NodeConfig(500, 380, "level_4_1.json", "Level 4-1", "LEVEL", 4, 1, false));
        nodes.add(new NodeConfig(600, 400, "level_4_2.json", "Level 4-2", "LEVEL", 4, 2, false));
        nodes.add(new NodeConfig(650, 430, "level_4_3.json", "Level 4-3", "LEVEL", 4, 3, false));
        nodes.add(new NodeConfig(700, 380, "level_4_4.json", "Level 4-4", "CASTLE", 4, 4, false));

        // Special areas - FIXED naming
        nodes.add(new NodeConfig(380, 280, "warp_zone.json", "Warp Zone", "SPECIAL", 0, 0, false));

        // Create paths connecting nodes
        createDefaultPaths();
    }

    private void createDefaultPaths() {
        // World 1 path (linear progression)
        paths.add(new PathConfig(0, 1)); // 1-1 to 1-2
        paths.add(new PathConfig(1, 2)); // 1-2 to 1-3
        paths.add(new PathConfig(2, 3)); // 1-3 to 1-4 (Castle)

        // World 2 path
        paths.add(new PathConfig(3, 4)); // 1-4 to 2-1
        paths.add(new PathConfig(4, 5)); // 2-1 to 2-2
        paths.add(new PathConfig(5, 6)); // 2-2 to 2-3
        paths.add(new PathConfig(6, 7)); // 2-3 to 2-4 (Castle)

        // World 3 path
        paths.add(new PathConfig(7, 8)); // 2-4 to 3-1
        paths.add(new PathConfig(8, 9)); // 3-1 to 3-2
        paths.add(new PathConfig(9, 10)); // 3-2 to 3-3
        paths.add(new PathConfig(10, 11)); // 3-3 to 3-4 (Castle)

        // World 4 path
        paths.add(new PathConfig(11, 12)); // 3-4 to 4-1
        paths.add(new PathConfig(12, 13)); // 4-1 to 4-2
        paths.add(new PathConfig(13, 14)); // 4-2 to 4-3
        paths.add(new PathConfig(14, 15)); // 4-3 to 4-4 (Castle)

        // Special connections
        paths.add(new PathConfig(1, 16)); // 1-2 to Warp Zone
        paths.add(new PathConfig(16, 12)); // Warp Zone to 4-1 (shortcut)
    }

    /**
     * Save the current configuration to a JSON file.
     */
    public void saveToFile() {
        try {
            Json json = new Json();
            FileHandle configDir = Gdx.files.local("config/");
            if (!configDir.exists()) {
                configDir.mkdirs();
            }
            FileHandle file = Gdx.files.local("config/worldmap_config.json");
            file.writeString(json.prettyPrint(this), false);
            Gdx.app.log("WorldMapConfig", "Configuration saved to: " + file.path());
        } catch (Exception e) {
            Gdx.app.error("WorldMapConfig", "Failed to save world map configuration", e);
        }
    }

    /**
     * Load configuration from JSON file, or create default if not found.
     */
    public static WorldMapConfig loadFromFile() {
        try {
            FileHandle file = Gdx.files.local("config/worldmap_config.json");
            if (file.exists()) {
                Json json = new Json();
                WorldMapConfig config = json.fromJson(WorldMapConfig.class, file.readString());
                Gdx.app.log("WorldMapConfig", "Configuration loaded from: " + file.path());
                return config;
            } else {
                Gdx.app.log("WorldMapConfig", "No existing configuration found, creating default");
                WorldMapConfig config = new WorldMapConfig();
                config.saveToFile(); // Save the default configuration
                return config;
            }
        } catch (Exception e) {
            Gdx.app.error("WorldMapConfig", "Failed to load world map configuration, using default", e);
            return new WorldMapConfig();
        }
    }

    /**
     * Get node configuration by world and level number.
     */
    public NodeConfig getNodeConfig(int world, int level) {
        for (NodeConfig node : nodes) {
            if (node.worldNumber == world && node.levelNumber == level) {
                return node;
            }
        }
        return null;
    }

    /**
     * Get all nodes for a specific world.
     */
    public Array<NodeConfig> getNodesForWorld(int world) {
        Array<NodeConfig> worldNodes = new Array<>();
        for (NodeConfig node : nodes) {
            if (node.worldNumber == world) {
                worldNodes.add(node);
            }
        }
        return worldNodes;
    }

    /**
     * Add a new node configuration.
     */
    public void addNode(NodeConfig node) {
        nodes.add(node);
    }

    /**
     * Remove a node configuration.
     */
    public void removeNode(NodeConfig node) {
        nodes.removeValue(node, true);
    }

    /**
     * Add a new path configuration.
     */
    public void addPath(PathConfig path) {
        paths.add(path);
    }

    /**
     * Remove a path configuration.
     */
    public void removePath(PathConfig path) {
        paths.removeValue(path, true);
    }

    /**
     * Validate that all referenced level files exist.
     */
    public Array<String> validateLevelFiles() {
        Array<String> missingFiles = new Array<>();

        for (NodeConfig node : nodes) {
            if (node.levelFileName != null && !node.levelFileName.isEmpty()) {
                FileHandle levelFile = Gdx.files.local("levels/" + node.levelFileName);
                if (!levelFile.exists()) {
                    missingFiles.add(node.levelFileName);
                }
            }
        }

        return missingFiles;
    }

    @Override
    public void write(Json json) {
        json.writeValue("worldMapTexturePath", worldMapTexturePath);
        json.writeValue("mapWidth", mapWidth);
        json.writeValue("mapHeight", mapHeight);
        json.writeValue("playerMoveSpeed", playerMoveSpeed);
        json.writeValue("cameraMinX", cameraMinX);
        json.writeValue("cameraMaxX", cameraMaxX);
        json.writeValue("cameraMinY", cameraMinY);
        json.writeValue("cameraMaxY", cameraMaxY);
        json.writeValue("nodes", nodes);
        json.writeValue("paths", paths);
    }

    @Override
    public void read(Json json, JsonValue jsonData) {
        worldMapTexturePath = jsonData.getString("worldMapTexturePath", "mario_sprites/world_map/worldmap.png");
        mapWidth = jsonData.getFloat("mapWidth", 800f);
        mapHeight = jsonData.getFloat("mapHeight", 600f);
        playerMoveSpeed = jsonData.getFloat("playerMoveSpeed", 120f);
        cameraMinX = jsonData.getFloat("cameraMinX", 400f);
        cameraMaxX = jsonData.getFloat("cameraMaxX", 400f);
        cameraMinY = jsonData.getFloat("cameraMinY", 240f);
        cameraMaxY = jsonData.getFloat("cameraMaxY", 360f);

        // Read nodes
        nodes.clear();
        JsonValue nodesJson = jsonData.get("nodes");
        if (nodesJson != null) {
            for (JsonValue nodeJson : nodesJson) {
                NodeConfig node = json.readValue(NodeConfig.class, nodeJson);
                nodes.add(node);
            }
        }

        // Read paths
        paths.clear();
        JsonValue pathsJson = jsonData.get("paths");
        if (pathsJson != null) {
            for (JsonValue pathJson : pathsJson) {
                PathConfig path = json.readValue(PathConfig.class, pathJson);
                paths.add(path);
            }
        }

        // If no nodes were loaded, create default
        if (nodes.size == 0) {
            createDefaultConfiguration();
        }
    }
}

================
File: src/main/java/io/github/game/WorldMapNode.java
================
// File: core/src/main/java/io/github/game/WorldMapNode.java
package io.github.game;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;

public class WorldMapNode {

    public enum NodeType {
        LEVEL,
        CASTLE,
        FORTRESS,
        GHOST_HOUSE,
        SPECIAL
    }

    public enum NodeState {
        LOCKED,
        UNLOCKED,
        COMPLETED
    }

    private Vector2 position;
    private Rectangle bounds;
    private String levelName;
    private String levelFileName; // NEW: JSON file name for this level
    private NodeType type;
    private NodeState state;
    private int worldNumber;
    private int levelNumber;
    private boolean isSelected;
    private float animationTimer;
    private Color nodeColor;

    // Static textures for different node types
    private static Texture levelNodeTexture;
    private static Texture castleNodeTexture;
    private static Texture fortressNodeTexture;
    private static Texture spookyNodeTexture;
    private static Texture specialNodeTexture;
    private static Texture lockedOverlayTexture;

    public static final float NODE_SIZE = 32f;
    public static final float CASTLE_SIZE = 48f;

    static {
        loadNodeTextures();
    }

    private static void loadNodeTextures() {
        try {
            // Load node textures based on your file structure
            if (com.badlogic.gdx.Gdx.files.internal("mario_sprites/world_map/level_node.png").exists()) {
                levelNodeTexture = new com.badlogic.gdx.graphics.Texture("mario_sprites/world_map/level_node.png");
                com.badlogic.gdx.Gdx.app.log("WorldMapNode", "Loaded level_node.png");
            }

            if (com.badlogic.gdx.Gdx.files.internal("mario_sprites/world_map/castle_node.png").exists()) {
                castleNodeTexture = new com.badlogic.gdx.graphics.Texture("mario_sprites/world_map/castle_node.png");
                com.badlogic.gdx.Gdx.app.log("WorldMapNode", "Loaded castle_node.png");
            }

            if (com.badlogic.gdx.Gdx.files.internal("mario_sprites/world_map/fortress_node.png").exists()) {
                fortressNodeTexture = new com.badlogic.gdx.graphics.Texture("mario_sprites/world_map/fortress_node.png");
                com.badlogic.gdx.Gdx.app.log("WorldMapNode", "Loaded fortress_node.png");
            }

            if (com.badlogic.gdx.Gdx.files.internal("mario_sprites/world_map/spooky_node.png").exists()) {
                spookyNodeTexture = new com.badlogic.gdx.graphics.Texture("mario_sprites/world_map/spooky_node.png");
                com.badlogic.gdx.Gdx.app.log("WorldMapNode", "Loaded spooky_node.png");
            }

            if (com.badlogic.gdx.Gdx.files.internal("mario_sprites/world_map/special_node.png").exists()) {
                specialNodeTexture = new com.badlogic.gdx.graphics.Texture("mario_sprites/world_map/special_node.png");
                com.badlogic.gdx.Gdx.app.log("WorldMapNode", "Loaded special_node.png");
            }

            // Try to find a locked overlay texture (you can create this or use a darker version)
            if (com.badlogic.gdx.Gdx.files.internal("mario_sprites/world_map/locked_overlay.png").exists()) {
                lockedOverlayTexture = new com.badlogic.gdx.graphics.Texture("mario_sprites/world_map/locked_overlay.png");
            }

        } catch (Exception e) {
            com.badlogic.gdx.Gdx.app.error("WorldMapNode", "Failed to load some node textures", e);
        }
    }

    public WorldMapNode(float x, float y, String levelName, NodeType type, int worldNumber, int levelNumber) {
        this.position = new Vector2(x, y);
        this.levelName = levelName;
        this.type = type;
        this.worldNumber = worldNumber;
        this.levelNumber = levelNumber;
        this.state = NodeState.LOCKED;
        this.isSelected = false;
        this.animationTimer = 0f;

        // Set appropriate size based on node type
        float nodeSize = NODE_SIZE;
        if (type == NodeType.CASTLE) {
            nodeSize = CASTLE_SIZE;
        }

        this.bounds = new Rectangle(x - nodeSize/2, y - nodeSize/2, nodeSize, nodeSize);

        // Set node color based on type (used as fallback if textures fail)
        switch (type) {
            case LEVEL:
                nodeColor = Color.RED;
                break;
            case CASTLE:
                nodeColor = Color.PURPLE;
                break;
            case FORTRESS:
                nodeColor = Color.DARK_GRAY;
                break;
            case GHOST_HOUSE:
                nodeColor = Color.WHITE;
                break;
            case SPECIAL:
                nodeColor = Color.YELLOW;
                break;
        }
    }

    public void update(float deltaTime) {
        animationTimer += deltaTime;
    }

    public void render(SpriteBatch batch) {
        // Get the appropriate texture for this node type
        Texture nodeTexture = getTextureForType(type);

        // Calculate size based on type
        float renderSize = (type == NodeType.CASTLE) ? CASTLE_SIZE : NODE_SIZE;

        // Calculate pulsing effect for selected nodes
        float pulseScale = 1.0f;
        if (isSelected) {
            pulseScale = 1.0f + 0.15f * (float)Math.sin(animationTimer * 6.0f);
            renderSize *= pulseScale;
        }

        // Calculate glow effect for unlocked nodes
        Color renderColor = Color.WHITE;
        if (state == NodeState.UNLOCKED) {
            float glowAlpha = 0.8f + 0.2f * (float)Math.sin(animationTimer * 3.0f);
            renderColor = new Color(1f, 1f, 1f, glowAlpha);
        } else if (state == NodeState.COMPLETED) {
            renderColor = new Color(0.8f, 1f, 0.8f, 1f); // Slight green tint for completed
        }

        // Calculate position for centered rendering
        float renderX = position.x - renderSize / 2;
        float renderY = position.y - renderSize / 2;

        // Set batch color
        batch.setColor(renderColor);

        if (nodeTexture != null) {
            // Render the actual node texture
            batch.draw(nodeTexture, renderX, renderY, renderSize, renderSize);

            // Render locked overlay if node is locked
            if (state == NodeState.LOCKED) {
                if (lockedOverlayTexture != null) {
                    batch.setColor(0.3f, 0.3f, 0.3f, 0.7f); // Dark overlay
                    batch.draw(lockedOverlayTexture, renderX, renderY, renderSize, renderSize);
                } else {
                    // Fallback: darken the node
                    batch.setColor(0.3f, 0.3f, 0.3f, 0.8f);
                    batch.draw(nodeTexture, renderX, renderY, renderSize, renderSize);
                }
            }
        } else {
            // Fallback: render colored rectangle if texture is missing
            // Note: This would require a simple white pixel texture to work properly
            // For now, we'll log an error
            com.badlogic.gdx.Gdx.app.error("WorldMapNode", "Missing texture for node type: " + type);
        }

        // Reset batch color
        batch.setColor(Color.WHITE);

        // Render selection indicator if selected
        if (isSelected) {
            renderSelectionIndicator(batch, renderX, renderY, renderSize);
        }
    }

    private void renderSelectionIndicator(SpriteBatch batch, float x, float y, float size) {
        // This could be a pulsing ring or glow effect around the selected node
        // For now, we'll use a simple approach - in a full implementation you'd have a selection ring texture

        // Note: This would require switching to ShapeRenderer or having a ring texture
        // Since we're in SpriteBatch context, we'll create a visual effect using the existing texture

        float ringSize = size * 1.3f;
        float ringX = position.x - ringSize / 2;
        float ringY = position.y - ringSize / 2;

        // Create a pulsing yellow tint around the node
        Color selectionColor = new Color(1f, 1f, 0f, 0.3f + 0.2f * (float)Math.sin(animationTimer * 8.0f));
        batch.setColor(selectionColor);

        // If we have the node texture, draw it slightly larger as a selection ring
        Texture nodeTexture = getTextureForType(type);
        if (nodeTexture != null) {
            batch.draw(nodeTexture, ringX, ringY, ringSize, ringSize);
        }

        batch.setColor(Color.WHITE);
    }

    private Texture getTextureForType(NodeType type) {
        switch (type) {
            case LEVEL:
                return levelNodeTexture;
            case CASTLE:
                return castleNodeTexture;
            case FORTRESS:
                return fortressNodeTexture;
            case GHOST_HOUSE:
                return spookyNodeTexture; // Using spooky for ghost house
            case SPECIAL:
                return specialNodeTexture;
            default:
                return levelNodeTexture; // Fallback
        }
    }

    public boolean contains(float x, float y) {
        return bounds.contains(x, y);
    }

    public void setPosition(float x, float y) {
        this.position.set(x, y);
        updateBounds();
    }

    private void updateBounds() {
        float nodeSize = (type == NodeType.CASTLE) ? CASTLE_SIZE : NODE_SIZE;
        bounds.setPosition(position.x - nodeSize/2, position.y - nodeSize/2);
        bounds.setSize(nodeSize, nodeSize);
    }

    public void unlock() {
        if (state == NodeState.LOCKED) {
            state = NodeState.UNLOCKED;
        }
    }

    public void complete() {
        state = NodeState.COMPLETED;
    }

    public boolean isAccessible() {
        return state == NodeState.UNLOCKED || state == NodeState.COMPLETED;
    }

    // Getters and setters
    public Vector2 getPosition() { return position; }
    public Rectangle getBounds() { return bounds; }
    public String getLevelName() { return levelName; }
    public String getLevelFileName() { return levelFileName; } // NEW
    public void setLevelFileName(String levelFileName) { this.levelFileName = levelFileName; } // NEW
    public NodeType getType() { return type; }
    public NodeState getState() { return state; }
    public void setState(NodeState state) { this.state = state; }
    public int getWorldNumber() { return worldNumber; }
    public int getLevelNumber() { return levelNumber; }
    public boolean isSelected() { return isSelected; }
    public void setSelected(boolean selected) { this.isSelected = selected; }
    public Color getNodeColor() { return nodeColor; }

    // Make textures accessible for WorldMap class
    public static Texture getLevelNodeTexture() { return levelNodeTexture; }
    public static Texture getCastleNodeTexture() { return castleNodeTexture; }
    public static Texture getFortressNodeTexture() { return fortressNodeTexture; }
    public static Texture getSpookyNodeTexture() { return spookyNodeTexture; }
    public static Texture getSpecialNodeTexture() { return specialNodeTexture; }

    public static void disposeStaticTextures() {
        if (levelNodeTexture != null) {
            levelNodeTexture.dispose();
            levelNodeTexture = null;
        }
        if (castleNodeTexture != null) {
            castleNodeTexture.dispose();
            castleNodeTexture = null;
        }
        if (fortressNodeTexture != null) {
            fortressNodeTexture.dispose();
            fortressNodeTexture = null;
        }
        if (spookyNodeTexture != null) {
            spookyNodeTexture.dispose();
            spookyNodeTexture = null;
        }
        if (specialNodeTexture != null) {
            specialNodeTexture.dispose();
            specialNodeTexture = null;
        }
        if (lockedOverlayTexture != null) {
            lockedOverlayTexture.dispose();
            lockedOverlayTexture = null;
        }
    }
}



================================================================
End of Codebase
================================================================
