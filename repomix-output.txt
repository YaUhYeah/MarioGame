This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-26T07:16:34.924Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.editorconfig
.gitattributes
.gitignore
assets/mario_sprites/proj.tpproj
build.gradle
core/build.gradle
core/src/main/java/io/github/game/Background.java
core/src/main/java/io/github/game/editor/AddEnemyCommand.java
core/src/main/java/io/github/game/editor/AddPlatformCommand.java
core/src/main/java/io/github/game/editor/ClearLevelCommand.java
core/src/main/java/io/github/game/editor/EditorCommand.java
core/src/main/java/io/github/game/editor/RemoveEnemyCommand.java
core/src/main/java/io/github/game/editor/RemovePlatformCommand.java
core/src/main/java/io/github/game/enemies/Enemy.java
core/src/main/java/io/github/game/enemies/EnemyType.java
core/src/main/java/io/github/game/enemies/Goomba.java
core/src/main/java/io/github/game/Level.java
core/src/main/java/io/github/game/LevelEditor.java
core/src/main/java/io/github/game/Main.gwt.xml
core/src/main/java/io/github/game/Main.java
core/src/main/java/io/github/game/Platform.java
core/src/main/java/io/github/game/Player.java
core/src/main/java/io/github/game/Powerup.java
core/src/main/java/io/github/game/SoundManager.java
gradle.properties
gradle/gradle-daemon-jvm.properties
gradle/wrapper/gradle-wrapper.properties
gradlew
gradlew.bat
html/build.gradle
html/src/main/java/io/github/game/GdxDefinition.gwt.xml
html/src/main/java/io/github/game/GdxDefinitionSuperdev.gwt.xml
html/src/main/java/io/github/game/gwt/GwtLauncher.java
html/webapp/index.html
html/webapp/styles.css
html/webapp/WEB-INF/web.xml
levels/New Level.json
lwjgl3/build.gradle
lwjgl3/nativeimage.gradle
lwjgl3/src/main/java/io/github/game/lwjgl3/Lwjgl3Launcher.java
lwjgl3/src/main/java/io/github/game/lwjgl3/StartupHelper.java
README.md
server/build.gradle
server/src/main/java/io/github/game/server/ServerLauncher.java
settings.gradle

================================================================
Repository Files
================================================================

================
File: .editorconfig
================
# https://editorconfig.org
root = true

[*]
indent_style = space
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.{java,scala,groovy,kt,kts}]
indent_size = 4

[*.gradle]
indent_size = 2

[*.md]
trim_trailing_whitespace = false

================
File: .gitattributes
================
* text=auto eol=lf
*.bat text=auto eol=crlf

================
File: .gitignore
================
## Gradle:
.gradle/
gradle-app.setting
/build/
/android/build/
/core/build/
/lwjgl2/build/
/lwjgl3/build/
/html/build/
/teavm/build/
/ios/build/
/ios-moe/build/
/headless/build/
/server/build/
/shared/build/

## Java:
*.class
*.war
*.ear
hs_err_pid*
.attach_pid*

## Android:
/android/libs/armeabi-v7a/
/android/libs/arm64-v8a/
/android/libs/x86/
/android/libs/x86_64/
/android/gen/
/android/out/
local.properties
com_crashlytics_export_strings.xml

## Robovm:
/ios/robovm-build/

## iOS:
/ios/xcode/*.xcodeproj/*
!/ios/xcode/*.xcodeproj/xcshareddata
!/ios/xcode/*.xcodeproj/project.pbxproj
/ios/xcode/native/
/ios/IOSLauncher.app
/ios/IOSLauncher.app.dSYM

## GWT:
/html/war/
/html/gwt-unitCache/
.apt_generated/
/html/war/WEB-INF/deploy/
/html/war/WEB-INF/classes/
.gwt/
gwt-unitCache/
www-test/
.gwt-tmp/

## TeaVM:
# Not sure yet...

## IntelliJ, Android Studio:
.idea/
*.ipr
*.iws
*.iml

## Eclipse:
.classpath
.project
.metadata/
/android/bin/
/core/bin/
/lwjgl2/bin/
/lwjgl3/bin/
/html/bin/
/teavm/bin/
/ios/bin/
/ios-moe/bin/
/headless/bin/
/server/bin/
/shared/bin/
*.tmp
*.bak
*.swp
*~.nib
.settings/
.loadpath
.externalToolBuilders/
*.launch


## NetBeans:

/nbproject/private/
/android/nbproject/private/
/core/nbproject/private/
/lwjgl2/nbproject/private/
/lwjgl3/nbproject/private/
/html/nbproject/private/
/teavm/nbproject/private/
/ios/nbproject/private/
/ios-moe/nbproject/private/
/headless/nbproject/private/
/server/nbproject/private/
/shared/nbproject/private/

/nbbuild/
/android/nbbuild/
/core/nbbuild/
/lwjgl2/nbbuild/
/lwjgl3/nbbuild/
/html/nbbuild/
/teavm/nbbuild/
/ios/nbbuild/
/ios-moe/nbbuild/
/headless/nbbuild/
/server/nbbuild/
/shared/nbbuild/

/dist/
/android/dist/
/core/dist/
/lwjgl2/dist/
/lwjgl3/dist/
/html/dist/
/teavm/dist/
/ios/dist/
/ios-moe/dist/
/headless/dist/
/server/dist/
/shared/dist/

/nbdist/
/android/nbdist/
/core/nbdist/
/lwjgl2/nbdist/
/lwjgl3/nbdist/
/html/nbdist/
/teavm/nbdist/
/ios/nbdist/
/ios-moe/nbdist/
/headless/nbdist/
/server/nbdist/
/shared/nbdist/

nbactions.xml
nb-configuration.xml

## OS-Specific:
.DS_Store
Thumbs.db

## Miscellaneous:
*~
*.*#
*#*#
/.kotlin/
/assets/assets.txt

## Special cases:

## There is a resource-config.json file generated by nativeimage.gradle if you use Graal Native Image.
## Some usage may need extra resource configuration in a different file with the same name.
## You could also add that configuration to the text in nativeimage.gradle .
## You should delete or comment out the next line if you have configuration in a different resource-config.json .
**/resource-config.json

================
File: assets/mario_sprites/proj.tpproj
================
name=mario
filename=
output=playables/mario/atlas

alias=true
alphaThreshold=0
debug=false
duplicatePadding=false
edgePadding=true
fast=false
filterMag=Nearest
filterMin=Nearest
ignoreBlankImages=true
maxHeight=2048
maxWidth=2048
minHeight=16
minWidth=16
paddingX=2
paddingY=2
pot=true
mof=false
rotation=false
stripWhitespaceX=false
stripWhitespaceY=false
wrapX=ClampToEdge
wrapY=ClampToEdge
premultiplyAlpha=false
grid=false
square=false
bleed=true
limitMemory=true
useIndexes=true
prettyPrint=false
legacyOutput=false

scaleFactors=[{suffix:"",factor:1,resampling:bicubic}]
inputFiles=[{path:playables/mario/mario_duck.png,type:Input,regionName:null},{path:playables/mario/mario_fall.png,type:Input,regionName:null},{path:playables/mario/mario_idle.png,type:Input,regionName:null},{path:playables/mario/mario_jump.png,type:Input,regionName:null},{path:playables/mario/mario_look_up.png,type:Input,regionName:null},{path:playables/mario/mario_pipe.png,type:Input,regionName:null},{path:playables/mario/mario_walk_0.png,type:Input,regionName:null},{path:playables/mario/mario_walk_1.png,type:Input,regionName:null},{path:playables/mario/mario_walk_2.png,type:Input,regionName:null}]
keepInputFileExtensions=false


---

name=enemies
filename=
output=enemies/atlas

alias=true
alphaThreshold=0
debug=false
duplicatePadding=false
edgePadding=true
fast=false
filterMag=Nearest
filterMin=Nearest
ignoreBlankImages=true
maxHeight=2048
maxWidth=2048
minHeight=16
minWidth=16
paddingX=2
paddingY=2
pot=true
mof=false
rotation=false
stripWhitespaceX=false
stripWhitespaceY=false
wrapX=ClampToEdge
wrapY=ClampToEdge
premultiplyAlpha=false
grid=false
square=false
bleed=true
limitMemory=true
useIndexes=true
prettyPrint=false
legacyOutput=false

scaleFactors=[{suffix:"",factor:1,resampling:bicubic}]
inputFiles=[{path:enemies/bullet_bill.png,type:Input,regionName:null},{path:enemies/goomba_0.png,type:Input,regionName:null},{path:enemies/goomba_1.png,type:Input,regionName:null}]
keepInputFileExtensions=false


---

name=backgrounds
filename=
output=

alias=true
alphaThreshold=0
debug=false
duplicatePadding=false
edgePadding=true
fast=false
filterMag=Nearest
filterMin=Nearest
ignoreBlankImages=true
maxHeight=2048
maxWidth=2048
minHeight=16
minWidth=16
paddingX=2
paddingY=2
pot=true
mof=false
rotation=false
stripWhitespaceX=false
stripWhitespaceY=false
wrapX=ClampToEdge
wrapY=ClampToEdge
premultiplyAlpha=false
grid=false
square=false
bleed=true
limitMemory=true
useIndexes=true
prettyPrint=false
legacyOutput=false

scaleFactors=[{suffix:"",factor:1,resampling:bicubic}]
inputFiles=[]
keepInputFileExtensions=false


-PROJ-

version=4.13.0
fileTypeType=png
fileTypeData={encoding:RGBA8888}
previewBackgroundColor=ffffffff
projectSettings={inputFiles:{}}

================
File: build.gradle
================
buildscript {
  repositories {
    mavenCentral()
    maven { url 'https://s01.oss.sonatype.org' }
    gradlePluginPortal()
    mavenLocal()
    google()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
  }
  dependencies {


  }
}

allprojects {
  apply plugin: 'eclipse'
  apply plugin: 'idea'

  // This allows you to "Build and run using IntelliJ IDEA", an option in IDEA's Settings.
  idea {
    module {
      outputDir file('build/classes/java/main')
      testOutputDir file('build/classes/java/test')
    }
  }
}

configure(subprojects) {
  apply plugin: 'java-library'
  sourceCompatibility = 8

  // From https://lyze.dev/2021/04/29/libGDX-Internal-Assets-List/
  // The article can be helpful when using assets.txt in your project.
  tasks.register('generateAssetList') {
    inputs.dir("${project.rootDir}/assets/")
    // projectFolder/assets
    File assetsFolder = new File("${project.rootDir}/assets/")
    // projectFolder/assets/assets.txt
    File assetsFile = new File(assetsFolder, "assets.txt")
    // delete that file in case we've already created it
    assetsFile.delete()

    // iterate through all files inside that folder
    // convert it to a relative path
    // and append it to the file assets.txt
    fileTree(assetsFolder).collect { assetsFolder.relativePath(it) }.sort().each {
      assetsFile.append(it + "\n")
    }
  }
  processResources.dependsOn 'generateAssetList'

  compileJava {
    options.incremental = true
  }
}

subprojects {
  version = "$projectVersion"
  ext.appName = 'Mario'
  repositories {
    mavenCentral()
    maven { url 'https://s01.oss.sonatype.org' }
    // You may want to remove the following line if you have errors downloading dependencies.
    mavenLocal()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://jitpack.io' }
  }
}

eclipse.project.name = 'Mario' + '-parent'

================
File: core/build.gradle
================
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
eclipse.project.name = appName + '-core'

dependencies {
  api "com.badlogicgames.gdx:gdx:$gdxVersion"
  api "com.crashinvaders.basisu:basisu-gdx:$gdxBasisUniversalVersion"
  api "com.crashinvaders.basisu:basisu-wrapper:$gdxBasisUniversalVersion"
  api "com.github.crykn:kryonet:$kryoNetVersion"

  if(enableGraalNative == 'true') {
    implementation "io.github.berstanio:gdx-svmhelper-annotations:$graalHelperVersion"
  }
}

================
File: core/src/main/java/io/github/game/Background.java
================
// File: core/src/main/java/io/github/game/Background.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;

public class Background {

    private Texture backgroundTexture;
    private String currentTexturePath;
    private float textureWidth;
    private float textureHeight;
    private float scrollSpeed = 0.5f; // Default scroll speed

    public static final String DEFAULT_BACKGROUND_PATH = "mario_sprites/backgrounds/background_0.png";

    public Background() {
        setTexture(DEFAULT_BACKGROUND_PATH);
    }

    public Background(String texturePath) {
        setTexture(texturePath);
    }

    public void setTexture(String texturePath) {
        if (texturePath == null || texturePath.isEmpty()) {
            Gdx.app.error("Background", "Texture path is null or empty. Using default: " + DEFAULT_BACKGROUND_PATH);
            texturePath = DEFAULT_BACKGROUND_PATH;
        }

        if (this.currentTexturePath != null && this.currentTexturePath.equals(texturePath) && backgroundTexture != null) {
            return; // Texture is already loaded and is the same
        }

        try {
            if (backgroundTexture != null) {
                backgroundTexture.dispose(); // Dispose old texture
            }
            Gdx.app.log("Background", "Attempting to load background: " + texturePath);
            backgroundTexture = new Texture(Gdx.files.internal(texturePath));
            this.currentTexturePath = texturePath;
            textureWidth = backgroundTexture.getWidth();
            textureHeight = backgroundTexture.getHeight();
            Gdx.app.log("Background", "Successfully loaded new background: " + texturePath + " (Width: " + textureWidth + ", Height: " + textureHeight + ")");
        } catch (Exception e) {
            Gdx.app.error("Background", "Failed to load background texture: " + texturePath, e);
            // Attempt to load a fallback if the primary one fails and it wasn't the default already
            if (!texturePath.equals(DEFAULT_BACKGROUND_PATH)) {
                Gdx.app.error("Background", "Falling back to default background due to previous error.");
                setTexture(DEFAULT_BACKGROUND_PATH); // Recursive call to load default
            } else {
                // If default also fails, then we have a bigger issue, or it's missing
                Gdx.app.error("Background", "Default background also failed to load. Background will be blank.");
                if (backgroundTexture != null) backgroundTexture.dispose();
                backgroundTexture = null; // Prevent NPEs in render
                this.currentTexturePath = null;
                textureWidth = 0; // Reset dimensions
                textureHeight = 0;
            }
        }
    }


    public void update(float deltaTime) {
        // This method can be used for future background animations or effects.
        // For parallax scrolling based on camera, all logic is in render().
    }

    public void render(SpriteBatch batch, OrthographicCamera camera) {
        if (backgroundTexture == null || textureWidth == 0) { // Don't render if texture failed to load or has no width
            return;
        }

        float cameraViewLeft = camera.position.x - camera.viewportWidth * camera.zoom / 2f;
        float cameraViewRight = camera.position.x + camera.viewportWidth * camera.zoom / 2f;

        float parallaxOffset = camera.position.x * scrollSpeed;

        // Ensure the loop condition handles cases where textureWidth might be zero to prevent infinite loops.
        // The condition textureWidth == 0 is checked at the beginning.
        for (float x = (float)Math.floor((cameraViewLeft - parallaxOffset) / textureWidth) * textureWidth + parallaxOffset; // Adjusted logic slightly
             x < cameraViewRight;
             x += textureWidth) {
            // Draw the background from y=0 up to camera.viewportHeight or level height.
            // For simplicity, drawing at y=0 with its original height.
            // If viewportHeight is desired, texture scaling or tiling vertically would be needed if textureHeight < viewportHeight.
            batch.draw(backgroundTexture, x, 0, textureWidth, textureHeight);
        }
    }

    public void dispose() {
        if (backgroundTexture != null) {
            backgroundTexture.dispose();
            backgroundTexture = null;
        }
    }
}

================
File: core/src/main/java/io/github/game/editor/AddEnemyCommand.java
================
package io.github.game.editor;

import io.github.game.Level;

public class AddEnemyCommand implements EditorCommand {
    private Level level;
    private Level.EnemyData enemyData;

    public AddEnemyCommand(Level level, Level.EnemyData enemyData) {
        this.level = level;
        this.enemyData = enemyData;
    }

    @Override
    public void execute() {
        level.addEnemy(enemyData);
    }

    @Override
    public void undo() {
        level.removeEnemy(enemyData);
    }
}

================
File: core/src/main/java/io/github/game/editor/AddPlatformCommand.java
================
// File: core/src/main/java/io/github/game/editor/AddPlatformCommand.java
package io.github.game.editor;

import io.github.game.Level;
import io.github.game.Level.PlatformData; // If PlatformData is public inner class

public class AddPlatformCommand implements EditorCommand {
    private Level level;
    private PlatformData platformData;

    public AddPlatformCommand(Level level, PlatformData platformData) {
        this.level = level;
        this.platformData = platformData;
    }

    @Override
    public void execute() {
        level.addPlatform(platformData);
    }

    @Override
    public void undo() {
        level.removePlatform(platformData); // Assumes Level.removePlatform can remove by instance
    }
}

================
File: core/src/main/java/io/github/game/editor/ClearLevelCommand.java
================
// File: core/src/main/java/io/github/game/editor/ClearLevelCommand.java
package io.github.game.editor;

import com.badlogic.gdx.utils.Array;
import io.github.game.Level;
import io.github.game.Level.PlatformData;

public class ClearLevelCommand implements EditorCommand {
    private Level level;
    private Array<PlatformData> originalPlatforms;
    private PlatformData defaultGroundAdded; // The specific instance of default ground added

    public ClearLevelCommand(Level level, Array<PlatformData> platformsBeforeClear, PlatformData defaultGroundInstance) {
        this.level = level;
        this.originalPlatforms = new Array<>(platformsBeforeClear); // Store a copy of the state before clear
        this.defaultGroundAdded = defaultGroundInstance;
    }

    @Override
    public void execute() {
        level.getPlatformData().clear();
        if (defaultGroundAdded != null) {
            level.addPlatform(defaultGroundAdded); // Add the specific instance
        }
    }

    @Override
    public void undo() {
        level.getPlatformData().clear();
        level.getPlatformData().addAll(originalPlatforms);
    }
}

================
File: core/src/main/java/io/github/game/editor/EditorCommand.java
================
// File: core/src/main/java/io/github/game/editor/EditorCommand.java
package io.github.game.editor;

public interface EditorCommand {
    void execute();
    void undo();
}

================
File: core/src/main/java/io/github/game/editor/RemoveEnemyCommand.java
================
// File: core/src/main/java/io/github/game/editor/RemoveEnemyCommand.java
package io.github.game.editor;

import io.github.game.Level;

public class RemoveEnemyCommand implements EditorCommand {
    private Level level;
    private Level.EnemyData enemyData;
    // private int originalIndex = -1; // Optional for restoring order

    public RemoveEnemyCommand(Level level, Level.EnemyData enemyData) {
        this.level = level;
        this.enemyData = enemyData;
        // this.originalIndex = level.getEnemyData().indexOf(enemyData, true);
    }

    @Override
    public void execute() {
        level.removeEnemy(enemyData);
    }

    @Override
    public void undo() {
        // if (originalIndex != -1 && originalIndex < level.getEnemyData().size) {
        //    level.getEnemyData().insert(originalIndex, enemyData);
        // } else {
        level.addEnemy(enemyData); // Adds to the end if index not used
        // }
    }
}

================
File: core/src/main/java/io/github/game/editor/RemovePlatformCommand.java
================
// File: core/src/main/java/io/github/game/editor/RemovePlatformCommand.java
package io.github.game.editor;

import io.github.game.Level;
import io.github.game.Level.PlatformData;
import com.badlogic.gdx.utils.Array; // For storing index if needed

public class RemovePlatformCommand implements EditorCommand {
    private Level level;
    private PlatformData platformData;
    private int originalIndex = -1; // Optional: for restoring exact order

    public RemovePlatformCommand(Level level, PlatformData platformData) {
        this.level = level;
        this.platformData = platformData;
        // To store originalIndex, you'd find it before removing:
        // this.originalIndex = level.getPlatformData().indexOf(platformData, true);
    }

    @Override
    public void execute() {
        // If originalIndex was stored, ensure it's still valid or re-find before removal.
        // For simplicity, we assume Level.removePlatform works by instance.
        level.removePlatform(platformData);
    }

    @Override
    public void undo() {
        // if (originalIndex != -1 && originalIndex < level.getPlatformData().size) {
        //    level.getPlatformData().insert(originalIndex, platformData);
        // } else {
        level.addPlatform(platformData); // Adds to the end if index not used
        // }
    }
}

================
File: core/src/main/java/io/github/game/enemies/Enemy.java
================
// File: core/src/main/java/io/github/game/Enemy.java
package io.github.game.enemies;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Disposable;
import io.github.game.Platform;
import io.github.game.Player;

public abstract class Enemy implements Disposable {
    public enum EnemyState {
        WALKING,
        STOMPED,
        DEAD
    }

    protected Vector2 position;
    protected Vector2 velocity;
    protected Rectangle bounds;
    protected boolean isAlive;
    protected boolean facingRight;
    protected float stateTimer;
    protected EnemyState currentState;
    protected TextureAtlas enemyAtlas; // All enemies can share this

    public static final float GRAVITY = -900f; // Shared gravity for enemies

    public Enemy(TextureAtlas atlas, float x, float y, float width, float height) {
        this.enemyAtlas = atlas;
        this.position = new Vector2(x, y);
        this.velocity = new Vector2(0, 0);
        this.bounds = new Rectangle(x, y, width, height);
        this.isAlive = true;
        this.facingRight = false; // Default to moving left
        this.stateTimer = 0f;
        this.currentState = EnemyState.WALKING;
    }

    public void update(float deltaTime, Array<Platform> platforms, Player player) {
        if (!isAlive && currentState != EnemyState.STOMPED) return; // Don't update if dead, unless it's a timed stomp animation

        stateTimer += deltaTime;
        updateLogic(deltaTime, platforms, player);

        // Apply gravity if not stomped (stomped might have a different behavior)
        if (currentState == EnemyState.WALKING) {
            velocity.y += GRAVITY * deltaTime;
        }

        position.x += velocity.x * deltaTime;
        bounds.setX(position.x);
        checkHorizontalPlatformCollisions(platforms);

        position.y += velocity.y * deltaTime;
        bounds.setY(position.y);
        checkVerticalPlatformCollisions(platforms);

        if (position.y < -bounds.height * 2) { // Fell off screen
            isAlive = false;
            currentState = EnemyState.DEAD;
        }
    }

    protected abstract void updateLogic(float deltaTime, Array<Platform> platforms, Player player);
    public abstract void render(SpriteBatch batch);
    public abstract void onStompedBy(Player player); // Called when Mario jumps on it
    public abstract boolean onCollisionWith(Player player); // Called when Mario runs into it

    protected void checkHorizontalPlatformCollisions(Array<Platform> platforms) {
        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue;
            if (bounds.overlaps(platform.getBounds())) {
                if (velocity.x > 0) { // Moving right
                    position.x = platform.getBounds().x - bounds.width;
                    velocity.x = -Math.abs(velocity.x); // Turn around
                    facingRight = false;
                } else if (velocity.x < 0) { // Moving left
                    position.x = platform.getBounds().x + platform.getBounds().width;
                    velocity.x = Math.abs(velocity.x); // Turn around
                    facingRight = true;
                }
                bounds.setX(position.x);
            }
        }
    }

    protected void checkVerticalPlatformCollisions(Array<Platform> platforms) {
        boolean grounded = false;
        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue;
            if (bounds.overlaps(platform.getBounds())) {
                if (velocity.y < 0 && position.y + bounds.height / 2f > platform.getBounds().y + platform.getBounds().height) { // Landing on top
                    position.y = platform.getBounds().y + platform.getBounds().height;
                    velocity.y = 0;
                    grounded = true;
                } else if (velocity.y > 0 && position.y < platform.getBounds().y) { // Hitting head (less common for Goombas)
                    position.y = platform.getBounds().y - bounds.height;
                    velocity.y = 0;
                }
                bounds.setY(position.y);
            }
        }
        // If walking and not grounded, and about to pass edge, turn around (simplified edge detection)
        if (currentState == EnemyState.WALKING && grounded) {
            boolean onPlatform = false;
            for (Platform platform : platforms) {
                if (platform.getType() == Platform.PlatformType.COIN) continue;
                // Check if bottom of enemy is slightly above the platform
                Rectangle groundCheckRect = new Rectangle(bounds.x, bounds.y - 1, bounds.width, 1);
                if(groundCheckRect.overlaps(platform.getBounds())) {
                    onPlatform = true;
                    break;
                }
            }
            if (!onPlatform && velocity.y == 0) { // No ground directly beneath, turn (very basic)
                // This simple check might make them turn mid-air if they walk off a tiny bit.
                // A more robust solution involves raycasting or checking tiles ahead.
                // For now, let's make them turn if they hit a wall or are explicitly told to.
            }
        }


    }


    public Rectangle getBounds() {
        return bounds;
    }

    public boolean isAlive() {
        return isAlive;
    }

    public Vector2 getPosition() { return position; }
    public Vector2 getVelocity() { return velocity; }
    public EnemyState getCurrentState() { return currentState; }


    @Override
    public void dispose() {
        // TextureAtlas is shared, usually disposed by Main game class
    }
}

================
File: core/src/main/java/io/github/game/enemies/EnemyType.java
================
// File: core/src/main/java/io/github/game/enemies/EnemyType.java
package io.github.game.enemies;

public enum EnemyType {
    GOOMBA("Goomba");
    // Add other enemy types here in the future, e.g., KOOPA_TROOPA

    private final String displayName;

    EnemyType(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }

    @Override
    public String toString() {
        return displayName;
    }
}

================
File: core/src/main/java/io/github/game/enemies/Goomba.java
================
// File: core/src/main/java/io/github/game/Goomba.java
package io.github.game.enemies;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.Array;
import io.github.game.Platform;
import io.github.game.Player;
import io.github.game.SoundManager;
import io.github.game.enemies.Enemy;

public class Goomba extends Enemy {
    public static final float WIDTH = 32f; // Visual size
    public static final float HEIGHT = 32f;
    private static final float COLLISION_WIDTH = 28f; // Smaller collision box
    private static final float COLLISION_HEIGHT = 28f;
    private static final float SPEED = 50f;
    private static final float STOMP_DURATION = 0.5f; // How long squashed image shows

    private Animation<TextureRegion> walkAnimation;
    private TextureRegion squashedTexture; // For when stomped

    public Goomba(TextureAtlas atlas, float x, float y) {
        super(atlas, x, y, COLLISION_WIDTH, COLLISION_HEIGHT); // Use collision dimensions for bounds

        Array<TextureRegion> frames = new Array<>();
        frames.add(enemyAtlas.findRegion("goomba", 0)); // Assumes "goomba-0" or "goomba_0"
        frames.add(enemyAtlas.findRegion("goomba", 1)); // Assumes "goomba-1" or "goomba_1"
        if (frames.get(0) == null || frames.get(1) == null) {
            // Fallback if indexed regions are not found by name "goomba" and index
            frames.clear();
            TextureRegion goombaSheet = enemyAtlas.findRegion("goomba_walk_0"); // Fallback for individual images if atlas pack structure differs
            if (goombaSheet == null && enemyAtlas.findRegion("goomba") != null) { // If "goomba" is a single region for a spritesheet
                goombaSheet = enemyAtlas.findRegion("goomba");
                if (goombaSheet.getRegionWidth() > 16) { // Assuming it's a strip
                    frames.add(new TextureRegion(goombaSheet, 0, 0, 16, 16));
                    frames.add(new TextureRegion(goombaSheet, 16 + (goombaSheet.getRegionWidth() > 32 ? 20-16 : 0) , 0, 16, 16)); // Adjust based on your atlas packing for goomba_1
                } else {
                    frames.add(goombaSheet); // If only one frame
                    frames.add(goombaSheet);
                }
            } else if (goombaSheet != null) {
                frames.add(goombaSheet);
                frames.add(enemyAtlas.findRegion("goomba_walk_1"));
            }


            // If still null, major asset issue. For now, we'll proceed assuming they load.
            if(frames.size < 2 || frames.get(0) == null || frames.get(1) == null) {
                System.err.println("CRITICAL: Goomba walk animation frames not found in atlas!");
                // Create placeholder frames to avoid crashing
                TextureRegion placeholder = enemyAtlas.getRegions().first(); // any region
                if (placeholder == null) throw new RuntimeException("Enemy atlas is empty!");
                frames.clear();
                frames.add(placeholder);
                frames.add(placeholder);
            }
        }

        walkAnimation = new Animation<>(0.2f, frames, Animation.PlayMode.LOOP);
        // For squashed texture, ideally, you'd have a "goomba_squashed" region
        // For now, let's use the first frame and scale it or just make it disappear.
        // If you have a "bullet_bill" texture, and no specific squashed one, we can use a walk frame.
        squashedTexture = frames.get(0); // Placeholder for squashed

        velocity.x = facingRight ? SPEED : -SPEED;
    }

    @Override
    protected void updateLogic(float deltaTime, Array<Platform> platforms, Player player) {
        if (currentState == EnemyState.STOMPED) {
            velocity.x = 0; // Stop moving when stomped
            if (stateTimer > STOMP_DURATION) {
                isAlive = false;
                currentState = EnemyState.DEAD;
            }
            return;
        }

        if (currentState == EnemyState.WALKING) {
            // Basic edge detection: if no platform ahead and below, turn around
            // This needs a more robust solution for reliable behavior.
            // For now, relies on checkHorizontalPlatformCollisions to turn at walls.
            // A simple way to ensure they turn at edges:
            boolean willFall = true;
            float checkX = position.x + (facingRight ? bounds.width : -1); // Point just off the edge
            Rectangle groundFeeler = new Rectangle(checkX, position.y - 5, 1, 5);

            for (Platform p : platforms) {
                if (p.getType() != Platform.PlatformType.COIN && p.getBounds().overlaps(groundFeeler)) {
                    willFall = false;
                    break;
                }
            }
            if (willFall && velocity.y == 0) { // If on ground and about to fall
                facingRight = !facingRight;
                velocity.x = facingRight ? SPEED : -SPEED;
            }
        }
    }

    @Override
    public void render(SpriteBatch batch) {
        if (!isAlive && currentState != EnemyState.STOMPED) return;

        TextureRegion currentFrame = null;
        if (currentState == EnemyState.STOMPED) {
            currentFrame = squashedTexture;
        } else { // WALKING
            currentFrame = walkAnimation.getKeyFrame(stateTimer, true);
        }

        if (currentFrame != null) {
            float drawX = position.x - (WIDTH - COLLISION_WIDTH) / 2f; // Adjust draw position for visual size
            float drawY = position.y - (HEIGHT - COLLISION_HEIGHT) / 2f;
            float drawWidth = WIDTH;
            float drawHeight = currentState == EnemyState.STOMPED ? HEIGHT / 2f : HEIGHT; // Squash visually

            // Flip the texture if not facing right
            boolean flipX = !facingRight;
            if (currentFrame.isFlipX() != flipX) {
                // TextureRegion.flip() modifies the region permanently.
                // It's better to use SpriteBatch.draw() with flip parameters.
            }

            batch.draw(currentFrame,
                flipX ? drawX + drawWidth : drawX, // Adjust x for flipping
                drawY,
                flipX ? -drawWidth : drawWidth, // Flip by making width negative
                drawHeight);
        }
    }

    @Override
    public void onStompedBy(Player player) {
        if (currentState == EnemyState.WALKING) {
            currentState = EnemyState.STOMPED;
            isAlive = true; // Keep it "alive" for the stomp animation duration
            velocity.set(0, 0);
            stateTimer = 0f;
        }
    }

    @Override
    public boolean onCollisionWith(Player player) {
        // If Goomba is walking and player collides, player should die (unless invincible)
        return currentState == Enemy.EnemyState.WALKING;
    }

    @Override
    public void dispose() {
        super.dispose();
        // walkAnimation frames are from shared atlas
    }
}

================
File: core/src/main/java/io/github/game/Level.java
================
// File: core/src/main/java/io/github/game/Level.java
package io.github.game;

import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;
import com.badlogic.gdx.utils.ObjectMap;

public class Level implements Json.Serializable {
    public static class PlatformData {
        public float x, y, width, height;
        public Platform.PlatformType type;
        public Powerup.PowerupType containedPowerup;

        public PlatformData() {}

        public PlatformData(float x, float y, float width, float height, Platform.PlatformType type) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.type = type;
            this.containedPowerup = null;
        }
    }

    public static class EnemyData {
        public float x, y;
        public String type; // e.g., "GOOMBA"

        public EnemyData() {} // For JSON deserialization

        public EnemyData(float x, float y, String type) {
            this.x = x;
            this.y = y;
            this.type = type;
        }
    }

    private String name;
    private Array<PlatformData> platformData;
    private Array<EnemyData> enemyData; // ADDED
    private float playerStartX, playerStartY;
    private String backgroundMusic;
    private float musicVolume;
    private String backgroundTexturePath;
    private ObjectMap<String, Powerup.PowerupType> questionBlockContents;



    public Level() {
        this.name = "Untitled Level";
        this.platformData = new Array<>();
        this.enemyData = new Array<>(); // ADDED: Initialize
        this.playerStartX = 150;
        this.playerStartY = Platform.GROUND_TILE_SIZE * 2;
        this.backgroundMusic = "music/level1.mp3";
        this.musicVolume = 0.5f;
        this.backgroundTexturePath = Background.DEFAULT_BACKGROUND_PATH; // Use default from Background
        this.questionBlockContents = new ObjectMap<>();
    }

    public Level(String name) {
        this();
        this.name = name;
    }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public Array<PlatformData> getPlatformData() { return platformData; }

    public float getPlayerStartX() { return playerStartX; }
    public void setPlayerStartX(float x) { this.playerStartX = x; }

    public float getPlayerStartY() { return playerStartY; }
    public void setPlayerStartY(float y) { this.playerStartY = y; }

    public String getBackgroundMusic() { return backgroundMusic; }
    public void setBackgroundMusic(String music) { this.backgroundMusic = music; }

    public float getMusicVolume() { return musicVolume; }
    public void setMusicVolume(float volume) { this.musicVolume = volume; }

    public Array<EnemyData> getEnemyData() { return enemyData; }
    public String getBackgroundTexturePath() { return backgroundTexturePath; } // Added Getter
    public void setBackgroundTexturePath(String path) { this.backgroundTexturePath = path; } // Added Setter


    public void setQuestionBlockContent(String blockId, Powerup.PowerupType powerup) {
        questionBlockContents.put(blockId, powerup);
    }

    public Powerup.PowerupType getQuestionBlockContent(String blockId) {
        return questionBlockContents.get(blockId);
    }


    public void addPlatform(PlatformData data) {
        platformData.add(data);
    }

    public void removePlatform(PlatformData data) {
        platformData.removeValue(data, true);
    }

    public Array<Platform> createPlatforms() {
        Array<Platform> platforms = new Array<>();
        for (PlatformData data : platformData) {
            platforms.add(new Platform(data.x, data.y, data.width, data.height, data.type));
        }
        return platforms;
    }

    public void addEnemy(EnemyData data) {
        enemyData.add(data);
    }

    public void removeEnemy(EnemyData data) {
        enemyData.removeValue(data, true);
    }
    @Override
    public void write(Json json) {
        json.writeValue("name", name);
        json.writeValue("playerStartX", playerStartX);
        json.writeValue("playerStartY", playerStartY);
        json.writeValue("backgroundMusic", backgroundMusic);
        json.writeValue("musicVolume", musicVolume);
        json.writeValue("backgroundTexturePath", backgroundTexturePath); // Added serialization
        json.writeValue("platforms", platformData);
        json.writeValue("enemies", enemyData);
        json.writeValue("questionBlockContents", questionBlockContents);
    }

    @Override
    public void read(Json json, JsonValue jsonData) {
        name = jsonData.getString("name");
        playerStartX = jsonData.getFloat("playerStartX");
        playerStartY = jsonData.getFloat("playerStartY");
        backgroundMusic = jsonData.getString("backgroundMusic", "music/level1.mp3");
        musicVolume = jsonData.getFloat("musicVolume", 0.5f);
        backgroundTexturePath = jsonData.getString("backgroundTexturePath", Background.DEFAULT_BACKGROUND_PATH);

        platformData.clear();
        JsonValue platformsJson = jsonData.get("platforms");
        if (platformsJson != null) {
            for (JsonValue platformJson : platformsJson) {
                PlatformData data = json.readValue(PlatformData.class, platformJson); // Simpler read
                platformData.add(data);
            }
        }

        enemyData.clear(); // ADDED: Deserialize enemies
        JsonValue enemiesJson = jsonData.get("enemies");
        if (enemiesJson != null) {
            for (JsonValue enemyJson : enemiesJson) {
                EnemyData data = new EnemyData();
                data.x = enemyJson.getFloat("x");
                data.y = enemyJson.getFloat("y");
                data.type = enemyJson.getString("type");
                enemyData.add(data);
            }
        }


        questionBlockContents.clear();
        JsonValue contentsJson = jsonData.get("questionBlockContents");
        if (contentsJson != null) {
            for (JsonValue.JsonIterator it = contentsJson.iterator(); it.hasNext(); ) {
                JsonValue entry = it.next();
                try {
                    questionBlockContents.put(entry.name, Powerup.PowerupType.valueOf(entry.asString()));
                } catch (IllegalArgumentException e) {
                    System.err.println("Warning: Unknown PowerupType '" + entry.asString() + "' for question block ID '" + entry.name + "'. Skipping.");
                }
            }
        }
    }

}

================
File: core/src/main/java/io/github/game/LevelEditor.java
================
// File: core/src/main/java/io/github/game/LevelEditor.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture; // Keep for potential other previews if needed
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas; // For Goomba preview
import com.badlogic.gdx.graphics.g2d.TextureRegion; // For Goomba preview
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Json;

import java.util.ArrayDeque;

import io.github.game.editor.EditorCommand;
import io.github.game.editor.AddPlatformCommand;
import io.github.game.editor.RemovePlatformCommand;
import io.github.game.editor.ClearLevelCommand;
import io.github.game.editor.AddEnemyCommand; // New
import io.github.game.editor.RemoveEnemyCommand; // New

public class LevelEditor {
    private static final float GRID_SIZE = 32f;
    private static final float UI_PANEL_WIDTH = 220f; // Slightly wider for more text/buttons
    private static final float DEFAULT_GROUND_WIDTH_MULTIPLIER = 100f;
    private static final float DEFAULT_GROUND_HEIGHT_MULTIPLIER = 2f;

    private Level currentLevel;

    // Tool selection
    private enum EditorTool {
        PLATFORM,
        GOOMBA
        // Add other enemy types or placeable items here
    }
    private EditorTool currentTool = EditorTool.PLATFORM;
    private Platform.PlatformType selectedPlatformType = Platform.PlatformType.GRAVEL_BLOCK;
    // private String selectedEnemyType = "GOOMBA"; // If supporting multiple enemy types via one tool

    private Level.PlatformData selectedPlatform;
    private Level.EnemyData selectedEnemy; // For selecting placed enemies

    private boolean isDragging = false;
    private float dragStartX, dragStartY;

    private ShapeRenderer shapeRenderer;
    private BitmapFont font;
    private Vector3 mousePos;

    // UI Rectangles
    private Array<Rectangle> platformTypeButtons;
    private Array<Platform.PlatformType> buttonPlatformTypes;
    private Rectangle goombaButton; // Button for selecting Goomba tool
    private Rectangle saveButton, loadButton, clearButton, playButton, previewButton;

    private Rectangle placementPreviewRect;
    private boolean showPlacementPreview = true;

    public enum EditorUIMode { EDITING, LEVEL_PREVIEW }
    private EditorUIMode currentUIMode = EditorUIMode.EDITING;
    private boolean hasUnappliedChanges = false;
    private BitmapFont notificationFont;

    private ArrayDeque<EditorCommand> undoStack = new ArrayDeque<>();
    private ArrayDeque<EditorCommand> redoStack = new ArrayDeque<>();
    private static final int MAX_HISTORY_SIZE = 100;

    private Array<String> availableBackgroundPaths;
    private Array<String> availableBackgroundNames;
    private Array<Rectangle> backgroundSelectorButtons;

    // Texture resources for editor previews
    private TextureAtlas enemyAtlasForEditor;
    private TextureRegion goombaPreviewTexture;

    public LevelEditor() {
        this.currentLevel = new Level("New Level");
        this.shapeRenderer = new ShapeRenderer();
        this.font = new BitmapFont();
        this.notificationFont = new BitmapFont();
        this.mousePos = new Vector3();
        this.placementPreviewRect = new Rectangle();

        // Load enemy atlas for editor previews
        try {
            enemyAtlasForEditor = new TextureAtlas(Gdx.files.internal("mario_sprites/enemies/atlas/enemies.atlas"));
            // Try finding by indexed name first, common from TexturePacker
            goombaPreviewTexture = enemyAtlasForEditor.findRegion("goomba", 0);
            if (goombaPreviewTexture == null) { // Fallback to simple name if not indexed
                goombaPreviewTexture = enemyAtlasForEditor.findRegion("goomba_walk_0"); // Or just "goomba" if it's a single packed image
            }
            if (goombaPreviewTexture == null && enemyAtlasForEditor.findRegion("goomba") != null && enemyAtlasForEditor.findRegion("goomba").getRegionWidth() > 16) {
                TextureRegion goombaSheet = enemyAtlasForEditor.findRegion("goomba");
                goombaPreviewTexture = new TextureRegion(goombaSheet, 0,0,16,16); // Assuming first frame of a strip
            }

            if (goombaPreviewTexture == null && enemyAtlasForEditor.getRegions().size > 0) {
                goombaPreviewTexture = enemyAtlasForEditor.getRegions().first(); // Absolute fallback
                Gdx.app.error("LevelEditor", "Goomba preview texture specific name not found, using first available region from enemy atlas.");
            } else if (goombaPreviewTexture == null) {
                Gdx.app.error("LevelEditor", "CRITICAL: Goomba preview texture not found and enemy atlas is empty or missing suitable regions.");
                // Potentially load a default placeholder texture here if goombaPreviewTexture is still null
            }
        } catch (Exception e) {
            Gdx.app.error("LevelEditor", "Failed to load enemy atlas for editor: " + e.getMessage(), e);
            // Handle error: goombaPreviewTexture might be null. Render methods should check.
        }


        this.availableBackgroundPaths = new Array<>();
        this.availableBackgroundNames = new Array<>();
        this.backgroundSelectorButtons = new Array<>();

        availableBackgroundPaths.add("mario_sprites/backgrounds/background_0.png");
        availableBackgroundNames.add("Sky (Default)");
        availableBackgroundPaths.add("mario_sprites/backgrounds/background_1.png");
        availableBackgroundNames.add("Hills");
        availableBackgroundPaths.add("mario_sprites/backgrounds/background_2.png");
        availableBackgroundNames.add("Night Sky");

        initializeUI();

        Level.PlatformData initialGround = new Level.PlatformData(
            0, 0, GRID_SIZE * DEFAULT_GROUND_WIDTH_MULTIPLIER, GRID_SIZE * DEFAULT_GROUND_HEIGHT_MULTIPLIER, Platform.PlatformType.GROUND
        );
        currentLevel.addPlatform(initialGround); // Add initial ground
        // No need to executeCommand for initial setup unless you want it in undo history
        this.hasUnappliedChanges = true; // Mark initial state as changeable
    }

    private void initializeUI() {
        platformTypeButtons = new Array<>();
        buttonPlatformTypes = new Array<>();
        backgroundSelectorButtons.clear(); // Clear before re-populating in case of resize

        float viewportHeight = Gdx.graphics.getHeight();
        float currentButtonTopY = viewportHeight - 20f; // Start from top
        float buttonHeight = 28f; // Smaller buttons for more items
        float buttonSpacing = 7f;
        float uiElementTotalHeight = buttonHeight + buttonSpacing;
        float sectionTitleSpacing = 15f; // Space for section titles
        float sectionPadding = 5f; // Space after a section title before buttons

        // --- Platforms Section ---
        currentButtonTopY -= sectionTitleSpacing; // Space for "Platforms:" title
        for (Platform.PlatformType type : Platform.PlatformType.values()) {
            currentButtonTopY -= uiElementTotalHeight;
            Rectangle button = new Rectangle(10f, currentButtonTopY, UI_PANEL_WIDTH - 20f, buttonHeight);
            platformTypeButtons.add(button);
            buttonPlatformTypes.add(type);
        }

        // --- Enemies Section ---
        currentButtonTopY -= (sectionTitleSpacing + sectionPadding); // Space for "Enemies:" title
        // Goomba Button
        currentButtonTopY -= uiElementTotalHeight;
        goombaButton = new Rectangle(10f, currentButtonTopY, UI_PANEL_WIDTH - 20f, buttonHeight);

        // --- Controls Section ---
        currentButtonTopY -= (sectionTitleSpacing + sectionPadding); // Space for "Controls:" title
        currentButtonTopY -= uiElementTotalHeight;
        saveButton = new Rectangle(10f, currentButtonTopY, UI_PANEL_WIDTH - 20f, buttonHeight);
        currentButtonTopY -= uiElementTotalHeight;
        loadButton = new Rectangle(10f, currentButtonTopY, UI_PANEL_WIDTH - 20f, buttonHeight);
        currentButtonTopY -= uiElementTotalHeight;
        clearButton = new Rectangle(10f, currentButtonTopY, UI_PANEL_WIDTH - 20f, buttonHeight);
        currentButtonTopY -= uiElementTotalHeight;
        previewButton = new Rectangle(10f, currentButtonTopY, UI_PANEL_WIDTH - 20f, buttonHeight);
        currentButtonTopY -= uiElementTotalHeight;
        playButton = new Rectangle(10f, currentButtonTopY, UI_PANEL_WIDTH - 20f, buttonHeight);

        // --- Backgrounds Section ---
        currentButtonTopY -= (sectionTitleSpacing + sectionPadding); // Space for "Backgrounds:" title
        for (int i = 0; i < availableBackgroundPaths.size; i++) {
            currentButtonTopY -= uiElementTotalHeight;
            Rectangle button = new Rectangle(10f, currentButtonTopY, UI_PANEL_WIDTH - 20f, buttonHeight);
            backgroundSelectorButtons.add(button);
        }
    }

    public void resize(int width, int height) {
        // Re-initialize UI, which recalculates positions based on new height
        initializeUI();
    }

    private void executeCommand(EditorCommand command) {
        command.execute();
        undoStack.addLast(command);
        if (undoStack.size() > MAX_HISTORY_SIZE) undoStack.removeFirst();
        redoStack.clear();
        hasUnappliedChanges = true;
        selectedPlatform = null; // Deselect after any command
        selectedEnemy = null;    // Deselect after any command
    }

    private void undo() {
        if (!undoStack.isEmpty()) {
            EditorCommand command = undoStack.removeLast();
            command.undo();
            redoStack.addLast(command);
            if (redoStack.size() > MAX_HISTORY_SIZE) redoStack.removeFirst();
            hasUnappliedChanges = true;
            selectedPlatform = null;
            selectedEnemy = null;
        }
    }

    private void redo() {
        if (!redoStack.isEmpty()) {
            EditorCommand command = redoStack.removeLast();
            command.execute();
            undoStack.addLast(command);
            if (undoStack.size() > MAX_HISTORY_SIZE) undoStack.removeFirst();
            hasUnappliedChanges = true;
            selectedPlatform = null;
            selectedEnemy = null;
        }
    }

    public void update(OrthographicCamera camera) {
        mousePos.set(Gdx.input.getX(), Gdx.input.getY(), 0);
        camera.unproject(mousePos); // Convert screen coordinates to world coordinates

        if (currentUIMode == EditorUIMode.LEVEL_PREVIEW) {
            if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
                currentUIMode = EditorUIMode.EDITING;
            }
            return; // No editor updates in preview mode
        }

        // Snapped mouse position for grid alignment
        float snappedX = Math.round(mousePos.x / GRID_SIZE) * GRID_SIZE;
        float snappedY = Math.round(mousePos.y / GRID_SIZE) * GRID_SIZE;

        // Update placement preview rectangle
        if (showPlacementPreview && mousePos.x > UI_PANEL_WIDTH) { // Only show preview in game world area
            if (currentTool == EditorTool.PLATFORM && isDragging) {
                float width = Math.abs(snappedX - dragStartX) + GRID_SIZE;
                float height = Math.abs(snappedY - dragStartY) + GRID_SIZE;
                float x = Math.min(snappedX, dragStartX);
                float y = Math.min(snappedY, dragStartY);
                placementPreviewRect.set(x, y, width, height);
            } else { // Single block preview for non-dragging platforms or enemies
                placementPreviewRect.set(snappedX, snappedY, GRID_SIZE, GRID_SIZE);
            }
        } else {
            placementPreviewRect.set(0,0,0,0); // Hide preview if mouse is over UI or preview is off
        }
        handleEditorInput(snappedX, snappedY, camera);
    }

    private void handleEditorInput(float snappedX, float snappedY, OrthographicCamera camera) {
        boolean ctrlPressed = Gdx.input.isKeyPressed(Input.Keys.CONTROL_LEFT) || Gdx.input.isKeyPressed(Input.Keys.CONTROL_RIGHT);
        if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.Z)) { undo(); return; }
        if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.Y)) { redo(); return; }

        // Camera movement
        float camSpeed = 300 * Gdx.graphics.getDeltaTime();
        if (Gdx.input.isKeyPressed(Input.Keys.A) || Gdx.input.isKeyPressed(Input.Keys.LEFT)) camera.position.x -= camSpeed;
        if (Gdx.input.isKeyPressed(Input.Keys.D) || Gdx.input.isKeyPressed(Input.Keys.RIGHT)) camera.position.x += camSpeed;
        if (Gdx.input.isKeyPressed(Input.Keys.W) || Gdx.input.isKeyPressed(Input.Keys.UP)) camera.position.y += camSpeed;
        if (Gdx.input.isKeyPressed(Input.Keys.S) || Gdx.input.isKeyPressed(Input.Keys.DOWN)) camera.position.y -= camSpeed;
        camera.update();


        if (Gdx.input.isButtonJustPressed(Input.Buttons.LEFT)) handleLeftClick(snappedX, snappedY);
        if (Gdx.input.isButtonJustPressed(Input.Buttons.RIGHT)) handleRightClick(snappedX, snappedY);

        // Handle platform dragging release
        if (currentTool == EditorTool.PLATFORM && !Gdx.input.isButtonPressed(Input.Buttons.LEFT) && isDragging) {
            isDragging = false;
            if (placementPreviewRect.width >= GRID_SIZE && placementPreviewRect.height >= GRID_SIZE && mousePos.x > UI_PANEL_WIDTH) {
                Level.PlatformData newPlatform = new Level.PlatformData(
                    placementPreviewRect.x, placementPreviewRect.y, placementPreviewRect.width, placementPreviewRect.height, selectedPlatformType
                );
                executeCommand(new AddPlatformCommand(currentLevel, newPlatform));
            }
        }

        if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.S)) saveLevel();
        if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.L)) loadLevel();

        // Hotkeys for tools/types (Example)
        if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_1)) { currentTool = EditorTool.PLATFORM; selectedPlatformType = Platform.PlatformType.GROUND; }
        if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_2)) { currentTool = EditorTool.PLATFORM; selectedPlatformType = Platform.PlatformType.GRAVEL_BLOCK; }
        if (Gdx.input.isKeyJustPressed(Input.Keys.G)) { currentTool = EditorTool.GOOMBA; } // G for Goomba

        if (Gdx.input.isKeyJustPressed(Input.Keys.DEL) || Gdx.input.isKeyJustPressed(Input.Keys.BACKSPACE)) {
            if (selectedPlatform != null) {
                executeCommand(new RemovePlatformCommand(currentLevel, selectedPlatform));
                // selectedPlatform already set to null by executeCommand
            } else if (selectedEnemy != null) {
                executeCommand(new RemoveEnemyCommand(currentLevel, selectedEnemy));
                // selectedEnemy already set to null by executeCommand
            }
        }
    }

    private void handleLeftClick(float snappedX, float snappedY) {
        Vector3 screenPos = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0); // Screen coordinates for UI buttons

        // Check Platform Type Buttons
        for (int i = 0; i < platformTypeButtons.size; i++) {
            if (isScreenButtonClicked(platformTypeButtons.get(i), screenPos)) {
                currentTool = EditorTool.PLATFORM;
                selectedPlatformType = buttonPlatformTypes.get(i);
                return;
            }
        }
        // Check Goomba Button
        if (isScreenButtonClicked(goombaButton, screenPos)) {
            currentTool = EditorTool.GOOMBA;
            return;
        }

        // Check other UI buttons
        if (isScreenButtonClicked(saveButton, screenPos)) { saveLevel(); return; }
        if (isScreenButtonClicked(loadButton, screenPos)) { loadLevel(); return; }
        if (isScreenButtonClicked(clearButton, screenPos)) { clearLevel(); return; }
        if (isScreenButtonClicked(previewButton, screenPos)) {
            currentUIMode = EditorUIMode.LEVEL_PREVIEW;
            selectedPlatform = null; selectedEnemy = null; isDragging = false;
            return;
        }
        if (isScreenButtonClicked(playButton, screenPos)) {
            // Main.java handles the actual switch via isPlayButtonClicked()
            return;
        }

        for (int i = 0; i < backgroundSelectorButtons.size; i++) {
            if (isScreenButtonClicked(backgroundSelectorButtons.get(i), screenPos)) {
                String newBgPath = availableBackgroundPaths.get(i);
                if (!newBgPath.equals(currentLevel.getBackgroundTexturePath())) {
                    currentLevel.setBackgroundTexturePath(newBgPath);
                    hasUnappliedChanges = true;
                }
                return;
            }
        }

        // If clicked on the game world area (not UI)
        if (mousePos.x > UI_PANEL_WIDTH) {
            selectedPlatform = null; // Deselect previous
            selectedEnemy = null;   // Deselect previous
            boolean clickedExisting = false;

            // Priority 1: Try selecting an existing platform
            for (Level.PlatformData platform : currentLevel.getPlatformData()) {
                Rectangle rect = new Rectangle(platform.x, platform.y, platform.width, platform.height);
                if (rect.contains(mousePos.x, mousePos.y)) {
                    selectedPlatform = platform;
                    clickedExisting = true;
                    currentTool = EditorTool.PLATFORM; // Good idea to switch to platform tool
                    break;
                }
            }
            // Priority 2: Try selecting an existing enemy (if no platform was clicked)
            if (!clickedExisting) {
                for (Level.EnemyData enemy : currentLevel.getEnemyData()) {
                    Rectangle rect = new Rectangle(enemy.x, enemy.y, GRID_SIZE, GRID_SIZE); // Use GRID_SIZE for clickable area
                    if (rect.contains(mousePos.x, mousePos.y)) {
                        selectedEnemy = enemy;
                        clickedExisting = true;
                        if ("GOOMBA".equals(enemy.type)) currentTool = EditorTool.GOOMBA;
                        // Add logic for other enemy types if necessary
                        break;
                    }
                }
            }

            // If nothing existing was clicked, try placing new item based on current tool
            if (!clickedExisting) {
                if (currentTool == EditorTool.PLATFORM) {
                    boolean shiftPressed = Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT);
                    if (selectedPlatformType == Platform.PlatformType.GROUND || shiftPressed) { // Drag for ground type or if shift is held
                        isDragging = true;
                        dragStartX = snappedX;
                        dragStartY = snappedY;
                        placementPreviewRect.set(snappedX, snappedY, GRID_SIZE, GRID_SIZE); // Initial preview for drag
                    } else { // Place single block for other platform types
                        Level.PlatformData newPlatform = new Level.PlatformData(
                            snappedX, snappedY, GRID_SIZE, GRID_SIZE, selectedPlatformType
                        );
                        executeCommand(new AddPlatformCommand(currentLevel, newPlatform));
                    }
                } else if (currentTool == EditorTool.GOOMBA) {
                    Level.EnemyData newEnemy = new Level.EnemyData(snappedX, snappedY, "GOOMBA");
                    executeCommand(new AddEnemyCommand(currentLevel, newEnemy));
                }
                // Add other tool placement logic here
            }
        }
    }

    private void handleRightClick(float snappedX, float snappedY) {
        if (mousePos.x <= UI_PANEL_WIDTH) return; // Ignore right clicks on UI panel

        // Try removing an enemy first (usually smaller targets)
        for (int i = currentLevel.getEnemyData().size - 1; i >= 0; i--) {
            Level.EnemyData enemy = currentLevel.getEnemyData().get(i);
            Rectangle rect = new Rectangle(enemy.x, enemy.y, GRID_SIZE, GRID_SIZE);
            if (rect.contains(mousePos.x, mousePos.y)) {
                executeCommand(new RemoveEnemyCommand(currentLevel, enemy));
                return;
            }
        }
        // Then try removing a platform
        for (int i = currentLevel.getPlatformData().size - 1; i >= 0; i--) {
            Level.PlatformData platform = currentLevel.getPlatformData().get(i);
            Rectangle rect = new Rectangle(platform.x, platform.y, platform.width, platform.height);
            if (rect.contains(mousePos.x, mousePos.y)) {
                executeCommand(new RemovePlatformCommand(currentLevel, platform));
                return;
            }
        }
    }

    private boolean isScreenButtonClicked(Rectangle button, Vector3 screenPos) {
        // Convert Gdx.input.getY() (origin top-left) to UI's ortho Y (origin bottom-left)
        float GdxYtoUIY = Gdx.graphics.getHeight() - screenPos.y;
        return button.contains(screenPos.x, GdxYtoUIY);
    }

    public void renderEditorElements(SpriteBatch batch, OrthographicCamera camera) {
        shapeRenderer.setProjectionMatrix(camera.combined);
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer.setColor(0.3f, 0.3f, 0.3f, 0.5f); // Grid color

        // Render Grid
        float viewLeft = camera.position.x - camera.viewportWidth / 2f * camera.zoom;
        float viewRight = camera.position.x + camera.viewportWidth / 2f * camera.zoom;
        float viewBottom = camera.position.y - camera.viewportHeight / 2f * camera.zoom;
        float viewTop = camera.position.y + camera.viewportHeight / 2f * camera.zoom;

        for (float x = Math.round(viewLeft / GRID_SIZE) * GRID_SIZE; x < viewRight; x += GRID_SIZE) {
            shapeRenderer.line(x, viewBottom, x, viewTop);
        }
        for (float y = Math.round(viewBottom / GRID_SIZE) * GRID_SIZE; y < viewTop; y += GRID_SIZE) {
            shapeRenderer.line(viewLeft, y, viewRight, y);
        }
        shapeRenderer.end(); // End grid rendering

        // Render Placed Enemies (using SpriteBatch for textures)
        if (goombaPreviewTexture != null) { // Check if texture loaded successfully
            batch.setProjectionMatrix(camera.combined);
            batch.begin();
            for (Level.EnemyData enemyData : currentLevel.getEnemyData()) {
                if ("GOOMBA".equals(enemyData.type)) {
                    batch.draw(goombaPreviewTexture, enemyData.x, enemyData.y, GRID_SIZE, GRID_SIZE);
                }
                // Add rendering for other enemy types here
            }
            batch.end();
        }

        // Highlights for selected items (after batch rendering)
        shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
        if (selectedPlatform != null) {
            shapeRenderer.setColor(Color.YELLOW);
            shapeRenderer.rect(selectedPlatform.x, selectedPlatform.y, selectedPlatform.width, selectedPlatform.height);
        }
        if (selectedEnemy != null) {
            shapeRenderer.setColor(Color.CYAN); // Different color for enemy selection
            shapeRenderer.rect(selectedEnemy.x, selectedEnemy.y, GRID_SIZE, GRID_SIZE);
        }
        shapeRenderer.end();


        // Render Placement Preview (outline and texture if applicable)
        if (showPlacementPreview && mousePos.x > UI_PANEL_WIDTH && placementPreviewRect.width > 0 && placementPreviewRect.height > 0) {
            if (isDragging || !Gdx.input.isButtonPressed(Input.Buttons.LEFT)) { // Show if dragging or if mouse button is up
                // Draw outline
                shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
                shapeRenderer.setColor(0.5f, 0.5f, 1f, 0.5f); // Preview outline color
                shapeRenderer.rect(placementPreviewRect.x, placementPreviewRect.y, placementPreviewRect.width, placementPreviewRect.height);
                shapeRenderer.end();

                // Draw texture preview if Goomba tool is active
                if (currentTool == EditorTool.GOOMBA && goombaPreviewTexture != null) {
                    batch.setProjectionMatrix(camera.combined);
                    batch.begin();
                    batch.setColor(1, 1, 1, 0.5f); // Semi-transparent
                    batch.draw(goombaPreviewTexture, placementPreviewRect.x, placementPreviewRect.y, GRID_SIZE, GRID_SIZE);
                    batch.setColor(1, 1, 1, 1f); // Reset color
                    batch.end();
                }
                // Add texture previews for other tools if needed
            }
        }
        drawUIScreenPanel(batch); // Draw UI panel last, on top of everything
    }

    private void drawUIScreenPanel(SpriteBatch batch) {
        batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        shapeRenderer.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());

        // Draw UI Panel Background
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.setColor(0.1f, 0.1f, 0.1f, 0.9f);
        shapeRenderer.rect(0, 0, UI_PANEL_WIDTH, Gdx.graphics.getHeight());
        shapeRenderer.end();

        batch.begin(); // Begin batch for all text rendering
        font.setColor(Color.WHITE);
        font.getData().setScale(0.85f); // Slightly smaller font for UI text

        float currentTextY = Gdx.graphics.getHeight() - 15f;
        float titleSpacing = 15f;
        float buttonTextOffsetY = (platformTypeButtons.first().height - font.getCapHeight()) / 2f + 2f; // Center text in button

        shapeRenderer.begin(ShapeRenderer.ShapeType.Line); // Begin for all button borders

        // --- Platforms Section ---
        font.draw(batch, "Platforms:", 10, currentTextY);
        currentTextY -= titleSpacing;
        for (int i = 0; i < platformTypeButtons.size; i++) {
            Rectangle button = platformTypeButtons.get(i);
            Platform.PlatformType type = buttonPlatformTypes.get(i);
            // Position text based on updated button Y from initializeUI
            font.draw(batch, type.toString(), button.x + 5, button.y + buttonTextOffsetY);
            shapeRenderer.setColor((currentTool == EditorTool.PLATFORM && type == selectedPlatformType) ? Color.GREEN : Color.WHITE);
            shapeRenderer.rect(button.x, button.y, button.width, button.height);
        }
        currentTextY = platformTypeButtons.isEmpty() ? currentTextY : platformTypeButtons.peek().y -5f;


        // --- Enemies Section ---
        font.draw(batch, "Enemies:", 10, currentTextY);
        currentTextY -= titleSpacing;
        // Goomba Button Text & Border
        font.draw(batch, "Goomba (G)", goombaButton.x + 5, goombaButton.y + buttonTextOffsetY);
        shapeRenderer.setColor((currentTool == EditorTool.GOOMBA) ? Color.GREEN : Color.WHITE);
        shapeRenderer.rect(goombaButton.x, goombaButton.y, goombaButton.width, goombaButton.height);
        currentTextY = goombaButton.y - 5f;

        // --- Controls Section ---
        font.draw(batch, "Controls:", 10, currentTextY);
        currentTextY -= titleSpacing;
        drawButtonWithText(shapeRenderer, batch, saveButton, "Save (Ctrl+S)", Color.WHITE, buttonTextOffsetY);
        drawButtonWithText(shapeRenderer, batch, loadButton, "Load (Ctrl+L)", Color.WHITE, buttonTextOffsetY);
        drawButtonWithText(shapeRenderer, batch, clearButton, "Clear Level", Color.WHITE, buttonTextOffsetY);
        drawButtonWithText(shapeRenderer, batch, previewButton, "Preview Level", Color.ORANGE, buttonTextOffsetY);
        drawButtonWithText(shapeRenderer, batch, playButton, "Play Mode (P)", Color.LIME, buttonTextOffsetY);
        currentTextY = playButton.y - 5f;

        // --- Backgrounds Section ---
        font.draw(batch, "Backgrounds:", 10, currentTextY);
        // currentTextY -= titleSpacing; // No, buttons are drawn from their own Y
        for (int i = 0; i < backgroundSelectorButtons.size; i++) {
            Rectangle button = backgroundSelectorButtons.get(i);
            String bgName = availableBackgroundNames.get(i);
            String bgPath = availableBackgroundPaths.get(i);
            Color bgColor = bgPath.equals(currentLevel.getBackgroundTexturePath()) ? Color.CYAN : Color.LIGHT_GRAY;
            drawButtonWithText(shapeRenderer, batch, button, bgName, bgColor, buttonTextOffsetY);
        }
        currentTextY = backgroundSelectorButtons.isEmpty() ? currentTextY : backgroundSelectorButtons.peek().y - 20f;


        shapeRenderer.end(); // End for all button borders

        // Instructions Text (at the bottom)
        float instructionBaseY = 150; // Start higher up and draw downwards
        if (!backgroundSelectorButtons.isEmpty()) {
            instructionBaseY = Math.min(instructionBaseY, backgroundSelectorButtons.peek().y - 25f);
        } else if (goombaButton != null){
            instructionBaseY = Math.min(instructionBaseY, goombaButton.y - 25f);
        }


        float lineHeight = 15f;
        if (instructionBaseY > lineHeight * 6) { // Ensure enough space for instructions
            font.draw(batch, "Tool: " + currentTool.toString() +
                    (currentTool == EditorTool.PLATFORM ? " (" + selectedPlatformType.toString() + ")" : ""),
                10, instructionBaseY); instructionBaseY -= lineHeight;
            font.draw(batch, "Ctrl+Z: Undo, Ctrl+Y: Redo", 10, instructionBaseY); instructionBaseY -= lineHeight;
            font.draw(batch, "Left Click: Place/Select", 10, instructionBaseY); instructionBaseY -= lineHeight;
            font.draw(batch, "Shift+Drag: Resize Ground", 10, instructionBaseY); instructionBaseY -= lineHeight;
            font.draw(batch, "Right Click: Remove", 10, instructionBaseY); instructionBaseY -= lineHeight;
            font.draw(batch, "Arrow/WASD: Move Cam", 10, instructionBaseY); instructionBaseY -= lineHeight;
            font.draw(batch, "1-2: Platform Hotkeys", 10, instructionBaseY); instructionBaseY -= lineHeight;
            font.draw(batch, "G: Goomba Hotkey", 10, instructionBaseY); instructionBaseY -= lineHeight;
            font.draw(batch, "DEL/Bksp: Delete Sel.", 10, instructionBaseY);
        }

        batch.end(); // End batch for all text rendering
        font.getData().setScale(1f); // Reset font scale
    }

    // Helper to draw button and its text, reducing repetition
    private void drawButtonWithText(ShapeRenderer sr, SpriteBatch batch, Rectangle button, String text, Color borderColor, float textOffsetY) {
        font.draw(batch, text, button.x + 5, button.y + textOffsetY);
        sr.setColor(borderColor);
        sr.rect(button.x, button.y, button.width, button.height);
    }
    // Overload for drawButtonUI to fit the new pattern
    private void drawButtonUI(ShapeRenderer sr, SpriteBatch batch, Rectangle button, String text) {
        float textOffsetY = (button.height - font.getCapHeight()) / 2f + 2f;
        drawButtonWithText(sr, batch, button, text, sr.getColor(), textOffsetY);
    }


    public void renderPreviewNotification(SpriteBatch batch) {
        batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        batch.begin();
        notificationFont.setColor(Color.YELLOW);
        notificationFont.draw(batch, "Preview Mode - Press ESC to exit", 20, Gdx.graphics.getHeight() - 20);
        batch.end();
    }

    private void saveLevel() {
        Json json = new Json();
        // Ensure "levels" directory exists
        FileHandle dir = Gdx.files.local("levels/");
        if (!dir.exists()) {
            dir.mkdirs();
        }
        FileHandle file = Gdx.files.local("levels/" + currentLevel.getName() + ".json");
        file.writeString(json.prettyPrint(currentLevel), false);
        Gdx.app.log("LevelEditor", "Level saved: " + file.path());
        hasUnappliedChanges = false; // Changes are now saved
    }

    private void loadLevel() {
        // Simple prompt for now. For a real app, use a file chooser dialog.
        String levelName = currentLevel.getName(); // Or prompt user for a name
        FileHandle file = Gdx.files.local("levels/" + levelName + ".json");
        if (file.exists()) {
            Json json = new Json();
            try {
                currentLevel = json.fromJson(Level.class, file.readString());
                undoStack.clear();
                redoStack.clear();
                hasUnappliedChanges = false; // Freshly loaded level has no unsaved changes relative to file
                selectedPlatform = null;
                selectedEnemy = null;
                Gdx.app.log("LevelEditor", "Level loaded: " + file.path() + ". Undo/Redo history cleared.");
            } catch (Exception e) {
                Gdx.app.error("LevelEditor", "Failed to load/parse level: " + file.path(), e);
                // Optionally, revert to a new empty level or keep the current one.
            }
        } else {
            Gdx.app.log("LevelEditor", "Level file not found: " + file.path());
        }
    }

    private void clearLevel() {
        Array<Level.PlatformData> platformsToBackup = new Array<>(currentLevel.getPlatformData());
        // Also backup enemies if ClearLevelCommand should handle them.
        // For now, ClearLevelCommand only handles platforms.
        Level.PlatformData defaultGroundInstance = new Level.PlatformData(
            0, 0, GRID_SIZE * DEFAULT_GROUND_WIDTH_MULTIPLIER, GRID_SIZE * DEFAULT_GROUND_HEIGHT_MULTIPLIER, Platform.PlatformType.GROUND
        );
        // Create a new command that also clears enemies
        // For simplicity, we'll just clear directly and make a new ClearLevelAndEnemiesCommand if full undo is needed.
        executeCommand(new ClearLevelCommand(currentLevel, platformsToBackup, defaultGroundInstance)); // This only clears platforms
        currentLevel.getEnemyData().clear(); // Manually clear enemies
        hasUnappliedChanges = true; // Mark as changed after clear
    }

    public Level getCurrentLevel() { return currentLevel; }
    public EditorUIMode getCurrentUIMode() { return currentUIMode; }
    public boolean hasUnappliedChanges() { return hasUnappliedChanges; }
    public void clearChangesFlag() { hasUnappliedChanges = false; }

    public boolean isPlayButtonClicked() {
        Vector3 screenPos = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0);
        if (playButton != null && Gdx.input.isButtonJustPressed(Input.Buttons.LEFT) &&
            isScreenButtonClicked(playButton, screenPos)) {
            // currentUIMode = EditorUIMode.EDITING; // This is handled by Main.java
            return true;
        }
        return false;
    }

    public void dispose() {
        if (shapeRenderer != null) shapeRenderer.dispose();
        if (font != null) font.dispose();
        if (notificationFont != null) notificationFont.dispose();
        if (enemyAtlasForEditor != null) enemyAtlasForEditor.dispose();
    }
}

================
File: core/src/main/java/io/github/game/Main.gwt.xml
================
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit 2.11.0//EN" "https://www.gwtproject.org/doctype/2.11.0/gwt-module.dtd">
<module>
  <!-- Paths to source are relative to this file and separated by slashes ('/'). -->
  <source path="" />

  <!-- Reflection includes may be needed for your code or library code. Each value is separated by periods ('.'). -->
  <!-- You can include a full package by not including the name of a type at the end. -->

</module>

================
File: core/src/main/java/io/github/game/Main.java
================
// File: core/src/main/java/io/github/game/Main.java
package io.github.game;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas; // Added for enemies
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.badlogic.gdx.utils.viewport.Viewport;
import io.github.game.enemies.Enemy;
import io.github.game.enemies.Goomba;

public class Main extends ApplicationAdapter {
    // World and Game Mechanics Constants
    private static final float WORLD_WIDTH = 800;
    private static final float WORLD_HEIGHT = 480;
    private static final float GRAVITY = -900f;
    private static final float MOVE_SPEED = 200f;
    private static final float JUMP_INITIAL_IMPULSE = 380f;
    private static final float JUMP_HOLD_GRAVITY_MULTIPLIER = 0.40f;
    private static final float MAX_JUMP_HOLD_TIME = 0.22f;
    public static final float SCALED_BLOCK_SIZE = 32f; // Potentially used by other classes
    private static final float PLAYER_STOMP_BOUNCE_VELOCITY = 250f; // How high Mario bounces after stomping

    // Core Game Objects
    private SpriteBatch batch;
    private OrthographicCamera camera;
    private Viewport viewport;
    private Player player;
    private Background background;
    private Array<Platform> activePlatforms;
    private Array<Enemy> activeEnemies; // For Goombas and other enemies
    private TextureAtlas enemyAtlas;    // Atlas for enemy sprites

    // Level Editor and Game State
    private LevelEditor levelEditor;
    private boolean editMode = true;
    private boolean gamePaused = false; // Used during player death animation, etc.

    // Utility
    private SoundManager soundManager;
    private Texture playerIdleTexture; // For editor preview of player start

    // Player jump state variables
    private boolean playerIsHoldingJumpKey = false;
    private float playerJumpHoldTimer = 0f;

    @Override
    public void create() {
        camera = new OrthographicCamera();
        viewport = new FitViewport(WORLD_WIDTH, WORLD_HEIGHT, camera);
        camera.position.set(WORLD_WIDTH / 2f, WORLD_HEIGHT / 2f, 0); // Center camera initially

        batch = new SpriteBatch();
        soundManager = SoundManager.getInstance();

        // Initialize Player
        player = new Player(150, Platform.GROUND_TILE_SIZE * 2); // Initial position

        // Load assets
        try {
            playerIdleTexture = new Texture("mario_sprites/playables/mario/mario_idle.png");
            enemyAtlas = new TextureAtlas(Gdx.files.internal("mario_sprites/enemies/atlas/enemies.atlas"));
        } catch (Exception e) {
            Gdx.app.error("MainCreate", "Failed to load essential textures (player idle or enemy atlas)", e);
            // Consider exiting or using placeholder assets if critical textures fail
        }

        background = new Background(); // Loads default background
        activePlatforms = new Array<>();
        activeEnemies = new Array<>();

        levelEditor = new LevelEditor();
        editMode = true; // Start in editor mode

        loadCurrentLevelData(); // Load initial level (platforms, enemies, player pos)
    }

    private void loadCurrentLevelData() {
        // Load data if editor has changes, or if it's the first load (e.g., activePlatforms is empty)
        // Forcing reload if switching to play mode ensures fresh start.
        // if (levelEditor.hasUnappliedChanges() || activePlatforms.isEmpty() || !editMode) {
        Level currentLoadedLevel = levelEditor.getCurrentLevel();

        // Create/Reset Platforms
        activePlatforms.clear();
        activePlatforms.addAll(currentLoadedLevel.createPlatforms());

        // Create/Reset Enemies
        activeEnemies.clear();
        if (enemyAtlas != null) { // Ensure atlas is loaded
            for (Level.EnemyData data : currentLoadedLevel.getEnemyData()) {
                if ("GOOMBA".equals(data.type)) {
                    activeEnemies.add(new Goomba(enemyAtlas, data.x, data.y));
                }
                // Add other enemy types here based on data.type
            }
        }

        background.setTexture(currentLoadedLevel.getBackgroundTexturePath());
        player.respawn(currentLoadedLevel.getPlayerStartX(), currentLoadedLevel.getPlayerStartY());
        player.getVelocity().set(0, 0); // Ensure velocity is zeroed on load/respawn

        levelEditor.clearChangesFlag();
        gamePaused = false; // Ensure game is not paused when loading/reloading level data
        // }
    }

    @Override
    public void render() {
        Gdx.gl.glClearColor(0.4f, 0.7f, 1, 1); // Blue sky color
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        float deltaTime = Gdx.graphics.getDeltaTime();

        // Toggle between Edit and Play mode
        if (Gdx.input.isKeyJustPressed(Input.Keys.P) || (editMode && levelEditor.isPlayButtonClicked())) {
            toggleFullEditPlayMode();
        }

        if (editMode) {
            // In edit mode, ensure the view reflects the latest editor state
            if(levelEditor.hasUnappliedChanges()){ // Only reload if editor explicitly marked changes
                loadCurrentLevelData();
            }
            levelEditor.update(camera); // Update editor logic (camera movement, UI interaction)

            if (levelEditor.getCurrentUIMode() == LevelEditor.EditorUIMode.EDITING) {
                camera.update(); // Editor camera might be controlled independently
                batch.setProjectionMatrix(camera.combined);
                batch.begin();
                background.render(batch, camera);
                for (Platform item : activePlatforms) item.render(batch);
                // Enemies are rendered by levelEditor.renderEditorElements using previews
                batch.end();
                levelEditor.renderEditorElements(batch, camera); // Renders grid, UI, previews
            } else if (levelEditor.getCurrentUIMode() == LevelEditor.EditorUIMode.LEVEL_PREVIEW) {
                // Level Preview Mode (player is static, camera might focus on player start)
                Level currentLevel = levelEditor.getCurrentLevel();
                background.setTexture(currentLevel.getBackgroundTexturePath()); // Ensure preview bg is correct

                // Simplified camera for preview - centers on player start or a bit ahead
                float targetX = currentLevel.getPlayerStartX() + Player.PLAYER_WIDTH / 2f;
                float targetY = currentLevel.getPlayerStartY() + Player.PLAYER_HEIGHT / 2f;
                camera.position.set(targetX + 100, Math.max(WORLD_HEIGHT / 2f, targetY + 50), 0);
                camera.update();

                batch.setProjectionMatrix(camera.combined);
                batch.begin();
                background.render(batch, camera);
                for (Platform p : activePlatforms) p.render(batch);
                for (Enemy enemy : activeEnemies) enemy.render(batch); // Render enemies in preview
                if (playerIdleTexture != null) { // Draw static player preview
                    batch.draw(playerIdleTexture, currentLevel.getPlayerStartX(), currentLevel.getPlayerStartY(), Player.PLAYER_WIDTH, Player.PLAYER_HEIGHT);
                }
                batch.end();
                levelEditor.renderPreviewNotification(batch); // "Preview Mode - ESC to exit"
            }
        } else { // Play Mode
            if (!gamePaused) {
                updateGameLogic(deltaTime);
            } else { // Game is paused (e.g., during player death animation)
                player.update(deltaTime); // Allow player's death animation to proceed
                // Some enemies might continue minimal updates (e.g., stomp animation)
                for (int i = activeEnemies.size - 1; i >= 0; i--) {
                    Enemy enemy = activeEnemies.get(i);
                    if (enemy.getCurrentState() == Enemy.EnemyState.STOMPED) {
                        enemy.update(deltaTime, activePlatforms, player); // Minimal update for stomp
                        if (!enemy.isAlive()) {
                            activeEnemies.removeIndex(i);
                        }
                    }
                }
            }

            // Check for player death animation completion
            if (player.getCurrentState() == Player.State.DEATH && player.getStateTimer() > Player.DEATH_ANIMATION_DURATION) {
                respawnPlayerAndResetLevel(); // This will also set gamePaused = false
            }

            // Camera follows player in play mode
            // A little ahead of the player, and doesn't go below a certain Y
            camera.position.x = player.getPosition().x + Player.PLAYER_WIDTH / 2f + 100f;
            camera.position.y = Math.max(WORLD_HEIGHT / 2f, player.getPosition().y + Player.PLAYER_HEIGHT / 2f - WORLD_HEIGHT / 4f + 50f);
            // Prevent camera from going too far left/right (level bounds if they exist)
            camera.position.x = Math.max(camera.viewportWidth / 2f, camera.position.x);
            camera.position.y = Math.max(camera.viewportHeight / 2f, camera.position.y);
            camera.update();

            // Rendering game objects
            batch.setProjectionMatrix(camera.combined);
            batch.begin();
            background.render(batch, camera);
            for (Platform item : activePlatforms) item.render(batch);
            for (Enemy enemy : activeEnemies) enemy.render(batch);
            player.render(batch);
            batch.end();
        }
    }

    private void toggleFullEditPlayMode() {
        editMode = !editMode;
        if (editMode) {
            soundManager.stopMusic(); // Stop game music when returning to editor
            gamePaused = false; // Ensure game is unpaused
            System.out.println("Switched to EDITOR MODE");
            // Data is already reflective of editor; no need to load unless specific logic requires.
            // loadCurrentLevelData(); // Can be called to ensure editor is 100% synced if needed
        } else { // Switching to Play Mode
            levelEditor.clearChangesFlag(); // Mark editor changes as "applied" for this play session
            loadCurrentLevelData(); // Crucial: Load the latest level setup from editor

            Level currentLevel = levelEditor.getCurrentLevel();
            // Player state (pos, vel, etc.) is reset within loadCurrentLevelData via player.respawn()

            if (currentLevel.getBackgroundMusic() != null && !currentLevel.getBackgroundMusic().isEmpty()) {
                soundManager.playMusic(currentLevel.getBackgroundMusic(), currentLevel.getMusicVolume());
            } else {
                soundManager.stopMusic();
            }
            gamePaused = false;
            playerIsHoldingJumpKey = false; // Reset jump state
            playerJumpHoldTimer = 0f;
            System.out.println("Switched to PLAY MODE");
        }
    }

    private void updateGameLogic(float deltaTime) {
        if (player.getCurrentState() == Player.State.DEATH) {
            gamePaused = true; // Keep game logic paused
            // Player's own update method handles its death animation movement
            return;
        }

        handlePlayerInput(deltaTime);

        // Apply gravity and jump hold force to player
        float effectiveGravity = GRAVITY;
        boolean jumpKeyIsCurrentlyHeld = Gdx.input.isKeyPressed(Input.Keys.UP) ||
            Gdx.input.isKeyPressed(Input.Keys.W) ||
            Gdx.input.isKeyPressed(Input.Keys.SPACE);

        if (playerIsHoldingJumpKey && jumpKeyIsCurrentlyHeld && player.getVelocity().y > 0 && playerJumpHoldTimer < MAX_JUMP_HOLD_TIME) {
            effectiveGravity = GRAVITY * JUMP_HOLD_GRAVITY_MULTIPLIER;
            playerJumpHoldTimer += deltaTime;
        } else {
            playerIsHoldingJumpKey = false; // Stop jump hold boost if key released, timer expired, or falling
        }
        player.getVelocity().y += effectiveGravity * deltaTime;

        // Update player position and check platform collisions
        player.getPosition().x += player.getVelocity().x * deltaTime;
        player.getBounds().setX(player.getPosition().x);
        checkHorizontalCollisions(player, activePlatforms);

        player.getPosition().y += player.getVelocity().y * deltaTime;
        player.getBounds().setY(player.getPosition().y);
        checkVerticalCollisions(player, activePlatforms);

        player.update(deltaTime); // Update player's internal state (animation timers, etc.)
        collectCoins();

        // Update Enemies
        for (int i = activeEnemies.size - 1; i >= 0; i--) {
            Enemy enemy = activeEnemies.get(i);
            enemy.update(deltaTime, activePlatforms, player); // Pass platforms for enemy AI/collision
            if (!enemy.isAlive() && enemy.getCurrentState() == Enemy.EnemyState.DEAD) { // Ensure stomp anim finished
                activeEnemies.removeIndex(i);
            }
        }
        checkPlayerEnemyCollisions(); // Check interactions after player and enemies have moved

        // Player fall death (if not already dying)
        if (player.getPosition().y < -Player.PLAYER_HEIGHT * 2 && player.getCurrentState() != Player.State.DEATH) {
            player.die(); // This sets state to DEATH and plays sound
            gamePaused = true; // Pause main game logic
        }
    }

    private void handlePlayerInput(float deltaTime) {
        if (player.getCurrentState() == Player.State.DEATH) return; // No input if player is dead

        // Horizontal Movement
        if (Gdx.input.isKeyPressed(Input.Keys.RIGHT) || Gdx.input.isKeyPressed(Input.Keys.D)) {
            player.getVelocity().x = MOVE_SPEED;
            player.setFacingRight(true);
            if (player.isGrounded()) player.setCurrentState(Player.State.WALKING);
        } else if (Gdx.input.isKeyPressed(Input.Keys.LEFT) || Gdx.input.isKeyPressed(Input.Keys.A)) {
            player.getVelocity().x = -MOVE_SPEED;
            player.setFacingRight(false);
            if (player.isGrounded()) player.setCurrentState(Player.State.WALKING);
        } else {
            player.getVelocity().x = 0;
            if (player.isGrounded() && player.getCurrentState() == Player.State.WALKING) {
                player.setCurrentState(Player.State.IDLE);
            }
        }

        // Jumping Input
        boolean jumpKeyPressedThisFrame = Gdx.input.isKeyJustPressed(Input.Keys.UP) ||
            Gdx.input.isKeyJustPressed(Input.Keys.W) ||
            Gdx.input.isKeyJustPressed(Input.Keys.SPACE);

        if (jumpKeyPressedThisFrame && player.isGrounded()) {
            player.getVelocity().y = JUMP_INITIAL_IMPULSE;
            player.setGrounded(false);
            player.setCurrentState(Player.State.JUMPING);
            soundManager.playJump();
            playerIsHoldingJumpKey = true;
            playerJumpHoldTimer = 0f;
        }

        // Ducking Input (from original code)
        boolean duckKeyPressed = Gdx.input.isKeyPressed(Input.Keys.DOWN) || Gdx.input.isKeyPressed(Input.Keys.S);
        if (duckKeyPressed) {
            if (player.isGrounded() && player.getCurrentState() != Player.State.DUCKING) {
                player.setCurrentState(Player.State.DUCKING);
                player.getVelocity().x *= 0.5f; // Slow down when ducking
            }
        } else {
            if (player.getCurrentState() == Player.State.DUCKING) {
                // TODO: Add check for ceiling clearance before standing up
                player.setCurrentState(player.getVelocity().x != 0 ? Player.State.WALKING : Player.State.IDLE);
            }
        }
    }

    private void checkHorizontalCollisions(Player gamePlayer, Array<Platform> platforms) {
        Rectangle playerRect = gamePlayer.getBounds();
        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue; // Coins are not solid
            Rectangle platformRect = platform.getBounds();
            if (playerRect.overlaps(platformRect)) {
                if (gamePlayer.getVelocity().x > 0) { // Moving right, collided with left side of platform
                    gamePlayer.getPosition().x = platformRect.x - playerRect.width;
                } else if (gamePlayer.getVelocity().x < 0) { // Moving left, collided with right side of platform
                    gamePlayer.getPosition().x = platformRect.x + platformRect.width;
                }
                gamePlayer.getVelocity().x = 0; // Stop horizontal movement
                gamePlayer.getBounds().setX(gamePlayer.getPosition().x); // Update bounds after position correction
            }
        }
    }

    private void checkVerticalCollisions(Player gamePlayer, Array<Platform> platforms) {
        gamePlayer.setGrounded(false); // Assume not grounded until a collision proves otherwise
        Rectangle playerRect = gamePlayer.getBounds();
        float playerOldY = gamePlayer.getPosition().y - (gamePlayer.getVelocity().y * Gdx.graphics.getDeltaTime()); // Approximate Y before this frame's Y movement

        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue;
            Rectangle platformRect = platform.getBounds();

            if (playerRect.overlaps(platformRect)) {
                // Landing on top of a platform
                if (gamePlayer.getVelocity().y <= 0 && playerOldY + playerRect.height * 0.5f >= platformRect.y + platformRect.height) {
                    gamePlayer.getPosition().y = platformRect.y + platformRect.height;
                    gamePlayer.getVelocity().y = 0;
                    gamePlayer.setGrounded(true);
                    if (gamePlayer.getCurrentState() == Player.State.JUMPING || gamePlayer.getCurrentState() == Player.State.FALLING) {
                        gamePlayer.setCurrentState(player.getVelocity().x == 0 ? Player.State.IDLE : Player.State.WALKING);
                    }
                }
                // Hitting head on bottom of a platform
                else if (gamePlayer.getVelocity().y > 0 && playerOldY <= platformRect.y) {
                    gamePlayer.getPosition().y = platformRect.y - playerRect.height;
                    gamePlayer.getVelocity().y = 0;
                    playerIsHoldingJumpKey = false; // Cancel jump hold if head is hit
                    if(gamePlayer.getCurrentState() == Player.State.JUMPING) gamePlayer.setCurrentState(Player.State.FALLING);
                    // TODO: Handle question block hit logic (spawn powerup, change block state)
                }
                gamePlayer.getBounds().setY(gamePlayer.getPosition().y); // Update bounds after position correction
            }
        }
    }

    private void checkPlayerEnemyCollisions() {
        if (player.getCurrentState() == Player.State.DEATH) return; // No enemy collisions if already dead

        Rectangle playerRect = player.getBounds();
        for (Enemy enemy : activeEnemies) {
            if (!enemy.isAlive() || enemy.getCurrentState() == Enemy.EnemyState.STOMPED) continue; // Ignore dead or being-stomped enemies

            if (playerRect.overlaps(enemy.getBounds())) {
                // Check for stomp: Player is falling and player's bottom is roughly above enemy's top
                boolean isStomp = player.getVelocity().y < 0 &&
                    (player.getBounds().y > enemy.getBounds().y + enemy.getBounds().height * 0.5f);
                // A more precise stomp check might compare player's previous bottom Y with enemy's current top Y.

                if (isStomp) {
                    enemy.onStompedBy(player); // Enemy handles its stomp reaction (sound, state change)
                    player.getVelocity().y = PLAYER_STOMP_BOUNCE_VELOCITY; // Player bounces up
                    player.setGrounded(false); // Player is airborne after bounce
                    // Sound for stomp is usually played by enemy.onStompedBy()
                } else {
                    // Player collided with enemy (not a stomp)
                    if (enemy.onCollisionWith(player)) { // Ask enemy if this collision is harmful to player
                        player.die(); // Player dies
                        gamePaused = true; // Pause game logic for death animation
                        break; // Player is dead, no need to check other enemies for this frame
                    }
                }
            }
        }
    }

    private void respawnPlayerAndResetLevel() {
        Gdx.app.log("Game", "Player Died. Respawning and Resetting Level.");
        gamePaused = false; // Unpause the game
        Level currentLevel = levelEditor.getCurrentLevel(); // Get fresh level specification

        // Reset Player to start position and state
        player.respawn(currentLevel.getPlayerStartX(), currentLevel.getPlayerStartY());

        // Reset Enemies: Clear existing and recreate from level data
        activeEnemies.clear();
        if (enemyAtlas != null) {
            for (Level.EnemyData data : currentLevel.getEnemyData()) {
                if ("GOOMBA".equals(data.type)) {
                    activeEnemies.add(new Goomba(enemyAtlas, data.x, data.y));
                }
                // Add other enemy types
            }
        }

        // Reset platforms if they have states (e.g., hit question blocks)
        // For now, platform states are not dynamically changed in a way that needs reset here,
        // but if they were, you'd either recreate them or call a reset method on each.
        // activePlatforms.clear();
        // activePlatforms.addAll(currentLevel.createPlatforms());

        // Reset camera to player's new position smoothly or instantly
        camera.position.x = player.getPosition().x + Player.PLAYER_WIDTH / 2f + 100f;
        camera.position.y = Math.max(WORLD_HEIGHT / 2f, player.getPosition().y + Player.PLAYER_HEIGHT / 2f);
        camera.update();

        // Restart level music
        if (currentLevel.getBackgroundMusic() != null && !currentLevel.getBackgroundMusic().isEmpty()) {
            soundManager.playMusic(currentLevel.getBackgroundMusic(), currentLevel.getMusicVolume());
        } else {
            soundManager.stopMusic();
        }
        playerIsHoldingJumpKey = false; // Reset jump state
        playerJumpHoldTimer = 0f;
    }

    private void collectCoins() {
        Rectangle playerRect = player.getBounds();
        for (int i = activePlatforms.size - 1; i >= 0; i--) {
            Platform item = activePlatforms.get(i);
            if (item.getType() == Platform.PlatformType.COIN && playerRect.overlaps(item.getBounds())) {
                activePlatforms.removeIndex(i); // Remove from active game list
                // Note: This does not remove it from the LevelData in the editor.
                // If coins should be permanently collected per level save, that logic needs to be added to Level and LevelEditor.
                soundManager.playCoinCollect();
                Gdx.app.log("Game", "Coin collected!");
            }
        }
    }

    @Override
    public void resize(int width, int height) {
        viewport.update(width, height, true); // Update viewport, true to center camera
        if (levelEditor != null) {
            levelEditor.resize(width, height); // Notify editor of resize for UI adjustments
        }
    }

    @Override
    public void dispose() {
        if (batch != null) batch.dispose();
        if (player != null) player.dispose();
        if (playerIdleTexture != null) playerIdleTexture.dispose();
        if (background != null) background.dispose();

        Platform.disposeSharedTextures(); // Dispose static textures in Platform class
        if (activePlatforms != null) activePlatforms.clear(); // Clear list

        if (enemyAtlas != null) enemyAtlas.dispose(); // Dispose enemy texture atlas
        if (activeEnemies != null) {
            for (Enemy enemy : activeEnemies) {
                enemy.dispose(); // Enemies currently don't have unique resources beyond atlas
            }
            activeEnemies.clear();
        }

        if (levelEditor != null) levelEditor.dispose();
        if (soundManager != null) soundManager.dispose();
    }
}

================
File: core/src/main/java/io/github/game/Platform.java
================
package io.github.game;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.ObjectMap;
import com.badlogic.gdx.Gdx;

public class Platform {
    private Rectangle bounds;
    private PlatformType type;
    private Texture singleBlockTexture;
    private Powerup.PowerupType containedPowerup;
    private boolean hasBeenHit;
    private String uniqueId;

    // Visual size of each ground tile component
    public static final int GROUND_TILE_SIZE = 32;

    // Static textures for ground composition
    private static Texture texGrassCornerLeft;
    private static Texture texGrassMiddle;
    private static Texture texGrassCornerRight;
    private static Texture texDirtMiddle;
    private static Texture texQuestionBlockEmpty;

    // Static map for textures
    private static ObjectMap<PlatformType, Texture> otherBlockTextures;

    public enum PlatformType {
        GROUND,
        GRAVEL_BLOCK,
        QUESTION_BLOCK,
        COIN
    }

    static {
        try {
            // Load ground composition textures
            texGrassCornerLeft = new Texture("mario_sprites/world/grass_left_corner.png");
            texGrassMiddle = new Texture("mario_sprites/world/grass_middle.png");
            texGrassCornerRight = new Texture("mario_sprites/world/grass_right_corner.png");
            texDirtMiddle = new Texture("mario_sprites/world/dirt_middle.png");

            // Initialize map and load other block textures
            otherBlockTextures = new ObjectMap<>();
            otherBlockTextures.put(PlatformType.GRAVEL_BLOCK, new Texture("mario_sprites/world/gravel.png"));

            String qbPath = "mario_sprites/world/question_block.png";
            if (Gdx.files.internal(qbPath).exists()) {
                otherBlockTextures.put(PlatformType.QUESTION_BLOCK, new Texture(qbPath));
            } else {
                System.err.println("Warning: Texture not found: " + qbPath);
                if (otherBlockTextures.containsKey(PlatformType.GRAVEL_BLOCK)) {
                    otherBlockTextures.put(PlatformType.QUESTION_BLOCK, otherBlockTextures.get(PlatformType.GRAVEL_BLOCK));
                }
            }

            // Try to load empty question block texture
            String emptyQbPath = "mario_sprites/world/question_block_empty.png";
            if (Gdx.files.internal(emptyQbPath).exists()) {
                texQuestionBlockEmpty = new Texture(emptyQbPath);
            } else {
                // Use gravel as fallback for empty question block
                texQuestionBlockEmpty = otherBlockTextures.get(PlatformType.GRAVEL_BLOCK);
            }

            String coinPath = "mario_sprites/world/coin.png";
            if (Gdx.files.internal(coinPath).exists()) {
                otherBlockTextures.put(PlatformType.COIN, new Texture(coinPath));
            } else {
                System.err.println("Warning: Texture not found: " + coinPath);
            }

        } catch (Exception e) {
            System.err.println("Fatal error loading platform textures: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public static Texture getTextureForType(PlatformType type) {
        if (type == PlatformType.GROUND) {
            return null;
        }
        return otherBlockTextures.get(type);
    }

    public Platform(float x, float y, float width, float height, PlatformType type) {
        this.bounds = new Rectangle(x, y, width, height);
        this.type = type;
        this.hasBeenHit = false;
        this.containedPowerup = null;
        this.uniqueId = x + "_" + y + "_" + type;

        if (type != PlatformType.GROUND) {
            this.singleBlockTexture = getTextureForType(type);

            if (this.singleBlockTexture == null) {
                System.err.println("Warning: Texture for type " + type + " is missing.");
                if (type != PlatformType.GRAVEL_BLOCK && getTextureForType(PlatformType.GRAVEL_BLOCK) != null) {
                    this.singleBlockTexture = getTextureForType(PlatformType.GRAVEL_BLOCK);
                }
            }
        }
    }

    public void setContainedPowerup(Powerup.PowerupType powerup) {
        this.containedPowerup = powerup;
    }

    public Powerup.PowerupType getContainedPowerup() {
        return containedPowerup;
    }

    public boolean hit() {
        if (type == PlatformType.QUESTION_BLOCK && !hasBeenHit) {
            hasBeenHit = true;
            return true;
        }
        return false;
    }

    public boolean hasBeenHit() {
        return hasBeenHit;
    }

    public String getUniqueId() {
        return uniqueId;
    }

    public void render(SpriteBatch batch) {
        switch (type) {
            case GROUND:
                renderGroundPlatform(batch);
                break;
            case GRAVEL_BLOCK:
            case COIN:
                renderSingleScaledBlock(batch);
                break;
            case QUESTION_BLOCK:
                renderQuestionBlock(batch);
                break;
            default:
                if (singleBlockTexture != null) {
                    batch.draw(singleBlockTexture, bounds.x, bounds.y, bounds.width, bounds.height);
                }
                break;
        }
    }

    private void renderQuestionBlock(SpriteBatch batch) {
        Texture textureToDraw;
        if (hasBeenHit && texQuestionBlockEmpty != null) {
            textureToDraw = texQuestionBlockEmpty;
        } else if (singleBlockTexture != null) {
            textureToDraw = singleBlockTexture;
        } else {
            return;
        }
        batch.draw(textureToDraw, bounds.x, bounds.y, bounds.width, bounds.height);
    }

    private void renderGroundPlatform(SpriteBatch batch) {
        if (texGrassCornerLeft == null || texGrassMiddle == null || texGrassCornerRight == null || texDirtMiddle == null) {
            System.err.println("Cannot render GROUND: one or more essential ground textures are missing.");
            return;
        }

        int numCols = (int) (bounds.width / GROUND_TILE_SIZE);
        int numRows = (int) (bounds.height / GROUND_TILE_SIZE);

        for (int row = 0; row < numRows; row++) {
            for (int col = 0; col < numCols; col++) {
                float tileX = bounds.x + col * GROUND_TILE_SIZE;
                float tileY = bounds.y + (numRows - 1 - row) * GROUND_TILE_SIZE;

                Texture currentTileToDraw;
                if (row == 0) {
                    if (numCols == 1) {
                        currentTileToDraw = texGrassMiddle;
                    } else if (col == 0) {
                        currentTileToDraw = texGrassCornerLeft;
                    } else if (col == numCols - 1) {
                        currentTileToDraw = texGrassCornerRight;
                    } else {
                        currentTileToDraw = texGrassMiddle;
                    }
                } else {
                    currentTileToDraw = texDirtMiddle;
                }
                batch.draw(currentTileToDraw, tileX, tileY, GROUND_TILE_SIZE, GROUND_TILE_SIZE);
            }
        }
    }

    private void renderSingleScaledBlock(SpriteBatch batch) {
        if (singleBlockTexture == null) {
            return;
        }
        batch.draw(singleBlockTexture, bounds.x, bounds.y, bounds.width, bounds.height);
    }

    public Rectangle getBounds() {
        return bounds;
    }

    public static void disposeSharedTextures() {
        if (texGrassCornerLeft != null) texGrassCornerLeft.dispose();
        if (texGrassMiddle != null) texGrassMiddle.dispose();
        if (texGrassCornerRight != null) texGrassCornerRight.dispose();
        if (texDirtMiddle != null) texDirtMiddle.dispose();
        if (texQuestionBlockEmpty != null) texQuestionBlockEmpty.dispose();

        if (otherBlockTextures != null) {
            for (Texture tex : otherBlockTextures.values()) {
                if (tex != null) tex.dispose();
            }
            otherBlockTextures.clear();
        }
        System.out.println("Platform shared textures disposed.");
    }

    public void dispose() {
        // No operation needed here as textures are static and shared.
    }

    public PlatformType getType() {
        return type;
    }
}

================
File: core/src/main/java/io/github/game/Player.java
================
// File: core/src/main/java/io/github/game/Player.java
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;

public class Player {

    private Texture deathTexture;
    public static final float DEATH_ANIMATION_DURATION = 1.5f;
    public enum State {
        IDLE, FALLING, WALKING, RUNNING, JUMPING, DUCKING, OPENING_DOOR, FULL_SPEED_JUMPING, DEATH, GROUND_POUNDING, GOING_DOWN_PIPE;
    }
    private Vector2 position;
    private Vector2 velocity;
    private boolean facingRight;
    private boolean grounded;
    private State currentState;
    private State previousState;
    private float stateTimer;

    public static final int PLAYER_WIDTH = 32;
    public static final int PLAYER_HEIGHT = 48;

    private Rectangle bounds;
    private Texture idleTexture;
    private Texture duckTexture;
    private Texture jumpTexture;
    private Texture walkTexture0;
    private Texture walkTexture1;
    private Texture walkTexture2;
    private Texture fallTexture;
    private Texture pipeTexture;
    private Texture lookUpTexture;
    private Animation<Texture> walkAnimation;

    public Player(float x, float y){
        position = new Vector2(x,y);
        velocity = new Vector2(0, 0);
        facingRight = true; // Player starts facing right
        grounded = false;
        currentState = State.IDLE;
        previousState = State.IDLE;
        bounds = new Rectangle(x, y, PLAYER_WIDTH, PLAYER_HEIGHT);
        idleTexture = new Texture("mario_sprites/playables/mario/mario_idle.png");
        walkTexture0 = new Texture("mario_sprites/playables/mario/mario_walk_0.png");
        walkTexture1 = new Texture("mario_sprites/playables/mario/mario_walk_1.png");
        walkTexture2 = new Texture("mario_sprites/playables/mario/mario_walk_2.png");
        duckTexture = new Texture("mario_sprites/playables/mario/mario_duck.png");
        jumpTexture = new Texture("mario_sprites/playables/mario/mario_jump.png");
        lookUpTexture = new Texture("mario_sprites/playables/mario/mario_look_up.png");
        pipeTexture = new Texture("mario_sprites/playables/mario/mario_pipe.png");
        fallTexture = new Texture("mario_sprites/playables/mario/mario_fall.png");
        if (Gdx.files.internal("mario_sprites/playables/mario/mario_death.png").exists()) {
            deathTexture = new Texture("mario_sprites/playables/mario/mario_fall.png");
        } else {
            deathTexture = fallTexture; // Placeholder
            Gdx.app.log("Player", "Mario death texture not found, using fall texture as placeholder.");
        }
        Array<Texture> walkFrames = new Array<Texture>();
        walkFrames.add(walkTexture0);
        walkFrames.add(walkTexture1);
        walkFrames.add(walkTexture2);
        walkAnimation = new Animation<Texture>(0.1f, walkFrames, Animation.PlayMode.LOOP);
    }

    public void update(float deltaTime){
        stateTimer = currentState == previousState ? stateTimer + deltaTime : 0;
        previousState = currentState;
        bounds.setPosition(position.x, position.y);
        // Condition for falling state based on vertical velocity and not being grounded
        if (velocity.y < 0 && !grounded && currentState != State.FALLING && currentState != State.DUCKING) {
            setCurrentState(State.FALLING);
        } else if (velocity.y == 0 && !grounded && currentState == State.JUMPING && currentState != State.FALLING) {
            // If apex of jump is reached (velocity.y is 0 but not yet falling due to gravity next frame)
            // it might be better to transition to FALLING when velocity.y < 0 consistently
        }
    }

    public void render(SpriteBatch batch){
        Texture currentFrame = getFrame();

        boolean flipX = !facingRight;

        batch.draw(
            currentFrame,
            position.x,
            position.y,
            PLAYER_WIDTH,
            PLAYER_HEIGHT,
            0,
            0,
            currentFrame.getWidth(),
            currentFrame.getHeight(),
            flipX,
            false
        );
    }

    public Texture getFrame() {
        switch(currentState){
            case WALKING:
                return walkAnimation.getKeyFrame(stateTimer, true);
            case JUMPING:
                return jumpTexture;
            case DUCKING:
                return duckTexture;
            case FALLING:
                return fallTexture;
            case IDLE:
            default:
                return idleTexture;
        }
    }

    public Vector2 getPosition() {
        return position;
    }

    public void setPosition(Vector2 position) {
        this.position = position;
    }

    public Vector2 getVelocity() {
        return velocity;
    }

    public void setVelocity(Vector2 velocity) {
        this.velocity = velocity;
    }

    public boolean isFacingRight() {
        return facingRight;
    }

    public void setFacingRight(boolean facingRight) {
        this.facingRight = facingRight;
    }

    public boolean isGrounded() {
        return grounded;
    }

    public void setGrounded(boolean grounded) {
        this.grounded = grounded;
    }

    public State getCurrentState() {
        return currentState;
    }

    public void setCurrentState(State currentState) {
        if (this.currentState != currentState) {
            this.currentState = currentState;
            this.stateTimer = 0; // Reset state timer on state change
        }
    }
    public void dispose(){
        idleTexture.dispose();
        walkTexture0.dispose();
        walkTexture1.dispose();
        walkTexture2.dispose();
        jumpTexture.dispose(); // was missing jumpTexture
        fallTexture.dispose();
        duckTexture.dispose();
        lookUpTexture.dispose();
        pipeTexture.dispose();
    }

    public State getPreviousState() {
        return previousState;
    }

    public void setPreviousState(State previousState) {
        this.previousState = previousState;
    }

    public float getStateTimer() {
        return stateTimer;
    }

    public void setStateTimer(float stateTimer) {
        this.stateTimer = stateTimer;
    }

    public Rectangle getBounds() {
        return bounds;
    }

    public void setBounds(Rectangle bounds) {
        this.bounds = bounds;
    }


    // ADDED: die method
    public void die() {
        if (currentState != State.DEATH) {
            setCurrentState(State.DEATH);
            velocity.set(0, 0); // Stop horizontal movementg
        }
    }
    public void respawn(float x, float y) {
        position.set(x, y);
        velocity.set(0, 0);
        setCurrentState(State.IDLE);
        grounded = true; // Assume respawn on ground
        facingRight = true;
        stateTimer = 0f;
    }
    public Texture getIdleTexture() { return idleTexture; }
    public void setIdleTexture(Texture idleTexture) { this.idleTexture = idleTexture; }
    public Texture getDuckTexture() { return duckTexture; }
    public void setDuckTexture(Texture duckTexture) { this.duckTexture = duckTexture; }
    public Texture getJumpTexture() { return jumpTexture; }
    public void setJumpTexture(Texture jumpTexture) { this.jumpTexture = jumpTexture; }
    public Texture getWalkTexture0() { return walkTexture0; }
    public void setWalkTexture0(Texture walkTexture0) { this.walkTexture0 = walkTexture0; }
    public Texture getWalkTexture1() { return walkTexture1; }
    public void setWalkTexture1(Texture walkTexture1) { this.walkTexture1 = walkTexture1; }
    public Texture getFallTexture() { return fallTexture; }
    public void setFallTexture(Texture fallTexture) { this.fallTexture = fallTexture; }
    public Texture getPipeTexture() { return pipeTexture; }
    public void setPipeTexture(Texture pipeTexture) { this.pipeTexture = pipeTexture; }
    public Texture getLookUpTexture() { return lookUpTexture; }
    public void setLookUpTexture(Texture lookUpTexture) { this.lookUpTexture = lookUpTexture; }
    public Animation<Texture> getWalkAnimation() { return walkAnimation; }
    public void setWalkAnimation(Animation<Texture> walkAnimation) { this.walkAnimation = walkAnimation; }
}

================
File: core/src/main/java/io/github/game/Powerup.java
================
package io.github.game;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;

public class Powerup {
    public enum PowerupType {
        CHICKEN("Chicken Power", "mario_sprites/items/chicken.png"),
        MUSHROOM("Mushroom", "mario_sprites/items/mushroom.png"),
        FIRE_FLOWER("Fire Flower", "mario_sprites/items/fire_flower.png"),
        STAR("Star", "mario_sprites/items/star.png");

        private final String name;
        private final String texturePath;

        PowerupType(String name, String texturePath) {
            this.name = name;
            this.texturePath = texturePath;
        }

        public String getName() { return name; }
        public String getTexturePath() { return texturePath; }
    }

    private PowerupType type;
    private Vector2 position;
    private Vector2 velocity;
    private Rectangle bounds;
    private Texture texture;
    private boolean active;
    private float animationTimer;

    public static final float POWERUP_SIZE = 32f;
    private static final float SPAWN_VELOCITY = 50f;
    private static final float MOVE_SPEED = 50f;

    public Powerup(PowerupType type, float x, float y) {
        this.type = type;
        this.position = new Vector2(x, y);
        this.velocity = new Vector2(MOVE_SPEED, SPAWN_VELOCITY);
        this.bounds = new Rectangle(x, y, POWERUP_SIZE, POWERUP_SIZE);
        this.active = true;
        this.animationTimer = 0;

        // Try to load texture, use placeholder if not found
        try {
            this.texture = new Texture(type.getTexturePath());
        } catch (Exception e) {
            // Use coin texture as placeholder if powerup texture doesn't exist
            try {
                this.texture = new Texture("mario_sprites/world/coin.png");
            } catch (Exception e2) {
                System.err.println("Warning: Could not load powerup texture: " + type.getTexturePath());
            }
        }
    }

    public void update(float deltaTime, Array<Platform> platforms) {
        if (!active) return;

        animationTimer += deltaTime;

        // Apply gravity
        velocity.y -= 400f * deltaTime;

        // Update position
        position.x += velocity.x * deltaTime;
        position.y += velocity.y * deltaTime;

        // Update bounds
        bounds.setPosition(position.x, position.y);

        // Check collisions with platforms
        for (Platform platform : platforms) {
            if (platform.getType() == Platform.PlatformType.COIN) continue;

            Rectangle platformBounds = platform.getBounds();
            if (bounds.overlaps(platformBounds)) {
                // Landing on top
                if (velocity.y < 0 && position.y > platformBounds.y) {
                    position.y = platformBounds.y + platformBounds.height;
                    velocity.y = 0;
                }
                // Hitting from side
                if (velocity.x > 0 && position.x < platformBounds.x) {
                    position.x = platformBounds.x - POWERUP_SIZE;
                    velocity.x = -MOVE_SPEED;
                } else if (velocity.x < 0 && position.x > platformBounds.x) {
                    position.x = platformBounds.x + platformBounds.width;
                    velocity.x = MOVE_SPEED;
                }
            }
        }

        // Remove if fallen off screen
        if (position.y < -100) {
            active = false;
        }
    }

    public void render(SpriteBatch batch) {
        if (!active || texture == null) return;

        // Add slight bobbing animation
        float yOffset = (float)Math.sin(animationTimer * 3) * 2;

        batch.draw(texture, position.x, position.y + yOffset, POWERUP_SIZE, POWERUP_SIZE);
    }

    public boolean checkCollision(Rectangle playerBounds) {
        return active && bounds.overlaps(playerBounds);
    }

    public void collect() {
        active = false;
        System.out.println(type.getName() + " collected!");
    }

    public PowerupType getType() { return type; }
    public boolean isActive() { return active; }
    public Vector2 getPosition() { return position; }
    public Rectangle getBounds() { return bounds; }

    public void dispose() {
        if (texture != null) {
            texture.dispose();
        }
    }
}

================
File: core/src/main/java/io/github/game/SoundManager.java
================
package io.github.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.utils.Disposable;

/**
 * Manages all sound effects and music in the game
 */
public class SoundManager implements Disposable {
    private static SoundManager instance;

    private Sound jumpSound;
    private Sound coinSound;
    private Sound growSound;
    private Sound itemGetSound;
    private Sound doorSound;
    private Sound powerupSound;

    private Music currentMusic;
    private String currentMusicPath;

    private Sound playerDeathSound; // ADDED
    private Sound enemyStompSound;  // ADDED
    private float masterVolume = 0.5f;
    private float musicVolume = 0.5f;
    private boolean soundEnabled = true;
    private boolean musicEnabled = true;

    private SoundManager() {
        loadSounds();
    }

    public static SoundManager getInstance() {
        if (instance == null) {
            instance = new SoundManager();
        }
        return instance;
    }

    private void loadSounds() {
        try {
            jumpSound = Gdx.audio.newSound(Gdx.files.internal("sounds/jump.wav"));
            coinSound = Gdx.audio.newSound(Gdx.files.internal("sounds/coin.wav"));

            // Load other sounds if they exist
            if (Gdx.files.internal("sounds/grow.wav").exists()) {
                growSound = Gdx.audio.newSound(Gdx.files.internal("sounds/grow.wav"));
            }
            if (Gdx.files.internal("sounds/item-get.wav").exists()) {
                itemGetSound = Gdx.audio.newSound(Gdx.files.internal("sounds/item-get.wav"));
            }
            if (Gdx.files.internal("sounds/door.wav").exists()) {
                doorSound = Gdx.audio.newSound(Gdx.files.internal("sounds/door.wav"));
            }
            if (Gdx.files.internal("sounds/powerup.wav").exists()) {
                powerupSound = Gdx.audio.newSound(Gdx.files.internal("sounds/powerup.wav"));
            }if (Gdx.files.internal("sounds/player_death.wav").exists()) {
                playerDeathSound = Gdx.audio.newSound(Gdx.files.internal("sounds/player_death.wav"));
            } else { Gdx.app.log("SoundManager", "player_death.wav not found."); }
            if (Gdx.files.internal("sounds/enemy_stomp.wav").exists()) {
                enemyStompSound = Gdx.audio.newSound(Gdx.files.internal("sounds/enemy_stomp.wav"));
            } else { Gdx.app.log("SoundManager", "enemy_stomp.wav not found."); }


        } catch (Exception e) {
            System.err.println("Error loading sounds: " + e.getMessage());
            soundEnabled = false;
        }
    }

    public void playMusic(String musicPath, float volume) {
        if (!musicEnabled) return;

        // Stop current music if playing
        if (currentMusic != null && currentMusic.isPlaying()) {
            currentMusic.stop();
        }

        // Don't reload if it's the same music
        if (musicPath != null && !musicPath.equals(currentMusicPath)) {
            try {
                if (currentMusic != null) {
                    currentMusic.dispose();
                }

                if (Gdx.files.internal(musicPath).exists()) {
                    currentMusic = Gdx.audio.newMusic(Gdx.files.internal(musicPath));
                    currentMusicPath = musicPath;
                    currentMusic.setLooping(true);
                    currentMusic.setVolume(volume * musicVolume);
                    currentMusic.play();
                } else {
                    System.err.println("Music file not found: " + musicPath);
                }
            } catch (Exception e) {
                System.err.println("Error loading music: " + e.getMessage());
                musicEnabled = false;
            }
        } else if (currentMusic != null) {
            currentMusic.setVolume(volume * musicVolume);
            if (!currentMusic.isPlaying()) {
                currentMusic.play();
            }
        }
    }

    public void stopMusic() {
        if (currentMusic != null) {
            currentMusic.stop();
        }
    }

    public void pauseMusic() {
        if (currentMusic != null) {
            currentMusic.pause();
        }
    }

    public void resumeMusic() {
        if (currentMusic != null && musicEnabled) {
            currentMusic.play();
        }
    }

    public void playJump() {
        if (soundEnabled && jumpSound != null) {
            jumpSound.play(masterVolume);
        }
    }

    public void playCoinCollect() {
        if (soundEnabled && coinSound != null) {
            coinSound.play(masterVolume * 0.8f);
        }
    }

    public void playPowerup() {
        if (soundEnabled) {
            if (powerupSound != null) {
                powerupSound.play(masterVolume);
            } else if (itemGetSound != null) {
                itemGetSound.play(masterVolume);
            }
        }
    }

    public void playGrow() {
        if (soundEnabled && growSound != null) {
            growSound.play(masterVolume);
        }
    }

    public void playItemGet() {
        if (soundEnabled && itemGetSound != null) {
            itemGetSound.play(masterVolume);
        }
    }

    public void playDoor() {
        if (soundEnabled && doorSound != null) {
            doorSound.play(masterVolume * 0.7f);
        }
    }

    public void setMasterVolume(float volume) {
        this.masterVolume = Math.max(0f, Math.min(1f, volume));
    }

    public float getMasterVolume() {
        return masterVolume;
    }

    public void setMusicVolume(float volume) {
        this.musicVolume = Math.max(0f, Math.min(1f, volume));
        if (currentMusic != null) {
            currentMusic.setVolume(musicVolume);
        }
    }

    public float getMusicVolume() {
        return musicVolume;
    }

    public void setSoundEnabled(boolean enabled) {
        this.soundEnabled = enabled;
    }

    public boolean isSoundEnabled() {
        return soundEnabled;
    }

    public void setMusicEnabled(boolean enabled) {
        this.musicEnabled = enabled;
        if (!enabled && currentMusic != null) {
            currentMusic.stop();
        } else if (enabled && currentMusic != null) {
            currentMusic.play();
        }
    }

    public boolean isMusicEnabled() {
        return musicEnabled;
    }

    @Override
    public void dispose() {
        if (jumpSound != null) jumpSound.dispose();
        if (coinSound != null) coinSound.dispose();
        if (growSound != null) growSound.dispose();
        if (itemGetSound != null) itemGetSound.dispose();
        if (doorSound != null) doorSound.dispose();
        if (powerupSound != null) powerupSound.dispose();
        if (currentMusic != null) currentMusic.dispose();
        instance = null;
    }
}

================
File: gradle.properties
================
org.gradle.daemon=false
org.gradle.jvmargs=-Xms512M -Xmx1G -Dfile.encoding=UTF-8 -Dconsole.encoding=UTF-8
org.gradle.configureondemand=false
gdxBasisUniversalVersion=1.0.2
kryoNetVersion=2.22.9
graalHelperVersion=2.0.1
gwtFrameworkVersion=2.11.0
gwtPluginVersion=1.1.29
enableGraalNative=false
gdxVersion=1.13.5
projectVersion=1.0.0

================
File: gradle/gradle-daemon-jvm.properties
================
#This file is generated by updateDaemonJvm
toolchainUrl.FREE_BSD.AARCH64=https\://api.foojay.io/disco/v3.0/ids/65aaef917b9f394804f058f1861225c9/redirect
toolchainUrl.FREE_BSD.X86_64=https\://api.foojay.io/disco/v3.0/ids/c728c5388b044fbdbbc44b0c6acee0df/redirect
toolchainUrl.LINUX.AARCH64=https\://api.foojay.io/disco/v3.0/ids/65aaef917b9f394804f058f1861225c9/redirect
toolchainUrl.LINUX.X86_64=https\://api.foojay.io/disco/v3.0/ids/c728c5388b044fbdbbc44b0c6acee0df/redirect
toolchainUrl.MAC_OS.AARCH64=https\://api.foojay.io/disco/v3.0/ids/dc463b4a8183dbcaa1b32544189c7f03/redirect
toolchainUrl.MAC_OS.X86_64=https\://api.foojay.io/disco/v3.0/ids/cb7dc109dd590ebca2d703734d23c9d3/redirect
toolchainUrl.UNIX.AARCH64=https\://api.foojay.io/disco/v3.0/ids/65aaef917b9f394804f058f1861225c9/redirect
toolchainUrl.UNIX.X86_64=https\://api.foojay.io/disco/v3.0/ids/c728c5388b044fbdbbc44b0c6acee0df/redirect
toolchainUrl.WINDOWS.AARCH64=https\://api.foojay.io/disco/v3.0/ids/43ee83889b87bacad5d3071ae7bbd349/redirect
toolchainUrl.WINDOWS.X86_64=https\://api.foojay.io/disco/v3.0/ids/2d57bdd1e17a18f83ff073919daa35ba/redirect
toolchainVersion=17

================
File: gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

================
File: gradlew
================
#!/bin/sh

#
# Copyright  2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions $var, ${var}, ${var:-default}, ${var+SET},
#           ${var#prefix}, ${var%suffix}, and $( cmd );
#         * compound commands having a testable exit status, especially case;
#         * various built-in commands including command, set, and ulimit.
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

================
File: gradlew.bat
================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

================
File: html/build.gradle
================
buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'org.gretty:gretty:3.1.5'
    classpath "org.docstr:gwt-gradle-plugin:$gwtPluginVersion"

  }
}
apply plugin: "gwt"
apply plugin: "war"
apply plugin: "org.gretty"

gwt {
  gwtVersion = "$gwtFrameworkVersion" // Should match the version used for building the GWT backend. See gradle.properties.
  maxHeapSize = '1G' // Default 256m is not enough for the GWT compiler. GWT is HUNGRY.
  minHeapSize = '1G'

  // Needs to be in front of "modules" below.
  src = files(file('src/main/java'), project(":core").file('src/main/java'))
  modules += ["io.github.game.GdxDefinition"]
  devModules += ["io.github.game.GdxDefinitionSuperdev"]
  project.webAppDirName = "webapp"

  compiler.strict = true
  compiler.disableCastChecking = true
  //// The next line can be useful to uncomment if you want output that hasn't been obfuscated.
//  compiler.style = org.docstr.gradle.plugins.gwt.Style.DETAILED

  sourceLevel = 1.11
}

dependencies {
  implementation "com.badlogicgames.gdx:gdx-backend-gwt:$gdxVersion"
  implementation "com.badlogicgames.gdx:gdx-backend-gwt:$gdxVersion:sources"
  implementation "com.badlogicgames.gdx:gdx:$gdxVersion:sources"
  implementation "com.crashinvaders.basisu:basisu-gdx:$gdxBasisUniversalVersion:sources"
  implementation "com.crashinvaders.basisu:basisu-wrapper:$gdxBasisUniversalVersion:natives-web"
  implementation "com.crashinvaders.basisu:basisu-wrapper:$gdxBasisUniversalVersion:sources"
  implementation project(':core')
  implementation("com.crashinvaders.basisu:basisu-gdx-gwt:$gdxBasisUniversalVersion:sources"){exclude group: "com.badlogicgames.gdx", module: "gdx-backend-gwt"}

}

import org.akhikhl.gretty.AppBeforeIntegrationTestTask
import org.docstr.gradle.plugins.gwt.GwtSuperDev

gretty.httpPort = 8080
// The line below will need to be changed only if you change the build directory to something other than "build".
gretty.resourceBase = "${project.layout.buildDirectory.asFile.get().absolutePath}/gwt/draftOut"
gretty.contextPath = "/"
gretty.portPropertiesFileName = "TEMP_PORTS.properties"

tasks.register('startHttpServer') {
  dependsOn("draftCompileGwt")
  doFirst {
    copy {
      from "webapp"
      into gretty.resourceBase
    }
    copy {
      from "war"
      into gretty.resourceBase
    }
  }
}

tasks.register('beforeRun', AppBeforeIntegrationTestTask) {
  dependsOn("startHttpServer")
  gretty {
    integrationTestTask("superDev")
  }
  // The next line allows ports to be reused instead of
  // needing a process to be manually terminated.
  file("build/TEMP_PORTS.properties").delete()
  interactive = false
}

tasks.register('superDev', GwtSuperDev) {
  group("gwt")
  dependsOn("beforeRun")
  doFirst {
    gwt.modules = gwt.devModules
  }
}

//// We delete the (temporary) war/ folder because if any extra files get into it, problems occur.
//// The war/ folder shouldn't be committed to version control.
clean.delete += [file("war")]

// This next line can be changed if you want to, for instance, always build into the
// docs/ folder of a Git repo, which can be set to automatically publish on GitHub Pages.
// This is relative to the html/ folder.
var outputPath = "build/dist/"

tasks.register('dist') {
  dependsOn(["clean", "compileGwt"])
  doLast {
    // Uncomment the next line if you have changed outputPath and know that its contents
    // should be replaced by a new dist build. Some large JS files are not cleaned up by
    // default unless the outputPath is inside build/ (then the clean task removes them).
    // Do not uncomment the next line if you changed outputPath to a folder that has
    // non-generated files that you want to keep!
    //delete(file(outputPath))

    file(outputPath).mkdirs()
    copy {
      from("build/gwt/out") {
        exclude '**/*.symbolMap' // Not used by a dist, and these can be large.
      }
      into outputPath
    }
    copy {
      from("webapp") {
        exclude 'index.html' // We edit this HTML file later.
        exclude 'refresh.png' // We don't need this button; this saves some bytes.
      }
      into outputPath
    }
    copy {
      from("webapp") {
        // These next two lines take the index.html page and remove the superdev refresh button.
        include 'index.html'
        filter { String line -> line.replaceAll('<a class="superdev" .+', '') }
        // This does not modify the original index.html, only the copy in the dist.
        // If you decide to manually remove or comment out the superdev button from index.html, you should also
        // either remove or comment out only the "filter" line above this.
      }
      into outputPath
    }
    copy {
      from "war"
      into outputPath
    }
  }
}

tasks.register('addSource') {
  doLast {
    sourceSets.main.compileClasspath += files(project(':core').sourceSets.main.allJava.srcDirs)
    sourceSets.main.compileClasspath += files("../core/build/generated/sources/annotationProcessor/java/main")
    sourceSets.main.compileClasspath += files(sourceSets.main.output.resourcesDir)

  }
}

tasks.register("distZip", Zip) {
  dependsOn("dist")
  //// This uses the output of the dist task, which removes the superdev button from index.html .
  from(outputPath)
  archiveVersion = projectVersion
  archiveBaseName.set("${appName}-dist")
  //// The result will be in html/build/ with a name containing "-dist".
  destinationDirectory.set(file("build"))
}

tasks.compileGwt.dependsOn("addSource")
tasks.draftCompileGwt.dependsOn("addSource")
tasks.checkGwt.dependsOn("addSource")

java.sourceCompatibility = JavaVersion.VERSION_11
java.targetCompatibility = JavaVersion.VERSION_11
sourceSets.main.java.srcDirs = [ "src/main/java/" ]

eclipse.project.name = appName + "-html"

================
File: html/src/main/java/io/github/game/GdxDefinition.gwt.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit 2.11.0//EN" "https://www.gwtproject.org/doctype/2.11.0/gwt-module.dtd">
<module rename-to="html">
  <!-- Paths to source are relative to this file and separated by slashes ('/'). -->
  <source path="" />

  <!-- Any resources placed under package public_html, relative to this file, will be copied verbatim into the final webapp folder. -->
  <!-- This is where you can place your JavaScript, CSS and other resources for advanced JS integration. -->
  <public path="public_html" />

  <!-- "Inherits" lines are how GWT knows where to look for code and configuration in other projects or libraries. -->
  <inherits name="com.badlogic.gdx.backends.gdx_backends_gwt" />
  <inherits name="com.crashinvaders.basisu.BasisuGdxGwt" />
  <inherits name="io.github.game.Main" />

  <!-- You must change this if you rename packages later, or rename GwtLauncher. -->
  <entry-point class="io.github.game.gwt.GwtLauncher" />

  <!-- Reflection includes may be needed for your code or library code. Each value is separated by periods ('.'). -->
  <!-- You can include a full package by not including the name of a type at the end. -->
  <!-- This is a feature of libGDX, so these lines go after the above "inherits" that brings in libGDX. -->
  <!-- <extend-configuration-property name="gdx.reflect.include" value="fully.qualified.TypeName" /> -->

  <!-- Rarely, projects may need to include files but do not have access to the complete assets. -->
  <!-- This happens for libraries and shared projects, typically, and the configuration goes in that project. -->
  <!-- The value is a path, separated by forward slashes, where the root is your html project's resources root. -->
  <!-- You can include individual files like this, and access them with Gdx.files.classpath("path/to/file.png") : -->
  <!-- This is also a feature of libGDX, so these lines go after the above "inherits" that brings in libGDX. -->
  <!-- <extend-configuration-property name="gdx.files.classpath" value="path/to/file.png" /> -->

  <!-- You usually won't need to make changes to the rest of this. -->
  <set-configuration-property name="gdx.assetpath" value="../assets" />
  <set-configuration-property name="xsiframe.failIfScriptTag" value="FALSE"/>
  <!-- These two lines reduce the work GWT has to do during compilation and also shrink output size. -->
  <set-property name="user.agent" value="gecko1_8, safari"/>
  <collapse-property name="user.agent" values="*" />
  <!-- Remove the "user.agent" lines above if you encounter issues with Safari or other Gecko browsers. -->
</module>

================
File: html/src/main/java/io/github/game/GdxDefinitionSuperdev.gwt.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit 2.11.0//EN" "https://www.gwtproject.org/doctype/2.11.0/gwt-module.dtd">
<module rename-to="html">
  <inherits name="io.github.game.GdxDefinition" />
  <collapse-all-properties />
  <add-linker name="xsiframe"/>
  <set-configuration-property name="devModeRedirectEnabled" value="true"/>
  <set-configuration-property name="xsiframe.failIfScriptTag" value="FALSE"/>
</module>

================
File: html/src/main/java/io/github/game/gwt/GwtLauncher.java
================
package io.github.game.gwt;

import com.badlogic.gdx.ApplicationListener;
import com.badlogic.gdx.backends.gwt.GwtApplication;
import com.badlogic.gdx.backends.gwt.GwtApplicationConfiguration;
import io.github.game.Main;

/** Launches the GWT application. */
public class GwtLauncher extends GwtApplication {
        @Override
        public GwtApplicationConfiguration getConfig () {
            // Resizable application, uses available space in browser with no padding:
            GwtApplicationConfiguration cfg = new GwtApplicationConfiguration(true);
            cfg.padVertical = 0;
            cfg.padHorizontal = 0;
            return cfg;
            // If you want a fixed size application, comment out the above resizable section,
            // and uncomment below:
            //return new GwtApplicationConfiguration(640, 480);
        }

        @Override
        public ApplicationListener createApplicationListener () {
            return new Main();
        }
}

================
File: html/webapp/index.html
================
<!doctype html>
<html>
<head>
  <title>Mario</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta id="gameViewport" name="viewport" content="width=device-width initial-scale=1">
  <link href="styles.css" rel="stylesheet" type="text/css">
</head>

<body>
<a class="superdev" href="javascript:%7B%20window.__gwt_bookmarklet_params%20%3D%20%7B'server_url'%3A'http%3A%2F%2Flocalhost%3A9876%2F'%7D%3B%20var%20s%20%3D%20document.createElement('script')%3B%20s.src%20%3D%20'http%3A%2F%2Flocalhost%3A9876%2Fdev_mode_on.js'%3B%20void(document.getElementsByTagName('head')%5B0%5D.appendChild(s))%3B%7D">&#8635;</a>
<div align="center" id="embed-html"></div>
<script type="text/javascript" src="html/html.nocache.js"></script>
</body>

<script>
function handleMouseDown(evt) {
  evt.preventDefault();
  evt.stopPropagation();
  window.focus();
}

function handleMouseUp(evt) {
  evt.preventDefault();
  evt.stopPropagation();
}
document.addEventListener('contextmenu', event => event.preventDefault());
document.getElementById('embed-html').addEventListener('mousedown', handleMouseDown, false);
document.getElementById('embed-html').addEventListener('mouseup', handleMouseUp, false);
</script>
</html>

================
File: html/webapp/styles.css
================
canvas {
    cursor: default;
    outline: none;
}

body {
    background-color: #222222;
    margin: 0px;
}

p {
    text-align: center;
    color: #eeeeee;
}

a {
    text-align: center;
    color: #bbbbff;
}

.superdev {
    color: rgb(37,37,37);
    text-shadow: 0px 1px 1px rgba(250,250,250,0.1);
    font-size: 50pt;
    display: block;
    position: relative;
    text-decoration: none;
    background-color: rgb(83,87,93);
    box-shadow: 0px 3px 0px 0px rgb(34,34,34),
                0px 7px 10px 0px rgb(17,17,17),
                inset 0px 1px 1px 0px rgba(250, 250, 250, .2),
                inset 0px -12px 35px 0px rgba(0, 0, 0, .5);
    width: 70px;
    height: 70px;
    border: 0;
    border-radius: 35px;
    text-align: center;
    line-height: 68px;
}

.superdev:active {
    box-shadow: 0px 0px 0px 0px rgb(34,34,34),
                0px 3px 7px 0px rgb(17,17,17),
                inset 0px 1px 1px 0px rgba(250, 250, 250, .2),
                inset 0px -10px 35px 5px rgba(0, 0, 0, .5);
    background-color: rgb(83,87,93);
    top: 3px;
    color: #fff;
    text-shadow: 0px 0px 3px rgb(250,250,250);
}

.superdev:hover {
    background-color: rgb(100,100,100);
}

================
File: html/webapp/WEB-INF/web.xml
================
<?xml version="1.0" ?>
<web-app>
</web-app>

================
File: levels/New Level.json
================
{
name: New Level
playerStartX: 150
playerStartY: 64
backgroundMusic: music/level1.mp3
musicVolume: 0.5
backgroundTexturePath: mario_sprites/backgrounds/background_0.png
platforms: [
	{
		class: io.github.game.Level$PlatformData
		width: 3200
		height: 64
		type: GROUND
	}
	{
		class: io.github.game.Level$PlatformData
		x: 352
		y: 256
		width: 32
		height: 32
		type: QUESTION_BLOCK
	}
	{
		class: io.github.game.Level$PlatformData
		x: 480
		y: 224
		width: 32
		height: 32
		type: QUESTION_BLOCK
	}
	{
		class: io.github.game.Level$PlatformData
		x: 416
		y: 224
		width: 32
		height: 32
		type: COIN
	}
	{
		class: io.github.game.Level$PlatformData
		x: 352
		y: 224
		width: 32
		height: 32
		type: COIN
	}
	{
		class: io.github.game.Level$PlatformData
		x: 384
		y: 128
		width: 32
		height: 32
		type: COIN
	}
]
questionBlockContents: {}
}

================
File: lwjgl3/build.gradle
================
buildscript {
  repositories {
    gradlePluginPortal()
  }
  dependencies {
    classpath "io.github.fourlastor:construo:1.7.1"
    if(enableGraalNative == 'true') {
      classpath "org.graalvm.buildtools.native:org.graalvm.buildtools.native.gradle.plugin:0.9.28"
    }
  }
}
plugins {
  id "application"
}
apply plugin: 'io.github.fourlastor.construo'


import io.github.fourlastor.construo.Target

sourceSets.main.resources.srcDirs += [ rootProject.file('assets').path ]
mainClassName = 'io.github.game.lwjgl3.Lwjgl3Launcher'
application.setMainClass(mainClassName)
eclipse.project.name = appName + '-lwjgl3'
java.sourceCompatibility = 8
java.targetCompatibility = 8
if (JavaVersion.current().isJava9Compatible()) {
        compileJava.options.release.set(8)
}

dependencies {
  implementation "com.badlogicgames.gdx:gdx-backend-lwjgl3:$gdxVersion"
  implementation "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-desktop"
  implementation "com.crashinvaders.basisu:basisu-wrapper:$gdxBasisUniversalVersion:natives-desktop"
  implementation project(':core')

  if(enableGraalNative == 'true') {
    implementation "io.github.berstanio:gdx-svmhelper-backend-lwjgl3:$graalHelperVersion"

    }
}

def os = System.properties['os.name'].toLowerCase()

run {
  workingDir = rootProject.file('assets').path
// You can uncomment the next line if your IDE claims a build failure even when the app closed properly.
  //setIgnoreExitValue(true)

  if (os.contains('mac')) jvmArgs += "-XstartOnFirstThread"
}

jar {
// sets the name of the .jar file this produces to the name of the game or app, with the version after.
  archiveFileName.set("${appName}-${projectVersion}.jar")
// the duplicatesStrategy matters starting in Gradle 7.0; this setting works.
  duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
  dependsOn configurations.runtimeClasspath
  from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
// these "exclude" lines remove some unnecessary duplicate files in the output JAR.
  exclude('META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
  dependencies {
    exclude('META-INF/INDEX.LIST', 'META-INF/maven/**')
  }
// setting the manifest makes the JAR runnable.
  manifest {
    attributes 'Main-Class': project.mainClassName
  }
// this last step may help on some OSes that need extra instruction to make runnable JARs.
  doLast {
    file(archiveFile).setExecutable(true, false)
  }
}

// Builds a JAR that only includes the files needed to run on macOS, not Windows or Linux.
// The file size for a Mac-only JAR is about 7MB smaller than a cross-platform JAR.
tasks.register("jarMac") {
  dependsOn("jar")
  group("build")
  jar.archiveFileName.set("${appName}-${projectVersion}-mac.jar")
  jar.exclude("windows/x86/**", "windows/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**", "**/*.dll", "**/*.so",
    'META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
  dependencies {
    jar.exclude("windows/x86/**", "windows/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**",
      'META-INF/INDEX.LIST', 'META-INF/maven/**')
  }
}

// Builds a JAR that only includes the files needed to run on Linux, not Windows or macOS.
// The file size for a Linux-only JAR is about 5MB smaller than a cross-platform JAR.
tasks.register("jarLinux") {
  dependsOn("jar")
  group("build")
  jar.archiveFileName.set("${appName}-${projectVersion}-linux.jar")
  jar.exclude("windows/x86/**", "windows/x64/**", "macos/arm64/**", "macos/x64/**", "**/*.dll", "**/*.dylib",
    'META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
  dependencies {
    jar.exclude("windows/x86/**", "windows/x64/**", "macos/arm64/**", "macos/x64/**",
      'META-INF/INDEX.LIST', 'META-INF/maven/**')
  }
}

// Builds a JAR that only includes the files needed to run on Windows, not Linux or macOS.
// The file size for a Windows-only JAR is about 6MB smaller than a cross-platform JAR.
tasks.register("jarWin") {
  dependsOn("jar")
  group("build")
  jar.archiveFileName.set("${appName}-${projectVersion}-win.jar")
  jar.exclude("macos/arm64/**", "macos/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**", "**/*.dylib", "**/*.so",
    'META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
  dependencies {
    jar.exclude("macos/arm64/**", "macos/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**",
      'META-INF/INDEX.LIST', 'META-INF/maven/**')
  }
}

construo {
    // name of the executable
    name.set(appName)
    // human-readable name, used for example in the `.app` name for macOS
    humanName.set(appName)
    // Optional, defaults to project version property
    version.set("$projectVersion")

    targets.configure {
      create("linuxX64", Target.Linux) {
        architecture.set(Target.Architecture.X86_64)
        jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_x64_linux_hotspot_17.0.15_6.tar.gz")
        // Linux does not currently have a way to set the icon on the executable
      }
      create("macM1", Target.MacOs) {
        architecture.set(Target.Architecture.AARCH64)
        jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_aarch64_mac_hotspot_17.0.15_6.tar.gz")
        // macOS needs an identifier
        identifier.set("io.github.game." + appName)
        // Optional: icon for macOS, as an ICNS file
        macIcon.set(project.file("icons/logo.icns"))
      }
      create("macX64", Target.MacOs) {
        architecture.set(Target.Architecture.X86_64)
        jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_x64_mac_hotspot_17.0.15_6.tar.gz")
        // macOS needs an identifier
        identifier.set("io.github.game." + appName)
        // Optional: icon for macOS, as an ICNS file
        macIcon.set(project.file("icons/logo.icns"))
      }
      create("winX64", Target.Windows) {
        architecture.set(Target.Architecture.X86_64)
        // Optional: icon for Windows, as a PNG
        icon.set(project.file("icons/logo.png"))
        jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_x64_windows_hotspot_17.0.15_6.zip")
        // Uncomment the next line to show a console when the game runs, to print messages.
        //useConsole.set(true)
      }
    }
}

// Equivalent to the jar task; here for compatibility with gdx-setup.
tasks.register('dist') {
  dependsOn 'jar'
}

distributions {
  main {
    contents {
      into('libs') {
        project.configurations.runtimeClasspath.files.findAll { file ->
          file.getName() != project.tasks.jar.outputs.files.singleFile.name
        }.each { file ->
          exclude file.name
        }
      }
    }
  }
}

startScripts.dependsOn(':lwjgl3:jar')
startScripts.classpath = project.tasks.jar.outputs.files

if(enableGraalNative == 'true') {
  apply from: file("nativeimage.gradle")
}

================
File: lwjgl3/nativeimage.gradle
================
project(":lwjgl3") {
  apply plugin: "org.graalvm.buildtools.native"

  graalvmNative {
    binaries {
      main {
        imageName = appName
        mainClass = project.mainClassName
        requiredVersion = '23.0'
        buildArgs.add("-march=compatibility")
        jvmArgs.addAll("-Dfile.encoding=UTF8")
        sharedLibrary = false
        resources.autodetect()
      }
    }
  }

  run {
    doNotTrackState("Running the app should not be affected by Graal.")
  }

  // Modified from https://lyze.dev/2021/04/29/libGDX-Internal-Assets-List/ ; thanks again, Lyze!
  // This creates a resource-config.json file based on the contents of the assets folder (and the libGDX icons).
  // This file is used by Graal Native to embed those specific files.
  // This has to run before nativeCompile, so it runs at the start of an unrelated resource-handling command.
  generateResourcesConfigFile.doFirst {
    def assetsFolder = new File("${project.rootDir}/assets/")
    def lwjgl3 = project(':lwjgl3')
    def resFolder = new File("${lwjgl3.projectDir}/src/main/resources/META-INF/native-image/${lwjgl3.ext.appName}")
    resFolder.mkdirs()
    def resFile = new File(resFolder, "resource-config.json")
    resFile.delete()
    resFile.append(
            """{
  "resources":{
  "includes":[
    {
      "pattern": ".*(""")
    // This adds every filename in the assets/ folder to a pattern that adds those files as resources.
    fileTree(assetsFolder).each {
      // The backslash-Q and backslash-E escape the start and end of a literal string, respectively.
      resFile.append("\\\\Q${it.name}\\\\E|")
    }
    // We also match all of the window icon images this way and the font files that are part of libGDX.
    resFile.append(
            """libgdx.+\\\\.png|lsans.+)"
    }
  ]},
  "bundles":[]
}"""
    )
  }
}

================
File: lwjgl3/src/main/java/io/github/game/lwjgl3/Lwjgl3Launcher.java
================
package io.github.game.lwjgl3;

import com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application;
import com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration;
import io.github.game.Main;

/** Launches the desktop (LWJGL3) application. */
public class Lwjgl3Launcher {
    public static void main(String[] args) {
        if (StartupHelper.startNewJvmIfRequired()) return; // This handles macOS support and helps on Windows.
        createApplication();
    }

    private static Lwjgl3Application createApplication() {
        return new Lwjgl3Application(new Main(), getDefaultConfiguration());
    }

    private static Lwjgl3ApplicationConfiguration getDefaultConfiguration() {
        Lwjgl3ApplicationConfiguration configuration = new Lwjgl3ApplicationConfiguration();
        configuration.setTitle("Mario");
        //// Vsync limits the frames per second to what your hardware can display, and helps eliminate
        //// screen tearing. This setting doesn't always work on Linux, so the line after is a safeguard.
        configuration.useVsync(true);
        //// Limits FPS to the refresh rate of the currently active monitor, plus 1 to try to match fractional
        //// refresh rates. The Vsync setting above should limit the actual FPS to match the monitor.
        configuration.setForegroundFPS(Lwjgl3ApplicationConfiguration.getDisplayMode().refreshRate + 1);
        //// If you remove the above line and set Vsync to false, you can get unlimited FPS, which can be
        //// useful for testing performance, but can also be very stressful to some hardware.
        //// You may also need to configure GPU drivers to fully disable Vsync; this can cause screen tearing.

        configuration.setWindowedMode(640, 480);
        //// You can change these files; they are in lwjgl3/src/main/resources/ .
        //// They can also be loaded from the root of assets/ .
        configuration.setWindowIcon("libgdx128.png", "libgdx64.png", "libgdx32.png", "libgdx16.png");
        return configuration;
    }
}

================
File: lwjgl3/src/main/java/io/github/game/lwjgl3/StartupHelper.java
================
/*
 * Copyright 2020 damios
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//Note, the above license and copyright applies to this file only.

package io.github.game.lwjgl3;

import com.badlogic.gdx.Version;
import com.badlogic.gdx.backends.lwjgl3.Lwjgl3NativesLoader;
import org.lwjgl.system.macosx.LibC;
import org.lwjgl.system.macosx.ObjCRuntime;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.lang.management.ManagementFactory;
import java.util.ArrayList;

import static org.lwjgl.system.JNI.invokePPP;
import static org.lwjgl.system.JNI.invokePPZ;
import static org.lwjgl.system.macosx.ObjCRuntime.objc_getClass;
import static org.lwjgl.system.macosx.ObjCRuntime.sel_getUid;

/**
 * Adds some utilities to ensure that the JVM was started with the
 * {@code -XstartOnFirstThread} argument, which is required on macOS for LWJGL 3
 * to function. Also helps on Windows when users have names with characters from
 * outside the Latin alphabet, a common cause of startup crashes.
 * <br>
 * <a href="https://jvm-gaming.org/t/starting-jvm-on-mac-with-xstartonfirstthread-programmatically/57547">Based on this java-gaming.org post by kappa</a>
 * @author damios
 */
public class StartupHelper {

    private static final String JVM_RESTARTED_ARG = "jvmIsRestarted";

    private StartupHelper() {
        throw new UnsupportedOperationException();
    }

    /**
     * Starts a new JVM if the application was started on macOS without the
     * {@code -XstartOnFirstThread} argument. This also includes some code for
     * Windows, for the case where the user's home directory includes certain
     * non-Latin-alphabet characters (without this code, most LWJGL3 apps fail
     * immediately for those users). Returns whether a new JVM was started and
     * thus no code should be executed.
     * <p>
     * <u>Usage:</u>
     *
     * <pre><code>
     * public static void main(String... args) {
     * 	if (StartupHelper.startNewJvmIfRequired(true)) return; // This handles macOS support and helps on Windows.
     * 	// after this is the actual main method code
     * }
     * </code></pre>
     *
     * @param redirectOutput
     *            whether the output of the new JVM should be rerouted to the
     *            old JVM, so it can be accessed in the same place; keeps the
     *            old JVM running if enabled
     * @return whether a new JVM was started and thus no code should be executed
     *         in this one
     */
    public static boolean startNewJvmIfRequired(boolean redirectOutput) {
        String osName = System.getProperty("os.name").toLowerCase();
        if (!osName.contains("mac")) {
            if (osName.contains("windows")) {
// Here, we are trying to work around an issue with how LWJGL3 loads its extracted .dll files.
// By default, LWJGL3 extracts to the directory specified by "java.io.tmpdir", which is usually the user's home.
// If the user's name has non-ASCII (or some non-alphanumeric) characters in it, that would fail.
// By extracting to the relevant "ProgramData" folder, which is usually "C:\ProgramData", we avoid this.
// We also temporarily change the "user.name" property to one without any chars that would be invalid.
// We revert our changes immediately after loading LWJGL3 natives.
                String programData = System.getenv("ProgramData");
                if(programData == null) programData = "C:\\Temp\\"; // if ProgramData isn't set, try some fallback.
                String prevTmpDir = System.getProperty("java.io.tmpdir", programData);
                String prevUser = System.getProperty("user.name", "libGDX_User");
                System.setProperty("java.io.tmpdir", programData + "/libGDX-temp");
                System.setProperty("user.name", ("User_" + prevUser.hashCode() + "_GDX" + Version.VERSION).replace('.', '_'));
                Lwjgl3NativesLoader.load();
                System.setProperty("java.io.tmpdir", prevTmpDir);
                System.setProperty("user.name", prevUser);
            }
            return false;
        }

        // There is no need for -XstartOnFirstThread on Graal native image
        if (!System.getProperty("org.graalvm.nativeimage.imagecode", "").isEmpty()) {
            return false;
        }

        // Checks if we are already on the main thread, such as from running via Construo.
        long objc_msgSend = ObjCRuntime.getLibrary().getFunctionAddress("objc_msgSend");
        long NSThread      = objc_getClass("NSThread");
        long currentThread = invokePPP(NSThread, sel_getUid("currentThread"), objc_msgSend);
        boolean isMainThread = invokePPZ(currentThread, sel_getUid("isMainThread"), objc_msgSend);
        if(isMainThread) return false;

        long pid = LibC.getpid();

        // check whether -XstartOnFirstThread is enabled
        if ("1".equals(System.getenv("JAVA_STARTED_ON_FIRST_THREAD_" + pid))) {
            return false;
        }

        // check whether the JVM was previously restarted
        // avoids looping, but most certainly leads to a crash
        if ("true".equals(System.getProperty(JVM_RESTARTED_ARG))) {
            System.err.println(
                    "There was a problem evaluating whether the JVM was started with the -XstartOnFirstThread argument.");
            return false;
        }

        // Restart the JVM with -XstartOnFirstThread
        ArrayList<String> jvmArgs = new ArrayList<>();
        String separator = System.getProperty("file.separator", "/");
        // The following line is used assuming you target Java 8, the minimum for LWJGL3.
        String javaExecPath = System.getProperty("java.home") + separator + "bin" + separator + "java";
        // If targeting Java 9 or higher, you could use the following instead of the above line:
        //String javaExecPath = ProcessHandle.current().info().command().orElseThrow();

        if (!(new File(javaExecPath)).exists()) {
            System.err.println(
                    "A Java installation could not be found. If you are distributing this app with a bundled JRE, be sure to set the -XstartOnFirstThread argument manually!");
            return false;
        }

        jvmArgs.add(javaExecPath);
        jvmArgs.add("-XstartOnFirstThread");
        jvmArgs.add("-D" + JVM_RESTARTED_ARG + "=true");
        jvmArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());
        jvmArgs.add("-cp");
        jvmArgs.add(System.getProperty("java.class.path"));
        String mainClass = System.getenv("JAVA_MAIN_CLASS_" + pid);
        if (mainClass == null) {
            StackTraceElement[] trace = Thread.currentThread().getStackTrace();
            if (trace.length > 0) {
                mainClass = trace[trace.length - 1].getClassName();
            } else {
                System.err.println("The main class could not be determined.");
                return false;
            }
        }
        jvmArgs.add(mainClass);

        try {
            if (!redirectOutput) {
                ProcessBuilder processBuilder = new ProcessBuilder(jvmArgs);
                processBuilder.start();
            } else {
                Process process = (new ProcessBuilder(jvmArgs))
                        .redirectErrorStream(true).start();
                BufferedReader processOutput = new BufferedReader(
                        new InputStreamReader(process.getInputStream()));
                String line;

                while ((line = processOutput.readLine()) != null) {
                    System.out.println(line);
                }

                process.waitFor();
            }
        } catch (Exception e) {
            System.err.println("There was a problem restarting the JVM");
            e.printStackTrace();
        }

        return true;
    }

    /**
     * Starts a new JVM if the application was started on macOS without the
     * {@code -XstartOnFirstThread} argument. Returns whether a new JVM was
     * started and thus no code should be executed. Redirects the output of the
     * new JVM to the old one.
     * <p>
     * <u>Usage:</u>
     *
     * <pre>
     * public static void main(String... args) {
     * 	if (StartupHelper.startNewJvmIfRequired()) return; // This handles macOS support and helps on Windows.
     * 	// the actual main method code
     * }
     * </pre>
     *
     * @return whether a new JVM was started and thus no code should be executed
     *         in this one
     */
    public static boolean startNewJvmIfRequired() {
        return startNewJvmIfRequired(true);
    }
}

================
File: README.md
================
# Mario

A [libGDX](https://libgdx.com/) project generated with [gdx-liftoff](https://github.com/libgdx/gdx-liftoff).

This project was generated with a template including simple application launchers and an `ApplicationAdapter` extension that draws libGDX logo.

## Platforms

- `core`: Main module with the application logic shared by all platforms.
- `lwjgl3`: Primary desktop platform using LWJGL3; was called 'desktop' in older docs.
- `html`: Web platform using GWT and WebGL. Supports only Java projects.
- `server`: A separate application without access to the `core` module.

## Gradle

This project uses [Gradle](https://gradle.org/) to manage dependencies.
The Gradle wrapper was included, so you can run Gradle tasks using `gradlew.bat` or `./gradlew` commands.
Useful Gradle tasks and flags:

- `--continue`: when using this flag, errors will not stop the tasks from running.
- `--daemon`: thanks to this flag, Gradle daemon will be used to run chosen tasks.
- `--offline`: when using this flag, cached dependency archives will be used.
- `--refresh-dependencies`: this flag forces validation of all dependencies. Useful for snapshot versions.
- `build`: builds sources and archives of every project.
- `cleanEclipse`: removes Eclipse project data.
- `cleanIdea`: removes IntelliJ project data.
- `clean`: removes `build` folders, which store compiled classes and built archives.
- `eclipse`: generates Eclipse project data.
- `html:dist`: compiles GWT sources. The compiled application can be found at `html/build/dist`: you can use any HTTP server to deploy it.
- `html:superDev`: compiles GWT sources and runs the application in SuperDev mode. It will be available at [localhost:8080/html](http://localhost:8080/html). Use only during development.
- `idea`: generates IntelliJ project data.
- `lwjgl3:jar`: builds application's runnable jar, which can be found at `lwjgl3/build/libs`.
- `lwjgl3:run`: starts the application.
- `server:run`: runs the server application.
- `test`: runs unit tests (if any).

Note that most tasks that are not specific to a single project can be run with `name:` prefix, where the `name` should be replaced with the ID of a specific project.
For example, `core:clean` removes `build` folder only from the `core` project.

================
File: server/build.gradle
================
apply plugin: 'application'


java.sourceCompatibility = 8
java.targetCompatibility = 8
if (JavaVersion.current().isJava9Compatible()) {
        compileJava.options.release.set(8)
}

mainClassName = 'io.github.game.server.ServerLauncher'
application.setMainClass(mainClassName)
eclipse.project.name = appName + '-server'

dependencies {

}

jar {
  archiveBaseName.set(appName)
// the duplicatesStrategy matters starting in Gradle 7.0; this setting works.
  duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
  dependsOn configurations.runtimeClasspath
  from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
// these "exclude" lines remove some unnecessary duplicate files in the output JAR.
  exclude('META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
  dependencies {
    exclude('META-INF/INDEX.LIST', 'META-INF/maven/**')
  }
// setting the manifest makes the JAR runnable.
  manifest {
    attributes 'Main-Class': project.mainClassName
  }
// this last step may help on some OSes that need extra instruction to make runnable JARs.
  doLast {
    file(archiveFile).setExecutable(true, false)
  }
}

// Equivalent to the jar task; here for compatibility with gdx-setup.
task dist(dependsOn: [jar]) {
}

================
File: server/src/main/java/io/github/game/server/ServerLauncher.java
================
package io.github.game.server;

/** Launches the server application. */
public class ServerLauncher {
    public static void main(String[] args) {
        // TODO Implement server application.
    }
}

================
File: settings.gradle
================
plugins {
  // Applies the foojay-resolver plugin to allow automatic download of JDKs.
  id("org.gradle.toolchains.foojay-resolver-convention") version "0.9.0"
}
// A list of which subprojects to load as part of the same larger project.
// You can remove Strings from the list and reload the Gradle project
// if you want to temporarily disable a subproject.
include 'lwjgl3', 'server', 'html', 'core'
