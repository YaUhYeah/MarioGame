    This file is a merged representation of the entire codebase, combining all repository files into a single document.
    Generated by Repomix on: 2025-05-26T08:14:43.351Z

    ================================================================
    File Summary
    ================================================================

    Purpose:
    --------
    This file contains a packed representation of the entire repository's contents.
    It is designed to be easily consumable by AI systems for analysis, code review,
    or other automated processes.

    File Format:
    ------------
    The content is organized as follows:
    1. This summary section
    2. Repository information
    3. Repository structure
    4. Multiple file entries, each consisting of:
      a. A separator line (================)
      b. The file path (File: path/to/file)
      c. Another separator line
      d. The full contents of the file
      e. A blank line

    Usage Guidelines:
    -----------------
    - This file should be treated as read-only. Any changes should be made to the
      original repository files, not this packed version.
    - When processing this file, use the file path to distinguish
      between different files in the repository.
    - Be aware that this file may contain sensitive information. Handle it with
      the same level of security as you would the original repository.

    Notes:
    ------
    - Some files may have been excluded based on .gitignore rules and Repomix's
      configuration.
    - Binary files are not included in this packed representation. Please refer to
      the Repository Structure section for a complete list of file paths, including
      binary files.

    Additional Info:
    ----------------

    For more information about Repomix, visit: https://github.com/yamadashy/repomix

    ================================================================
    Repository Structure
    ================================================================
    .editorconfig
    .gitattributes
    .gitignore
    assets/mario_sprites/proj.tpproj
    build.gradle
    core/build.gradle
    core/src/main/java/io/github/game/Background.java
    core/src/main/java/io/github/game/editor/AddEnemyCommand.java
    core/src/main/java/io/github/game/editor/AddPlatformCommand.java
    core/src/main/java/io/github/game/editor/ClearLevelCommand.java
    core/src/main/java/io/github/game/editor/EditorCommand.java
    core/src/main/java/io/github/game/editor/RemoveEnemyCommand.java
    core/src/main/java/io/github/game/editor/RemovePlatformCommand.java
    core/src/main/java/io/github/game/enemies/Enemy.java
    core/src/main/java/io/github/game/enemies/EnemyType.java
    core/src/main/java/io/github/game/enemies/Goomba.java
    core/src/main/java/io/github/game/Level.java
    core/src/main/java/io/github/game/LevelEditor.java
    core/src/main/java/io/github/game/Main.gwt.xml
    core/src/main/java/io/github/game/Main.java
    core/src/main/java/io/github/game/Platform.java
    core/src/main/java/io/github/game/Player.java
    core/src/main/java/io/github/game/Powerup.java
    core/src/main/java/io/github/game/SoundManager.java
    gradle.properties
    gradle/gradle-daemon-jvm.properties
    gradle/wrapper/gradle-wrapper.properties
    gradlew
    gradlew.bat
    html/build.gradle
    html/src/main/java/io/github/game/GdxDefinition.gwt.xml
    html/src/main/java/io/github/game/GdxDefinitionSuperdev.gwt.xml
    html/src/main/java/io/github/game/gwt/GwtLauncher.java
    html/webapp/index.html
    html/webapp/styles.css
    html/webapp/WEB-INF/web.xml
    levels/New Level.json
    lwjgl3/build.gradle
    lwjgl3/nativeimage.gradle
    lwjgl3/src/main/java/io/github/game/lwjgl3/Lwjgl3Launcher.java
    lwjgl3/src/main/java/io/github/game/lwjgl3/StartupHelper.java
    README.md
    server/build.gradle
    server/src/main/java/io/github/game/server/ServerLauncher.java
    settings.gradle

    ================================================================
    Repository Files
    ================================================================

    ================
    File: .editorconfig
    ================
    # https://editorconfig.org
    root = true

    [*]
    indent_style = space
    end_of_line = lf
    charset = utf-8
    trim_trailing_whitespace = true
    insert_final_newline = true

    [*.{java,scala,groovy,kt,kts}]
    indent_size = 4

    [*.gradle]
    indent_size = 2

    [*.md]
    trim_trailing_whitespace = false

    ================
    File: .gitattributes
    ================
    * text=auto eol=lf
    *.bat text=auto eol=crlf

    ================
    File: .gitignore
    ================
    ## Gradle:
    .gradle/
    gradle-app.setting
    /build/
    /android/build/
    /core/build/
    /lwjgl2/build/
    /lwjgl3/build/
    /html/build/
    /teavm/build/
    /ios/build/
    /ios-moe/build/
    /headless/build/
    /server/build/
    /shared/build/

    ## Java:
    *.class
    *.war
    *.ear
    hs_err_pid*
    .attach_pid*

    ## Android:
    /android/libs/armeabi-v7a/
    /android/libs/arm64-v8a/
    /android/libs/x86/
    /android/libs/x86_64/
    /android/gen/
    /android/out/
    local.properties
    com_crashlytics_export_strings.xml

    ## Robovm:
    /ios/robovm-build/

    ## iOS:
    /ios/xcode/*.xcodeproj/*
    !/ios/xcode/*.xcodeproj/xcshareddata
    !/ios/xcode/*.xcodeproj/project.pbxproj
    /ios/xcode/native/
    /ios/IOSLauncher.app
    /ios/IOSLauncher.app.dSYM

    ## GWT:
    /html/war/
    /html/gwt-unitCache/
    .apt_generated/
    /html/war/WEB-INF/deploy/
    /html/war/WEB-INF/classes/
    .gwt/
    gwt-unitCache/
    www-test/
    .gwt-tmp/

    ## TeaVM:
    # Not sure yet...

    ## IntelliJ, Android Studio:
    .idea/
    *.ipr
    *.iws
    *.iml

    ## Eclipse:
    .classpath
    .project
    .metadata/
    /android/bin/
    /core/bin/
    /lwjgl2/bin/
    /lwjgl3/bin/
    /html/bin/
    /teavm/bin/
    /ios/bin/
    /ios-moe/bin/
    /headless/bin/
    /server/bin/
    /shared/bin/
    *.tmp
    *.bak
    *.swp
    *~.nib
    .settings/
    .loadpath
    .externalToolBuilders/
    *.launch


    ## NetBeans:

    /nbproject/private/
    /android/nbproject/private/
    /core/nbproject/private/
    /lwjgl2/nbproject/private/
    /lwjgl3/nbproject/private/
    /html/nbproject/private/
    /teavm/nbproject/private/
    /ios/nbproject/private/
    /ios-moe/nbproject/private/
    /headless/nbproject/private/
    /server/nbproject/private/
    /shared/nbproject/private/

    /nbbuild/
    /android/nbbuild/
    /core/nbbuild/
    /lwjgl2/nbbuild/
    /lwjgl3/nbbuild/
    /html/nbbuild/
    /teavm/nbbuild/
    /ios/nbbuild/
    /ios-moe/nbbuild/
    /headless/nbbuild/
    /server/nbbuild/
    /shared/nbbuild/

    /dist/
    /android/dist/
    /core/dist/
    /lwjgl2/dist/
    /lwjgl3/dist/
    /html/dist/
    /teavm/dist/
    /ios/dist/
    /ios-moe/dist/
    /headless/dist/
    /server/dist/
    /shared/dist/

    /nbdist/
    /android/nbdist/
    /core/nbdist/
    /lwjgl2/nbdist/
    /lwjgl3/nbdist/
    /html/nbdist/
    /teavm/nbdist/
    /ios/nbdist/
    /ios-moe/nbdist/
    /headless/nbdist/
    /server/nbdist/
    /shared/nbdist/

    nbactions.xml
    nb-configuration.xml

    ## OS-Specific:
    .DS_Store
    Thumbs.db

    ## Miscellaneous:
    *~
    *.*#
    *#*#
    /.kotlin/
    /assets/assets.txt

    ## Special cases:

    ## There is a resource-config.json file generated by nativeimage.gradle if you use Graal Native Image.
    ## Some usage may need extra resource configuration in a different file with the same name.
    ## You could also add that configuration to the text in nativeimage.gradle .
    ## You should delete or comment out the next line if you have configuration in a different resource-config.json .
    **/resource-config.json

    ================
    File: assets/mario_sprites/proj.tpproj
    ================
    name=mario
    filename=
    output=playables/mario/atlas

    alias=true
    alphaThreshold=0
    debug=false
    duplicatePadding=false
    edgePadding=true
    fast=false
    filterMag=Nearest
    filterMin=Nearest
    ignoreBlankImages=true
    maxHeight=2048
    maxWidth=2048
    minHeight=16
    minWidth=16
    paddingX=2
    paddingY=2
    pot=true
    mof=false
    rotation=false
    stripWhitespaceX=false
    stripWhitespaceY=false
    wrapX=ClampToEdge
    wrapY=ClampToEdge
    premultiplyAlpha=false
    grid=false
    square=false
    bleed=true
    limitMemory=true
    useIndexes=true
    prettyPrint=false
    legacyOutput=false

    scaleFactors=[{suffix:"",factor:1,resampling:bicubic}]
    inputFiles=[{path:playables/mario/mario_duck.png,type:Input,regionName:null},{path:playables/mario/mario_fall.png,type:Input,regionName:null},{path:playables/mario/mario_idle.png,type:Input,regionName:null},{path:playables/mario/mario_jump.png,type:Input,regionName:null},{path:playables/mario/mario_look_up.png,type:Input,regionName:null},{path:playables/mario/mario_pipe.png,type:Input,regionName:null},{path:playables/mario/mario_walk_0.png,type:Input,regionName:null},{path:playables/mario/mario_walk_1.png,type:Input,regionName:null},{path:playables/mario/mario_walk_2.png,type:Input,regionName:null}]
    keepInputFileExtensions=false


    ---

    name=enemies
    filename=
    output=enemies/atlas

    alias=true
    alphaThreshold=0
    debug=false
    duplicatePadding=false
    edgePadding=true
    fast=false
    filterMag=Nearest
    filterMin=Nearest
    ignoreBlankImages=true
    maxHeight=2048
    maxWidth=2048
    minHeight=16
    minWidth=16
    paddingX=2
    paddingY=2
    pot=true
    mof=false
    rotation=false
    stripWhitespaceX=false
    stripWhitespaceY=false
    wrapX=ClampToEdge
    wrapY=ClampToEdge
    premultiplyAlpha=false
    grid=false
    square=false
    bleed=true
    limitMemory=true
    useIndexes=true
    prettyPrint=false
    legacyOutput=false

    scaleFactors=[{suffix:"",factor:1,resampling:bicubic}]
    inputFiles=[{path:enemies/bullet_bill.png,type:Input,regionName:null},{path:enemies/goomba_0.png,type:Input,regionName:null},{path:enemies/goomba_1.png,type:Input,regionName:null}]
    keepInputFileExtensions=false


    ---

    name=backgrounds
    filename=
    output=

    alias=true
    alphaThreshold=0
    debug=false
    duplicatePadding=false
    edgePadding=true
    fast=false
    filterMag=Nearest
    filterMin=Nearest
    ignoreBlankImages=true
    maxHeight=2048
    maxWidth=2048
    minHeight=16
    minWidth=16
    paddingX=2
    paddingY=2
    pot=true
    mof=false
    rotation=false
    stripWhitespaceX=false
    stripWhitespaceY=false
    wrapX=ClampToEdge
    wrapY=ClampToEdge
    premultiplyAlpha=false
    grid=false
    square=false
    bleed=true
    limitMemory=true
    useIndexes=true
    prettyPrint=false
    legacyOutput=false

    scaleFactors=[{suffix:"",factor:1,resampling:bicubic}]
    inputFiles=[]
    keepInputFileExtensions=false


    -PROJ-

    version=4.13.0
    fileTypeType=png
    fileTypeData={encoding:RGBA8888}
    previewBackgroundColor=ffffffff
    projectSettings={inputFiles:{}}

    ================
    File: build.gradle
    ================
    buildscript {
      repositories {
        mavenCentral()
        maven { url 'https://s01.oss.sonatype.org' }
        gradlePluginPortal()
        mavenLocal()
        google()
        maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
        maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
      }
      dependencies {


      }
    }

    allprojects {
      apply plugin: 'eclipse'
      apply plugin: 'idea'

      // This allows you to "Build and run using IntelliJ IDEA", an option in IDEA's Settings.
      idea {
        module {
          outputDir file('build/classes/java/main')
          testOutputDir file('build/classes/java/test')
        }
      }
    }

    configure(subprojects) {
      apply plugin: 'java-library'
      sourceCompatibility = 8

      // From https://lyze.dev/2021/04/29/libGDX-Internal-Assets-List/
      // The article can be helpful when using assets.txt in your project.
      tasks.register('generateAssetList') {
        inputs.dir("${project.rootDir}/assets/")
        // projectFolder/assets
        File assetsFolder = new File("${project.rootDir}/assets/")
        // projectFolder/assets/assets.txt
        File assetsFile = new File(assetsFolder, "assets.txt")
        // delete that file in case we've already created it
        assetsFile.delete()

        // iterate through all files inside that folder
        // convert it to a relative path
        // and append it to the file assets.txt
        fileTree(assetsFolder).collect { assetsFolder.relativePath(it) }.sort().each {
          assetsFile.append(it + "\n")
        }
      }
      processResources.dependsOn 'generateAssetList'

      compileJava {
        options.incremental = true
      }
    }

    subprojects {
      version = "$projectVersion"
      ext.appName = 'Mario'
      repositories {
        mavenCentral()
        maven { url 'https://s01.oss.sonatype.org' }
        // You may want to remove the following line if you have errors downloading dependencies.
        mavenLocal()
        maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
        maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
        maven { url 'https://jitpack.io' }
      }
    }

    eclipse.project.name = 'Mario' + '-parent'

    ================
    File: core/build.gradle
    ================
    [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
    eclipse.project.name = appName + '-core'

    dependencies {
      api "com.badlogicgames.gdx:gdx:$gdxVersion"
      api "com.crashinvaders.basisu:basisu-gdx:$gdxBasisUniversalVersion"
      api "com.crashinvaders.basisu:basisu-wrapper:$gdxBasisUniversalVersion"
      api "com.github.crykn:kryonet:$kryoNetVersion"

      if(enableGraalNative == 'true') {
        implementation "io.github.berstanio:gdx-svmhelper-annotations:$graalHelperVersion"
      }
    }

    ================
    File: core/src/main/java/io/github/game/Background.java
    ================
    // File: core/src/main/java/io/github/game/Background.java
    package io.github.game;

    import com.badlogic.gdx.Gdx;
    import com.badlogic.gdx.graphics.OrthographicCamera;
    import com.badlogic.gdx.graphics.Texture;
    import com.badlogic.gdx.graphics.g2d.SpriteBatch;

    public class Background {

        private Texture backgroundTexture;
        private String currentTexturePath;
        private float textureWidth;
        private float textureHeight;
        private float scrollSpeed = 0.5f; // Default scroll speed

        public static final String DEFAULT_BACKGROUND_PATH = "mario_sprites/backgrounds/background_0.png";

        public Background() {
            setTexture(DEFAULT_BACKGROUND_PATH);
        }

        public Background(String texturePath) {
            setTexture(texturePath);
        }

        public void setTexture(String texturePath) {
            if (texturePath == null || texturePath.isEmpty()) {
                Gdx.app.error("Background", "Texture path is null or empty. Using default: " + DEFAULT_BACKGROUND_PATH);
                texturePath = DEFAULT_BACKGROUND_PATH;
            }

            if (this.currentTexturePath != null && this.currentTexturePath.equals(texturePath) && backgroundTexture != null) {
                return; // Texture is already loaded and is the same
            }

            try {
                if (backgroundTexture != null) {
                    backgroundTexture.dispose(); // Dispose old texture
                }
                Gdx.app.log("Background", "Attempting to load background: " + texturePath);
                backgroundTexture = new Texture(Gdx.files.internal(texturePath));
                this.currentTexturePath = texturePath;
                textureWidth = backgroundTexture.getWidth();
                textureHeight = backgroundTexture.getHeight();
                Gdx.app.log("Background", "Successfully loaded new background: " + texturePath + " (Width: " + textureWidth + ", Height: " + textureHeight + ")");
            } catch (Exception e) {
                Gdx.app.error("Background", "Failed to load background texture: " + texturePath, e);
                // Attempt to load a fallback if the primary one fails and it wasn't the default already
                if (!texturePath.equals(DEFAULT_BACKGROUND_PATH)) {
                    Gdx.app.error("Background", "Falling back to default background due to previous error.");
                    setTexture(DEFAULT_BACKGROUND_PATH); // Recursive call to load default
                } else {
                    // If default also fails, then we have a bigger issue, or it's missing
                    Gdx.app.error("Background", "Default background also failed to load. Background will be blank.");
                    if (backgroundTexture != null) backgroundTexture.dispose();
                    backgroundTexture = null; // Prevent NPEs in render
                    this.currentTexturePath = null;
                    textureWidth = 0; // Reset dimensions
                    textureHeight = 0;
                }
            }
        }


        public void update(float deltaTime) {
            // This method can be used for future background animations or effects.
            // For parallax scrolling based on camera, all logic is in render().
        }

        public void render(SpriteBatch batch, OrthographicCamera camera) {
            if (backgroundTexture == null || textureWidth == 0) { // Don't render if texture failed to load or has no width
                return;
            }

            float cameraViewLeft = camera.position.x - camera.viewportWidth * camera.zoom / 2f;
            float cameraViewRight = camera.position.x + camera.viewportWidth * camera.zoom / 2f;

            float parallaxOffset = camera.position.x * scrollSpeed;

            // Ensure the loop condition handles cases where textureWidth might be zero to prevent infinite loops.
            // The condition textureWidth == 0 is checked at the beginning.
            for (float x = (float)Math.floor((cameraViewLeft - parallaxOffset) / textureWidth) * textureWidth + parallaxOffset; // Adjusted logic slightly
                 x < cameraViewRight;
                 x += textureWidth) {
                // Draw the background from y=0 up to camera.viewportHeight or level height.
                // For simplicity, drawing at y=0 with its original height.
                // If viewportHeight is desired, texture scaling or tiling vertically would be needed if textureHeight < viewportHeight.
                batch.draw(backgroundTexture, x, 0, textureWidth, textureHeight);
            }
        }

        public void dispose() {
            if (backgroundTexture != null) {
                backgroundTexture.dispose();
                backgroundTexture = null;
            }
        }
    }

    ================
    File: core/src/main/java/io/github/game/editor/AddEnemyCommand.java
    ================
    package io.github.game.editor;

    import io.github.game.Level;

    public class AddEnemyCommand implements EditorCommand {
        private Level level;
        private Level.EnemyData enemyData;

        public AddEnemyCommand(Level level, Level.EnemyData enemyData) {
            this.level = level;
            this.enemyData = enemyData;
        }

        @Override
        public void execute() {
            level.addEnemy(enemyData);
        }

        @Override
        public void undo() {
            level.removeEnemy(enemyData);
        }
    }

    ================
    File: core/src/main/java/io/github/game/editor/AddPlatformCommand.java
    ================
    // File: core/src/main/java/io/github/game/editor/AddPlatformCommand.java
    package io.github.game.editor;

    import io.github.game.Level;
    import io.github.game.Level.PlatformData; // If PlatformData is public inner class

    public class AddPlatformCommand implements EditorCommand {
        private Level level;
        private PlatformData platformData;

        public AddPlatformCommand(Level level, PlatformData platformData) {
            this.level = level;
            this.platformData = platformData;
        }

        @Override
        public void execute() {
            level.addPlatform(platformData);
        }

        @Override
        public void undo() {
            level.removePlatform(platformData); // Assumes Level.removePlatform can remove by instance
        }
    }

    ================
    File: core/src/main/java/io/github/game/editor/ClearLevelCommand.java
    ================
    // File: core/src/main/java/io/github/game/editor/ClearLevelCommand.java
    package io.github.game.editor;

    import com.badlogic.gdx.utils.Array;
    import io.github.game.Level;
    import io.github.game.Level.PlatformData;

    public class ClearLevelCommand implements EditorCommand {
        private Level level;
        private Array<PlatformData> originalPlatforms;
        private PlatformData defaultGroundAdded; // The specific instance of default ground added

        public ClearLevelCommand(Level level, Array<PlatformData> platformsBeforeClear, PlatformData defaultGroundInstance) {
            this.level = level;
            this.originalPlatforms = new Array<>(platformsBeforeClear); // Store a copy of the state before clear
            this.defaultGroundAdded = defaultGroundInstance;
        }

        @Override
        public void execute() {
            level.getPlatformData().clear();
            if (defaultGroundAdded != null) {
                level.addPlatform(defaultGroundAdded); // Add the specific instance
            }
        }

        @Override
        public void undo() {
            level.getPlatformData().clear();
            level.getPlatformData().addAll(originalPlatforms);
        }
    }

    ================
    File: core/src/main/java/io/github/game/editor/EditorCommand.java
    ================
    // File: core/src/main/java/io/github/game/editor/EditorCommand.java
    package io.github.game.editor;

    public interface EditorCommand {
        void execute();
        void undo();
    }

    ================
    File: core/src/main/java/io/github/game/editor/RemoveEnemyCommand.java
    ================
    // File: core/src/main/java/io/github/game/editor/RemoveEnemyCommand.java
    package io.github.game.editor;

    import io.github.game.Level;

    public class RemoveEnemyCommand implements EditorCommand {
        private Level level;
        private Level.EnemyData enemyData;
        // private int originalIndex = -1; // Optional for restoring order

        public RemoveEnemyCommand(Level level, Level.EnemyData enemyData) {
            this.level = level;
            this.enemyData = enemyData;
            // this.originalIndex = level.getEnemyData().indexOf(enemyData, true);
        }

        @Override
        public void execute() {
            level.removeEnemy(enemyData);
        }

        @Override
        public void undo() {
            // if (originalIndex != -1 && originalIndex < level.getEnemyData().size) {
            //    level.getEnemyData().insert(originalIndex, enemyData);
            // } else {
            level.addEnemy(enemyData); // Adds to the end if index not used
            // }
        }
    }

    ================
    File: core/src/main/java/io/github/game/editor/RemovePlatformCommand.java
    ================
    // File: core/src/main/java/io/github/game/editor/RemovePlatformCommand.java
    package io.github.game.editor;

    import io.github.game.Level;
    import io.github.game.Level.PlatformData;
    import com.badlogic.gdx.utils.Array; // For storing index if needed

    public class RemovePlatformCommand implements EditorCommand {
        private Level level;
        private PlatformData platformData;
        private int originalIndex = -1; // Optional: for restoring exact order

        public RemovePlatformCommand(Level level, PlatformData platformData) {
            this.level = level;
            this.platformData = platformData;
            // To store originalIndex, you'd find it before removing:
            // this.originalIndex = level.getPlatformData().indexOf(platformData, true);
        }

        @Override
        public void execute() {
            // If originalIndex was stored, ensure it's still valid or re-find before removal.
            // For simplicity, we assume Level.removePlatform works by instance.
            level.removePlatform(platformData);
        }

        @Override
        public void undo() {
            // if (originalIndex != -1 && originalIndex < level.getPlatformData().size) {
            //    level.getPlatformData().insert(originalIndex, platformData);
            // } else {
            level.addPlatform(platformData); // Adds to the end if index not used
            // }
        }
    }

    ================
    File: core/src/main/java/io/github/game/enemies/Enemy.java
    ================
    // File: core/src/main/java/io/github/game/enemies/Enemy.java
    package io.github.game.enemies;

    import com.badlogic.gdx.graphics.g2d.SpriteBatch;
    // Remove TextureAtlas import if not used by any direct Enemy subclass that NEEDS an atlas
    import com.badlogic.gdx.math.Rectangle;
    import com.badlogic.gdx.math.Vector2;
    import com.badlogic.gdx.utils.Array;
    import com.badlogic.gdx.utils.Disposable;
    import io.github.game.Platform;
    import io.github.game.Player;

    public abstract class Enemy implements Disposable {
        public enum EnemyState {
            WALKING,
            STOMPED,
            DEAD
        }

        protected Vector2 position;
        protected Vector2 velocity;
        protected Rectangle bounds;
        protected boolean isAlive;
        protected boolean facingRight;
        protected float stateTimer;
        protected EnemyState currentState;
        // Removed: protected TextureAtlas enemyAtlas;

        public static final float GRAVITY = -900f;

        // Modified Constructor: No longer takes TextureAtlas
        public Enemy(float x, float y, float width, float height) {
            this.position = new Vector2(x, y);
            this.velocity = new Vector2(0, 0);
            this.bounds = new Rectangle(x, y, width, height);
            this.isAlive = true;
            this.facingRight = false;
            this.stateTimer = 0f;
            this.currentState = EnemyState.WALKING;
        }

        public void update(float deltaTime, Array<Platform> platforms, Player player) {
            if (!isAlive && currentState != EnemyState.STOMPED) return;

            stateTimer += deltaTime;
            updateLogic(deltaTime, platforms, player);

            if (currentState == EnemyState.WALKING) {
                velocity.y += GRAVITY * deltaTime;
            }

            position.x += velocity.x * deltaTime;
            bounds.setX(position.x);
            checkHorizontalPlatformCollisions(platforms);

            position.y += velocity.y * deltaTime;
            bounds.setY(position.y);
            checkVerticalPlatformCollisions(platforms);

            if (position.y < -bounds.height * 2) {
                isAlive = false;
                currentState = EnemyState.DEAD;
            }
        }

        protected abstract void updateLogic(float deltaTime, Array<Platform> platforms, Player player);
        public abstract void render(SpriteBatch batch);
        public abstract void onStompedBy(Player player);
        public abstract boolean onCollisionWith(Player player);

        protected void checkHorizontalPlatformCollisions(Array<Platform> platforms) {
            for (Platform platform : platforms) {
                if (platform.getType() == Platform.PlatformType.COIN) continue;
                if (bounds.overlaps(platform.getBounds())) {
                    if (velocity.x > 0) {
                        position.x = platform.getBounds().x - bounds.width;
                        velocity.x = -Math.abs(velocity.x);
                        facingRight = false;
                    } else if (velocity.x < 0) {
                        position.x = platform.getBounds().x + platform.getBounds().width;
                        velocity.x = Math.abs(velocity.x);
                        facingRight = true;
                    }
                    bounds.setX(position.x);
                }
            }
        }

        protected void checkVerticalPlatformCollisions(Array<Platform> platforms) {
            boolean grounded = false;
            for (Platform platform : platforms) {
                if (platform.getType() == Platform.PlatformType.COIN) continue;
                if (bounds.overlaps(platform.getBounds())) {
                    if (velocity.y <= 0 && position.y + bounds.height * 0.5f >= platform.getBounds().y + platform.getBounds().height) {
                        position.y = platform.getBounds().y + platform.getBounds().height;
                        velocity.y = 0;
                        grounded = true;
                    } else if (velocity.y > 0 && position.y < platform.getBounds().y) {
                        position.y = platform.getBounds().y - bounds.height;
                        velocity.y = 0;
                    }
                    bounds.setY(position.y);
                }
            }
            if (currentState == EnemyState.WALKING && grounded) {
                // Simplified edge detection - if moving and no ground directly ahead and below, turn.
                // This requires careful implementation of "ahead and below".
                // For now, turning is primarily handled by hitting walls or more explicit edge detection in Goomba.
            }
        }

        public Rectangle getBounds() { return bounds; }
        public boolean isAlive() { return isAlive; }
        public Vector2 getPosition() { return position; }
        public Vector2 getVelocity() { return velocity; }
        public EnemyState getCurrentState() { return currentState; }

        @Override
        public void dispose() {
            // Subclasses responsible for disposing their own textures if they own them.
            // If textures are passed in and shared, Main/LevelEditor disposes them.
        }
    }

    ================
    File: core/src/main/java/io/github/game/enemies/EnemyType.java
    ================
    // File: core/src/main/java/io/github/game/enemies/EnemyType.java
    package io.github.game.enemies;

    public enum EnemyType {
        GOOMBA("Goomba");
        // Add other enemy types here in the future, e.g., KOOPA_TROOPA

        private final String displayName;

        EnemyType(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }

        @Override
        public String toString() {
            return displayName;
        }
    }

    ================
    File: core/src/main/java/io/github/game/enemies/Goomba.java
    ================
    // File: core/src/main/java/io/github/game/enemies/Goomba.java
    package io.github.game.enemies;

    import com.badlogic.gdx.graphics.Texture;
    import com.badlogic.gdx.graphics.g2d.Animation;
    import com.badlogic.gdx.graphics.g2d.SpriteBatch;
    import com.badlogic.gdx.graphics.g2d.TextureRegion;
    import com.badlogic.gdx.math.Rectangle;
    import com.badlogic.gdx.utils.Array;
    import io.github.game.Platform;
    import io.github.game.Player;
    import io.github.game.SoundManager; // Make sure SoundManager is accessible

    public class Goomba extends Enemy {
        public static final float WIDTH = 32f;
        public static final float HEIGHT = 32f;
        private static final float COLLISION_WIDTH = 28f;
        private static final float COLLISION_HEIGHT = 28f;
        private static final float SPEED = 40f; // Slightly slower for more classic feel
        private static final float STOMP_DURATION = 0.5f;

        private Animation<TextureRegion> walkAnimation;
        private TextureRegion squashedTextureRegion; // Changed from Texture to TextureRegion

        // Modified Constructor to take Textures (or TextureRegions)
        public Goomba(Texture walkFrame1Tex, Texture walkFrame2Tex, Texture squashedTex, float x, float y) {
            super(x, y, COLLISION_WIDTH, COLLISION_HEIGHT); // Enemy constructor sets facingRight = false by default

            Array<TextureRegion> frames = new Array<>();
            frames.add(new TextureRegion(walkFrame1Tex));
            frames.add(new TextureRegion(walkFrame2Tex));
            walkAnimation = new Animation<>(0.25f, frames, Animation.PlayMode.LOOP); // Slower animation

            this.squashedTextureRegion = new TextureRegion(squashedTex);
            // If squashedTex is just one of the walk frames, it's fine.
            // Example: if no specific squashed sprite, use walkFrame1Tex for squashedTextureRegion

            // Initial velocity: Enemy.facingRight is false by default, so Goomba starts moving left.
            velocity.x = facingRight ? SPEED : -SPEED;
        }

        @Override
        protected void updateLogic(float deltaTime, Array<Platform> platforms, Player player) {
            if (currentState == EnemyState.STOMPED) {
                velocity.x = 0;
                if (stateTimer > STOMP_DURATION) {
                    isAlive = false;
                    currentState = EnemyState.DEAD;
                }
                return;
            }

            if (currentState == EnemyState.WALKING) {
                // Edge detection logic (simple version: turn if no ground immediately ahead)
                // Check slightly in front and down, relative to movement direction
                float lookAheadOffset = facingRight ? bounds.width : -1; // Small offset in front of the bounding box
                float lookAheadX = position.x + lookAheadOffset;
                float lookDownY = position.y - 1; // Check just below the Goomba's feet

                boolean groundAhead = false;
                for (Platform p : platforms) {
                    if (p.getType() == Platform.PlatformType.COIN) continue;
                    // A small feeler rectangle for ground detection ahead
                    Rectangle feeler = new Rectangle(lookAheadX, lookDownY, 1, 1);
                    if (p.getBounds().overlaps(feeler)) {
                        groundAhead = true;
                        break;
                    }
                }
                if (!groundAhead && velocity.y == 0) { // If on ground (vy=0) and no ground ahead
                    facingRight = !facingRight; // Turn around
                    velocity.x = facingRight ? SPEED : -SPEED; // Update velocity based on new direction
                }
            }
        }

        @Override
        public void render(SpriteBatch batch) {
            if (!isAlive && currentState != EnemyState.STOMPED) return;

            TextureRegion currentFrame = null;
            if (currentState == EnemyState.STOMPED) {
                currentFrame = squashedTextureRegion;
            } else {
                currentFrame = walkAnimation.getKeyFrame(stateTimer, true);
            }

            if (currentFrame != null) {
                float drawX = position.x - (WIDTH - COLLISION_WIDTH) / 2f;
                float drawY = position.y; // Collision bounds Y is usually bottom
                float drawWidth = WIDTH;
                float drawHeight = (currentState == EnemyState.STOMPED) ? HEIGHT / 2f : HEIGHT;

                // If sprites are drawn facing LEFT by default:
                // - To move LEFT (facingRight = false), don't flip (flipX = false).
                // - To move RIGHT (facingRight = true), flip (flipX = true).
                // This means flipX should be true when facingRight is true.
                boolean flipX = facingRight; // Corrected logic

                batch.draw(currentFrame,
                    flipX ? drawX + drawWidth : drawX, // If flipping, adjust x-coordinate to keep position
                    drawY,
                    flipX ? -drawWidth : drawWidth,    // Negative width flips the texture region
                    drawHeight);
            }
        }

        @Override
        public void onStompedBy(Player player) {
            if (currentState == EnemyState.WALKING) {
                currentState = EnemyState.STOMPED;
                velocity.set(0, 0);
                stateTimer = 0f;
                // SoundManager.getInstance().playEnemyStomp(); // Example: play stomp sound
            }
        }

        @Override
        public boolean onCollisionWith(Player player) {
            return currentState == EnemyState.WALKING; // Harmful only if walking
        }

        // No need for dispose here if Textures are managed externally (by Main.java)
    }

    ================
    File: core/src/main/java/io/github/game/Level.java
    ================
    // File: core/src/main/java/io/github/game/Level.java
    package io.github.game;

    import com.badlogic.gdx.utils.Array;
    import com.badlogic.gdx.utils.Json;
    import com.badlogic.gdx.utils.JsonValue;
    import com.badlogic.gdx.utils.ObjectMap;

    public class Level implements Json.Serializable {
        public static class PlatformData {
            public float x, y, width, height;
            public Platform.PlatformType type;
            public Powerup.PowerupType containedPowerup;

            public PlatformData() {}

            public PlatformData(float x, float y, float width, float height, Platform.PlatformType type) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.containedPowerup = null;
            }
        }

        public static class EnemyData {
            public float x, y;
            public String type; // e.g., "GOOMBA"

            public EnemyData() {} // For JSON deserialization

            public EnemyData(float x, float y, String type) {
                this.x = x;
                this.y = y;
                this.type = type;
            }
        }

        private String name;
        private Array<PlatformData> platformData;
        private Array<EnemyData> enemyData; // ADDED
        private float playerStartX, playerStartY;
        private String backgroundMusic;
        private float musicVolume;
        private String backgroundTexturePath;
        private ObjectMap<String, Powerup.PowerupType> questionBlockContents;



        public Level() {
            this.name = "Untitled Level";
            this.platformData = new Array<>();
            this.enemyData = new Array<>(); // ADDED: Initialize
            this.playerStartX = 150;
            this.playerStartY = Platform.GROUND_TILE_SIZE * 2;
            this.backgroundMusic = "music/level1.mp3";
            this.musicVolume = 0.5f;
            this.backgroundTexturePath = Background.DEFAULT_BACKGROUND_PATH; // Use default from Background
            this.questionBlockContents = new ObjectMap<>();
        }

        public Level(String name) {
            this();
            this.name = name;
        }

        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public Array<PlatformData> getPlatformData() { return platformData; }

        public float getPlayerStartX() { return playerStartX; }
        public void setPlayerStartX(float x) { this.playerStartX = x; }

        public float getPlayerStartY() { return playerStartY; }
        public void setPlayerStartY(float y) { this.playerStartY = y; }

        public String getBackgroundMusic() { return backgroundMusic; }
        public void setBackgroundMusic(String music) { this.backgroundMusic = music; }

        public float getMusicVolume() { return musicVolume; }
        public void setMusicVolume(float volume) { this.musicVolume = volume; }

        public Array<EnemyData> getEnemyData() { return enemyData; }
        public String getBackgroundTexturePath() { return backgroundTexturePath; } // Added Getter
        public void setBackgroundTexturePath(String path) { this.backgroundTexturePath = path; } // Added Setter


        public void setQuestionBlockContent(String blockId, Powerup.PowerupType powerup) {
            questionBlockContents.put(blockId, powerup);
        }

        public Powerup.PowerupType getQuestionBlockContent(String blockId) {
            return questionBlockContents.get(blockId);
        }


        public void addPlatform(PlatformData data) {
            platformData.add(data);
        }

        public void removePlatform(PlatformData data) {
            platformData.removeValue(data, true);
        }

        public Array<Platform> createPlatforms() {
            Array<Platform> platforms = new Array<>();
            for (PlatformData data : platformData) {
                platforms.add(new Platform(data.x, data.y, data.width, data.height, data.type));
            }
            return platforms;
        }

        public void addEnemy(EnemyData data) {
            enemyData.add(data);
        }

        public void removeEnemy(EnemyData data) {
            enemyData.removeValue(data, true);
        }
        @Override
        public void write(Json json) {
            json.writeValue("name", name);
            json.writeValue("playerStartX", playerStartX);
            json.writeValue("playerStartY", playerStartY);
            json.writeValue("backgroundMusic", backgroundMusic);
            json.writeValue("musicVolume", musicVolume);
            json.writeValue("backgroundTexturePath", backgroundTexturePath); // Added serialization
            json.writeValue("platforms", platformData);
            json.writeValue("enemies", enemyData);
            json.writeValue("questionBlockContents", questionBlockContents);
        }

        @Override
        public void read(Json json, JsonValue jsonData) {
            name = jsonData.getString("name");
            playerStartX = jsonData.getFloat("playerStartX");
            playerStartY = jsonData.getFloat("playerStartY");
            backgroundMusic = jsonData.getString("backgroundMusic", "music/level1.mp3");
            musicVolume = jsonData.getFloat("musicVolume", 0.5f);
            backgroundTexturePath = jsonData.getString("backgroundTexturePath", Background.DEFAULT_BACKGROUND_PATH);

            platformData.clear();
            JsonValue platformsJson = jsonData.get("platforms");
            if (platformsJson != null) {
                for (JsonValue platformJson : platformsJson) {
                    PlatformData data = json.readValue(PlatformData.class, platformJson); // Simpler read
                    platformData.add(data);
                }
            }

            enemyData.clear(); // ADDED: Deserialize enemies
            JsonValue enemiesJson = jsonData.get("enemies");
            if (enemiesJson != null) {
                for (JsonValue enemyJson : enemiesJson) {
                    EnemyData data = new EnemyData();
                    data.x = enemyJson.getFloat("x");
                    data.y = enemyJson.getFloat("y");
                    data.type = enemyJson.getString("type");
                    enemyData.add(data);
                }
            }


            questionBlockContents.clear();
            JsonValue contentsJson = jsonData.get("questionBlockContents");
            if (contentsJson != null) {
                for (JsonValue.JsonIterator it = contentsJson.iterator(); it.hasNext(); ) {
                    JsonValue entry = it.next();
                    try {
                        questionBlockContents.put(entry.name, Powerup.PowerupType.valueOf(entry.asString()));
                    } catch (IllegalArgumentException e) {
                        System.err.println("Warning: Unknown PowerupType '" + entry.asString() + "' for question block ID '" + entry.name + "'. Skipping.");
                    }
                }
            }
        }

    }

    ================
    File: core/src/main/java/io/github/game/LevelEditor.java
    ================
    // File: core/src/main/java/io/github/game/LevelEditor.java
    package io.github.game;

    import com.badlogic.gdx.Gdx;
    import com.badlogic.gdx.Input;
    import com.badlogic.gdx.files.FileHandle;
    import com.badlogic.gdx.graphics.Color;
    import com.badlogic.gdx.graphics.OrthographicCamera;
    import com.badlogic.gdx.graphics.Texture;
    import com.badlogic.gdx.graphics.g2d.BitmapFont;
    import com.badlogic.gdx.graphics.g2d.SpriteBatch;
    import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
    import com.badlogic.gdx.math.Rectangle;
    import com.badlogic.gdx.math.Vector3;
    import com.badlogic.gdx.utils.Array;
    import com.badlogic.gdx.utils.Json;

    import java.util.ArrayDeque;

    import io.github.game.editor.EditorCommand;
    import io.github.game.editor.AddPlatformCommand;
    import io.github.game.editor.RemovePlatformCommand;
    import io.github.game.editor.ClearLevelCommand;
    import io.github.game.editor.AddEnemyCommand;
    import io.github.game.editor.RemoveEnemyCommand;

    public class LevelEditor {
        private static final float GRID_SIZE = 32f;
        private static final float UI_PANEL_WIDTH = 220f;
        private static final float DEFAULT_GROUND_WIDTH_MULTIPLIER = 100f;
        private static final float DEFAULT_GROUND_HEIGHT_MULTIPLIER = 2f;

        private Level currentLevel;

        private enum EditorTool {
            PLATFORM,
            GOOMBA
        }
        private EditorTool currentTool = EditorTool.PLATFORM;
        private Platform.PlatformType selectedPlatformType = Platform.PlatformType.GRAVEL_BLOCK;

        private Level.PlatformData selectedPlatform;
        private Level.EnemyData selectedEnemy;

        private boolean isDragging = false;
        private float dragStartX, dragStartY;

        private ShapeRenderer shapeRenderer;
        private BitmapFont font;
        private Vector3 mousePos;

        private Array<Rectangle> platformTypeButtons;
        private Array<Platform.PlatformType> buttonPlatformTypes;
        private Rectangle goombaButton;
        private Rectangle saveButton, loadButton, clearButton, playButton, previewButton;

        private Rectangle placementPreviewRect;
        private boolean showPlacementPreview = true;

        public enum EditorUIMode { EDITING, LEVEL_PREVIEW }
        private EditorUIMode currentUIMode = EditorUIMode.EDITING;
        private boolean hasUnappliedChanges = false;
        private BitmapFont notificationFont;

        private ArrayDeque<EditorCommand> undoStack = new ArrayDeque<>();
        private ArrayDeque<EditorCommand> redoStack = new ArrayDeque<>();
        private static final int MAX_HISTORY_SIZE = 100;

        private Array<String> availableBackgroundPaths;
        private Array<String> availableBackgroundNames;
        private Array<Rectangle> backgroundSelectorButtons;

        private Texture goombaPreviewTexture;

        public LevelEditor() {
            this.currentLevel = new Level("New Level");
            this.shapeRenderer = new ShapeRenderer();
            this.font = new BitmapFont();
            this.notificationFont = new BitmapFont();
            this.mousePos = new Vector3();
            this.placementPreviewRect = new Rectangle();

            try {
                goombaPreviewTexture = new Texture(Gdx.files.internal("mario_sprites/enemies/goomba_walk_0.png"));
            } catch (Exception e) {
                Gdx.app.error("LevelEditor", "Failed to load goomba_walk_0.png for editor preview: " + e.getMessage(), e);
                goombaPreviewTexture = null;
            }

            this.availableBackgroundPaths = new Array<>();
            this.availableBackgroundNames = new Array<>();
            this.backgroundSelectorButtons = new Array<>();

            availableBackgroundPaths.add("mario_sprites/backgrounds/background_0.png");
            availableBackgroundNames.add("Sky (Default)");
            availableBackgroundPaths.add("mario_sprites/backgrounds/background_1.png");
            availableBackgroundNames.add("Hills");
            availableBackgroundPaths.add("mario_sprites/backgrounds/background_2.png");
            availableBackgroundNames.add("Night Sky");

            initializeUI();

            Level.PlatformData initialGround = new Level.PlatformData(
                0, 0, GRID_SIZE * DEFAULT_GROUND_WIDTH_MULTIPLIER, GRID_SIZE * DEFAULT_GROUND_HEIGHT_MULTIPLIER, Platform.PlatformType.GROUND
            );
            currentLevel.addPlatform(initialGround);
            this.hasUnappliedChanges = true;
        }

        private void initializeUI() {
            platformTypeButtons = new Array<>();
            buttonPlatformTypes = new Array<>();
            backgroundSelectorButtons.clear(); // Ensure it's clear before repopulating

            float viewportHeight = Gdx.graphics.getHeight(); // Use Gdx.graphics.getHeight() for actual screen height
            float currentY = viewportHeight - 20f; // Start from top of screen
            float buttonHeight = 28f;
            float buttonSpacing = 7f;
            float uiElementMargin = 10f;
            float buttonWidth = UI_PANEL_WIDTH - 2 * uiElementMargin;
            float sectionTitleHeight = 20f; // Approximate height needed for a title string
            float spaceAfterTitle = 5f; // Space between a title and the first button in its section

            // --- Platforms Section ---
            currentY -= sectionTitleHeight; // Space for "Platforms:" title text
            float nextButtonBottomY = currentY - spaceAfterTitle - buttonHeight;
            for (Platform.PlatformType type : Platform.PlatformType.values()) {
                Rectangle button = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
                platformTypeButtons.add(button);
                buttonPlatformTypes.add(type);
                nextButtonBottomY -= (buttonHeight + buttonSpacing);
            }
            currentY = nextButtonBottomY + buttonSpacing; // Top of the area after last platform button


            // --- Enemies Section ---
            currentY -= sectionTitleHeight; // Space for "Enemies:" title text
            nextButtonBottomY = currentY - spaceAfterTitle - buttonHeight;
            goombaButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
            currentY = nextButtonBottomY; // Top of the area after goomba button

            // --- Controls Section ---
            currentY -= sectionTitleHeight; // Space for "Controls:" title text
            nextButtonBottomY = currentY - spaceAfterTitle - buttonHeight;
            saveButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
            nextButtonBottomY -= (buttonHeight + buttonSpacing);
            loadButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
            nextButtonBottomY -= (buttonHeight + buttonSpacing);
            clearButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
            nextButtonBottomY -= (buttonHeight + buttonSpacing);
            previewButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
            nextButtonBottomY -= (buttonHeight + buttonSpacing);
            playButton = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
            currentY = nextButtonBottomY; // Top of the area after play button

            // --- Backgrounds Section ---
            currentY -= sectionTitleHeight; // Space for "Backgrounds:" title text
            nextButtonBottomY = currentY - spaceAfterTitle - buttonHeight;
            for (int i = 0; i < availableBackgroundPaths.size; i++) {
                Rectangle button = new Rectangle(uiElementMargin, nextButtonBottomY, buttonWidth, buttonHeight);
                backgroundSelectorButtons.add(button); // Store the button
                nextButtonBottomY -= (buttonHeight + buttonSpacing);
            }
            // currentY is now at the top of the area after the last background button
        }


        public void resize(int width, int height) {
            initializeUI();
        }

        private void executeCommand(EditorCommand command) {
            command.execute();
            undoStack.addLast(command);
            if (undoStack.size() > MAX_HISTORY_SIZE) undoStack.removeFirst();
            redoStack.clear();
            hasUnappliedChanges = true;
            selectedPlatform = null;
            selectedEnemy = null;
        }

        private void undo() {
            if (!undoStack.isEmpty()) {
                EditorCommand command = undoStack.removeLast();
                command.undo();
                redoStack.addLast(command);
                if (redoStack.size() > MAX_HISTORY_SIZE) redoStack.removeFirst();
                hasUnappliedChanges = true;
                selectedPlatform = null;
                selectedEnemy = null;
            }
        }

        private void redo() {
            if (!redoStack.isEmpty()) {
                EditorCommand command = redoStack.removeLast();
                command.execute();
                undoStack.addLast(command);
                if (undoStack.size() > MAX_HISTORY_SIZE) undoStack.removeFirst();
                hasUnappliedChanges = true;
                selectedPlatform = null;
                selectedEnemy = null;
            }
        }

        public void update(OrthographicCamera camera) {
            mousePos.set(Gdx.input.getX(), Gdx.input.getY(), 0);
            camera.unproject(mousePos);

            if (currentUIMode == EditorUIMode.LEVEL_PREVIEW) {
                if (Gdx.input.isKeyJustPressed(Input.Keys.ESCAPE)) {
                    currentUIMode = EditorUIMode.EDITING;
                }
                return;
            }

            float snappedX = Math.round(mousePos.x / GRID_SIZE) * GRID_SIZE;
            float snappedY = Math.round(mousePos.y / GRID_SIZE) * GRID_SIZE;

            if (showPlacementPreview && mousePos.x > UI_PANEL_WIDTH) {
                if (currentTool == EditorTool.PLATFORM && isDragging) {
                    float width = Math.abs(snappedX - dragStartX) + GRID_SIZE;
                    float height = Math.abs(snappedY - dragStartY) + GRID_SIZE;
                    float x = Math.min(snappedX, dragStartX);
                    float y = Math.min(snappedY, dragStartY);
                    placementPreviewRect.set(x, y, width, height);
                } else { // For single-grid items like Goomba or non-draggable platforms
                    placementPreviewRect.set(snappedX, snappedY, GRID_SIZE, GRID_SIZE);
                }
            } else {
                placementPreviewRect.set(0,0,0,0); // Hide preview if mouse is over UI or preview is off
            }
            handleEditorInput(snappedX, snappedY, camera);
        }

        private void handleEditorInput(float snappedX, float snappedY, OrthographicCamera camera) {
            boolean ctrlPressed = Gdx.input.isKeyPressed(Input.Keys.CONTROL_LEFT) || Gdx.input.isKeyPressed(Input.Keys.CONTROL_RIGHT);
            if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.Z)) { undo(); return; }
            if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.Y)) { redo(); return; }

            float camSpeed = 300 * Gdx.graphics.getDeltaTime();
            if (Gdx.input.isKeyPressed(Input.Keys.A) || Gdx.input.isKeyPressed(Input.Keys.LEFT)) camera.position.x -= camSpeed;
            if (Gdx.input.isKeyPressed(Input.Keys.D) || Gdx.input.isKeyPressed(Input.Keys.RIGHT)) camera.position.x += camSpeed;
            if (Gdx.input.isKeyPressed(Input.Keys.W) || Gdx.input.isKeyPressed(Input.Keys.UP)) camera.position.y += camSpeed;
            if (Gdx.input.isKeyPressed(Input.Keys.S) || Gdx.input.isKeyPressed(Input.Keys.DOWN)) camera.position.y -= camSpeed;
            camera.update();

            if (Gdx.input.isButtonJustPressed(Input.Buttons.LEFT)) handleLeftClick(snappedX, snappedY);
            if (Gdx.input.isButtonJustPressed(Input.Buttons.RIGHT)) handleRightClick(snappedX, snappedY);

            if (currentTool == EditorTool.PLATFORM && !Gdx.input.isButtonPressed(Input.Buttons.LEFT) && isDragging) {
                isDragging = false;
                if (placementPreviewRect.width >= GRID_SIZE && placementPreviewRect.height >= GRID_SIZE && mousePos.x > UI_PANEL_WIDTH) {
                    Level.PlatformData newPlatform = new Level.PlatformData(
                        placementPreviewRect.x, placementPreviewRect.y, placementPreviewRect.width, placementPreviewRect.height, selectedPlatformType
                    );
                    executeCommand(new AddPlatformCommand(currentLevel, newPlatform));
                }
            }

            if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.S)) saveLevel();
            if (ctrlPressed && Gdx.input.isKeyJustPressed(Input.Keys.L)) loadLevel();

            if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_1)) { currentTool = EditorTool.PLATFORM; selectedPlatformType = Platform.PlatformType.GROUND; selectedEnemy = null;}
            if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_2)) { currentTool = EditorTool.PLATFORM; selectedPlatformType = Platform.PlatformType.GRAVEL_BLOCK; selectedEnemy = null;}
            if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_3)) { currentTool = EditorTool.PLATFORM; selectedPlatformType = Platform.PlatformType.QUESTION_BLOCK; selectedEnemy = null;}
            if (Gdx.input.isKeyJustPressed(Input.Keys.NUM_4)) { currentTool = EditorTool.PLATFORM; selectedPlatformType = Platform.PlatformType.COIN; selectedEnemy = null;}
            if (Gdx.input.isKeyJustPressed(Input.Keys.G)) { currentTool = EditorTool.GOOMBA; selectedPlatform = null; }

            if (Gdx.input.isKeyJustPressed(Input.Keys.DEL) || Gdx.input.isKeyJustPressed(Input.Keys.BACKSPACE)) {
                if (selectedPlatform != null) {
                    executeCommand(new RemovePlatformCommand(currentLevel, selectedPlatform));
                    selectedPlatform = null; // Deselect after removal
                } else if (selectedEnemy != null) {
                    executeCommand(new RemoveEnemyCommand(currentLevel, selectedEnemy));
                    selectedEnemy = null; // Deselect after removal
                }
            }
        }

        private void handleLeftClick(float snappedX, float snappedY) {
            Vector3 screenPos = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0); // Screen coordinates for UI buttons

            // Check UI buttons first
            for (int i = 0; i < platformTypeButtons.size; i++) {
                if (isScreenButtonClicked(platformTypeButtons.get(i), screenPos)) {
                    currentTool = EditorTool.PLATFORM;
                    selectedPlatformType = buttonPlatformTypes.get(i);
                    selectedEnemy = null; // Deselect enemy if platform tool is chosen
                    return;
                }
            }
            if (goombaButton != null && isScreenButtonClicked(goombaButton, screenPos)) {
                currentTool = EditorTool.GOOMBA;
                selectedPlatform = null; // Deselect platform if enemy tool is chosen
                return;
            }
            if (saveButton != null && isScreenButtonClicked(saveButton, screenPos)) { saveLevel(); return; }
            if (loadButton != null && isScreenButtonClicked(loadButton, screenPos)) { loadLevel(); return; }
            if (clearButton != null && isScreenButtonClicked(clearButton, screenPos)) { clearLevel(); return; }
            if (previewButton != null && isScreenButtonClicked(previewButton, screenPos)) {
                currentUIMode = EditorUIMode.LEVEL_PREVIEW;
                selectedPlatform = null; selectedEnemy = null; isDragging = false;
                return;
            }
            if (playButton != null && isScreenButtonClicked(playButton, screenPos)) { /* Main handles P key */ return; }

            for (int i = 0; i < backgroundSelectorButtons.size; i++) {
                if (isScreenButtonClicked(backgroundSelectorButtons.get(i), screenPos)) {
                    String newBgPath = availableBackgroundPaths.get(i);
                    if (!newBgPath.equals(currentLevel.getBackgroundTexturePath())) {
                        currentLevel.setBackgroundTexturePath(newBgPath);
                        hasUnappliedChanges = true; // Ensure this triggers a background update in Main
                    }
                    return;
                }
            }

            // If click is not on UI, it's in the game world
            if (mousePos.x > UI_PANEL_WIDTH) {
                selectedPlatform = null; // Deselect by default
                selectedEnemy = null;   // Deselect by default
                boolean clickedExisting = false;

                // Check for clicking existing enemies first (smaller click targets usually)
                for (Level.EnemyData enemy : currentLevel.getEnemyData()) {
                    Rectangle rect = new Rectangle(enemy.x, enemy.y, GRID_SIZE, GRID_SIZE); // Assuming enemies are 1 grid cell
                    if (rect.contains(mousePos.x, mousePos.y)) {
                        selectedEnemy = enemy;
                        clickedExisting = true;
                        currentTool = EditorTool.GOOMBA; // Switch tool to enemy type clicked
                        selectedPlatform = null; // Deselect platform
                        break;
                    }
                }

                if (!clickedExisting) { // If no enemy was clicked, check for platforms
                    for (Level.PlatformData platform : currentLevel.getPlatformData()) {
                        Rectangle rect = new Rectangle(platform.x, platform.y, platform.width, platform.height);
                        if (rect.contains(mousePos.x, mousePos.y)) {
                            selectedPlatform = platform;
                            clickedExisting = true;
                            currentTool = EditorTool.PLATFORM; // Switch tool
                            selectedPlatformType = platform.type; // Select the type of the clicked platform
                            selectedEnemy = null; // Deselect enemy
                            break;
                        }
                    }
                }

                // If nothing existing was clicked, try to place new element
                if (!clickedExisting) {
                    if (currentTool == EditorTool.PLATFORM) {
                        boolean shiftPressed = Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT);
                        if (selectedPlatformType == Platform.PlatformType.GROUND || shiftPressed) { // Allow dragging for ground or if shift is held
                            isDragging = true;
                            dragStartX = snappedX;
                            dragStartY = snappedY;
                            placementPreviewRect.set(snappedX, snappedY, GRID_SIZE, GRID_SIZE); // Initial preview for drag
                        } else { // Place single block platform
                            Level.PlatformData newPlatform = new Level.PlatformData(
                                snappedX, snappedY, GRID_SIZE, GRID_SIZE, selectedPlatformType
                            );
                            executeCommand(new AddPlatformCommand(currentLevel, newPlatform));
                        }
                    } else if (currentTool == EditorTool.GOOMBA) {
                        Level.EnemyData newEnemy = new Level.EnemyData(snappedX, snappedY, "GOOMBA"); // Assuming Goomba for now
                        executeCommand(new AddEnemyCommand(currentLevel, newEnemy));
                    }
                }
            }
        }

        private void handleRightClick(float snappedX, float snappedY) {
            if (mousePos.x <= UI_PANEL_WIDTH) return; // Click is on UI panel, ignore for removal

            // Try removing enemies first
            for (int i = currentLevel.getEnemyData().size - 1; i >= 0; i--) {
                Level.EnemyData enemy = currentLevel.getEnemyData().get(i);
                Rectangle rect = new Rectangle(enemy.x, enemy.y, GRID_SIZE, GRID_SIZE); // Assuming Goombas are 1 grid cell for click detection
                if (rect.contains(mousePos.x, mousePos.y)) {
                    executeCommand(new RemoveEnemyCommand(currentLevel, enemy));
                    if (enemy == selectedEnemy) selectedEnemy = null; // Deselect if removed
                    return; // Removed one enemy, done for this click
                }
            }

            // If no enemy removed, try removing platforms
            for (int i = currentLevel.getPlatformData().size - 1; i >= 0; i--) {
                Level.PlatformData platform = currentLevel.getPlatformData().get(i);
                Rectangle rect = new Rectangle(platform.x, platform.y, platform.width, platform.height);
                if (rect.contains(mousePos.x, mousePos.y)) {
                    executeCommand(new RemovePlatformCommand(currentLevel, platform));
                    if (platform == selectedPlatform) selectedPlatform = null; // Deselect if removed
                    return; // Removed one platform, done
                }
            }
        }


        private boolean isScreenButtonClicked(Rectangle button, Vector3 screenPos) {
            // Convert screen Y (origin top-left) to UI Y (origin bottom-left for rectangle)
            float GdxYtoUIY = Gdx.graphics.getHeight() - screenPos.y;
            return button.contains(screenPos.x, GdxYtoUIY);
        }

        public void renderEditorElements(SpriteBatch batch, OrthographicCamera camera) {
            // 1. Draw Grid
            shapeRenderer.setProjectionMatrix(camera.combined);
            shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
            shapeRenderer.setColor(0.3f, 0.3f, 0.3f, 0.5f);
            float viewLeft = camera.position.x - camera.viewportWidth / 2f * camera.zoom;
            float viewRight = camera.position.x + camera.viewportWidth / 2f * camera.zoom;
            float viewBottom = camera.position.y - camera.viewportHeight / 2f * camera.zoom;
            float viewTop = camera.position.y + camera.viewportHeight / 2f * camera.zoom;
            for (float x = Math.round(viewLeft / GRID_SIZE) * GRID_SIZE; x < viewRight; x += GRID_SIZE) {
                shapeRenderer.line(x, viewBottom, x, viewTop);
            }
            for (float y = Math.round(viewBottom / GRID_SIZE) * GRID_SIZE; y < viewTop; y += GRID_SIZE) {
                shapeRenderer.line(viewLeft, y, viewRight, y);
            }
            shapeRenderer.end();

            // 2. Draw existing enemies (Goombas)
            if (goombaPreviewTexture != null) {
                batch.setProjectionMatrix(camera.combined);
                batch.begin();
                for (Level.EnemyData enemyData : currentLevel.getEnemyData()) {
                    if ("GOOMBA".equals(enemyData.type)) {
                        batch.draw(goombaPreviewTexture, enemyData.x, enemyData.y, GRID_SIZE, GRID_SIZE);
                    }
                    // Add other enemy type previews here if needed
                }
                batch.end();
            }

            // 3. Draw Selection Highlights
            shapeRenderer.setProjectionMatrix(camera.combined); // Ensure projection is set for shapes
            shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
            if (selectedPlatform != null) {
                shapeRenderer.setColor(Color.YELLOW);
                shapeRenderer.rect(selectedPlatform.x, selectedPlatform.y, selectedPlatform.width, selectedPlatform.height);
            }
            if (selectedEnemy != null) {
                shapeRenderer.setColor(Color.CYAN); // Different color for enemy selection
                shapeRenderer.rect(selectedEnemy.x, selectedEnemy.y, GRID_SIZE, GRID_SIZE); // Assuming GRID_SIZE for enemy highlight
            }
            shapeRenderer.end();


            // 4. Draw Placement Preview
            if (showPlacementPreview && mousePos.x > UI_PANEL_WIDTH && placementPreviewRect.width > 0 && placementPreviewRect.height > 0) {
                if (currentTool == EditorTool.PLATFORM && isDragging || // For platform dragging
                    currentTool != EditorTool.PLATFORM || // For single-cell items like Goomba
                    (currentTool == EditorTool.PLATFORM && !isDragging && !Gdx.input.isButtonPressed(Input.Buttons.LEFT)) // For single platform block before click
                ) {
                    // Draw rectangle preview for platforms or generic grid cell
                    shapeRenderer.setProjectionMatrix(camera.combined);
                    shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
                    shapeRenderer.setColor(0.5f, 0.5f, 1f, 0.5f); // Preview color
                    shapeRenderer.rect(placementPreviewRect.x, placementPreviewRect.y, placementPreviewRect.width, placementPreviewRect.height);
                    shapeRenderer.end();

                    // If Goomba tool, draw Goomba texture preview
                    if (currentTool == EditorTool.GOOMBA && goombaPreviewTexture != null) {
                        batch.setProjectionMatrix(camera.combined);
                        batch.begin();
                        batch.setColor(1, 1, 1, 0.5f); // Semi-transparent
                        batch.draw(goombaPreviewTexture, placementPreviewRect.x, placementPreviewRect.y, GRID_SIZE, GRID_SIZE);
                        batch.setColor(1, 1, 1, 1f); // Reset alpha
                        batch.end();
                    }
                }
            }

            // 5. Draw UI Panel (which handles its own batch and shapeRenderer)
            drawUIScreenPanel(batch); // Pass the main batch, it will set its own projection
        }

        private void drawUIScreenPanel(SpriteBatch batch) {
            // Setup projection matrices for UI drawing (origin bottom-left)
            // The batch instance is passed, so we set its projection here.
            // ShapeRenderer will also use an ortho matrix.
            batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
            shapeRenderer.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());

            // 1. Draw Panel Background (using ShapeRenderer)
            shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
            shapeRenderer.setColor(0.1f, 0.1f, 0.1f, 0.9f);
            shapeRenderer.rect(0, 0, UI_PANEL_WIDTH, Gdx.graphics.getHeight());
            shapeRenderer.end();

            // 2. Draw all Text (using SpriteBatch)
            batch.begin(); // Begin batch for all text drawing
            font.setColor(Color.WHITE);
            font.getData().setScale(0.9f); // Apply scaling for UI text

            float textX = 15f;          // Horizontal padding for text inside buttons/labels
            float titleX = 10f;         // Horizontal position for section titles
            float currentDrawingY = Gdx.graphics.getHeight() - 10f; // Start Y for drawing titles (top of text)
            float sectionTitleVisualHeight = font.getCapHeight() * font.getData().scaleY; // Approximate height of title text
            float spaceBelowTitle = 10f; // Space after a title text before buttons start
            float spaceBelowButtonBlock = 18f; // Space after a block of buttons before next title
            float buttonTextPaddingY = 4f; // Vertical padding for text baseline within a button

            // --- Platforms Section ---
            font.draw(batch, "Platforms:", titleX, currentDrawingY);
            currentDrawingY -= (sectionTitleVisualHeight + spaceBelowTitle); // Move Y down for buttons
            for (int i = 0; i < platformTypeButtons.size; i++) {
                Rectangle button = platformTypeButtons.get(i); // button.y is bottom of button
                Platform.PlatformType type = buttonPlatformTypes.get(i);
                // Draw text so its top is button.y + capHeight + padding
                font.draw(batch, type.toString(), textX, button.y + font.getCapHeight() + buttonTextPaddingY);
            }
            if (!platformTypeButtons.isEmpty()) {
                currentDrawingY = platformTypeButtons.peek().y - spaceBelowButtonBlock; // Position below last platform button
            } else {
                currentDrawingY -= spaceBelowButtonBlock; // If no buttons, just space down
            }

            // --- Enemies Section ---
            font.draw(batch, "Enemies:", titleX, currentDrawingY);
            currentDrawingY -= (sectionTitleVisualHeight + spaceBelowTitle);
            if (goombaButton != null) {
                font.draw(batch, "Goomba (G)", textX, goombaButton.y + font.getCapHeight() + buttonTextPaddingY);
                currentDrawingY = goombaButton.y - spaceBelowButtonBlock;
            } else {
                currentDrawingY -= spaceBelowButtonBlock;
            }

            // --- Controls Section ---
            font.draw(batch, "Controls:", titleX, currentDrawingY);
            currentDrawingY -= (sectionTitleVisualHeight + spaceBelowTitle);
            Rectangle[] controlButtons = {saveButton, loadButton, clearButton, previewButton, playButton};
            String[] controlLabels = {"Save (Ctrl+S)", "Load (Ctrl+L)", "Clear Level", "Preview Level", "Play Mode (P)"};
            Rectangle lastControlButton = null;
            for (int i = 0; i < controlButtons.length; i++) {
                if (controlButtons[i] != null) {
                    font.draw(batch, controlLabels[i], textX, controlButtons[i].y + font.getCapHeight() + buttonTextPaddingY);
                    lastControlButton = controlButtons[i];
                }
            }
            if (lastControlButton != null) {
                currentDrawingY = lastControlButton.y - spaceBelowButtonBlock;
            } else {
                currentDrawingY -= spaceBelowButtonBlock;
            }

            // --- Backgrounds Section ---
            font.draw(batch, "Backgrounds:", titleX, currentDrawingY);
            currentDrawingY -= (sectionTitleVisualHeight + spaceBelowTitle);
            Rectangle lastBackgroundButton = null;
            for (int i = 0; i < backgroundSelectorButtons.size; i++) {
                Rectangle button = backgroundSelectorButtons.get(i);
                String bgName = availableBackgroundNames.get(i);
                font.draw(batch, bgName, textX, button.y + font.getCapHeight() + buttonTextPaddingY);
                lastBackgroundButton = button;
            }
            if (lastBackgroundButton != null) {
                currentDrawingY = lastBackgroundButton.y - spaceBelowButtonBlock;
            } else {
                currentDrawingY -= spaceBelowButtonBlock;
            }

            // --- Instructions ---
            // Position instructions from a fixed point or relative to last drawn elements
            float instructionStartY = 180f; // Default Y from bottom for instructions
            // Adjust if there's content above, ensuring instructions don't overlap
            if(lastBackgroundButton != null) instructionStartY = Math.min(instructionStartY, lastBackgroundButton.y - 25f);
            else if (lastControlButton != null) instructionStartY = Math.min(instructionStartY, lastControlButton.y - 25f);
            else if (goombaButton != null) instructionStartY = Math.min(instructionStartY, goombaButton.y - 25f);
            else if (!platformTypeButtons.isEmpty()) instructionStartY = Math.min(instructionStartY, platformTypeButtons.peek().y - 25f);


            float lineHeight = 18f;
            if (instructionStartY > lineHeight * 8) { // Check if enough space for all lines
                String toolInfo = "Tool: " + currentTool.toString();
                if (currentTool == EditorTool.PLATFORM) {
                    toolInfo += " (" + selectedPlatformType.toString() + ")";
                }
                font.draw(batch, toolInfo, titleX, instructionStartY); instructionStartY -= lineHeight;
                font.draw(batch, "Ctrl+Z: Undo, Ctrl+Y: Redo", titleX, instructionStartY); instructionStartY -= lineHeight;
                font.draw(batch, "LMB: Place/Select", titleX, instructionStartY); instructionStartY -= lineHeight;
                font.draw(batch, "Shift+Drag: Resize Ground", titleX, instructionStartY); instructionStartY -= lineHeight;
                font.draw(batch, "RMB: Remove", titleX, instructionStartY); instructionStartY -= lineHeight;
                font.draw(batch, "Arrows/WASD: Move Cam", titleX, instructionStartY); instructionStartY -= lineHeight;
                font.draw(batch, "1-4: Platforms, G: Goomba", titleX, instructionStartY); instructionStartY -= lineHeight;
                font.draw(batch, "DEL/Bksp: Delete Selected", titleX, instructionStartY);
            }
            batch.end(); // End batch for all text drawing

            // 3. Draw Button Borders (using ShapeRenderer)
            shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
            // Platforms
            for (int i = 0; i < platformTypeButtons.size; i++) {
                Rectangle button = platformTypeButtons.get(i);
                Platform.PlatformType type = buttonPlatformTypes.get(i);
                shapeRenderer.setColor((currentTool == EditorTool.PLATFORM && type == selectedPlatformType) ? Color.GREEN : Color.WHITE);
                shapeRenderer.rect(button.x, button.y, button.width, button.height);
            }
            // Enemies
            if (goombaButton != null) {
                shapeRenderer.setColor((currentTool == EditorTool.GOOMBA) ? Color.GREEN : Color.WHITE);
                shapeRenderer.rect(goombaButton.x, goombaButton.y, goombaButton.width, goombaButton.height);
            }
            // Controls
            Color[] controlColors = {Color.WHITE, Color.WHITE, Color.WHITE, Color.ORANGE, Color.LIME}; // Matched to controlLabels
            for (int i = 0; i < controlButtons.length; i++) {
                if (controlButtons[i] != null) {
                    shapeRenderer.setColor(controlColors[i]);
                    shapeRenderer.rect(controlButtons[i].x, controlButtons[i].y, controlButtons[i].width, controlButtons[i].height);
                }
            }
            // Backgrounds
            for (int i = 0; i < backgroundSelectorButtons.size; i++) {
                Rectangle button = backgroundSelectorButtons.get(i);
                shapeRenderer.setColor(availableBackgroundPaths.get(i).equals(currentLevel.getBackgroundTexturePath()) ? Color.CYAN : Color.LIGHT_GRAY);
                shapeRenderer.rect(button.x, button.y, button.width, button.height);
            }
            shapeRenderer.end();

            font.getData().setScale(1.0f); // Reset font scale after UI drawing
        }


        public void renderPreviewNotification(SpriteBatch batch) {
            batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
            batch.begin();
            notificationFont.setColor(Color.YELLOW);
            // Ensure notificationFont is not null and draw
            if (notificationFont != null) {
                notificationFont.draw(batch, "Preview Mode - Press ESC to exit", 20, Gdx.graphics.getHeight() - 20);
            }
            batch.end();
        }

        private void saveLevel() {
            Json json = new Json();
            FileHandle dir = Gdx.files.local("levels/");
            if (!dir.exists()) {
                dir.mkdirs();
            }
            FileHandle file = Gdx.files.local("levels/" + currentLevel.getName() + ".json");
            file.writeString(json.prettyPrint(currentLevel), false);
            Gdx.app.log("LevelEditor", "Level saved: " + file.path());
            hasUnappliedChanges = false;
        }

        private void loadLevel() {
            String levelName = currentLevel.getName(); // Or prompt user for name
            FileHandle file = Gdx.files.local("levels/" + levelName + ".json");
            if (file.exists()) {
                Json json = new Json();
                try {
                    currentLevel = json.fromJson(Level.class, file.readString());
                    undoStack.clear(); redoStack.clear();
                    hasUnappliedChanges = false; // Level just loaded, no new changes yet
                    selectedPlatform = null; selectedEnemy = null;
                    // Important: Signal to Main to reload this new level data
                    // This is implicitly handled by hasUnappliedChanges = true below,
                    // but explicit true might be clearer if load itself implies changes.
                    // For now, the game reloads if hasUnappliedChanges is true in Main's loop.
                    // Let's set it to true to force a refresh.
                    hasUnappliedChanges = true;
                    Gdx.app.log("LevelEditor", "Level loaded: " + file.path());
                } catch (Exception e) {
                    Gdx.app.error("LevelEditor", "Failed to load/parse level: " + file.path(), e);
                }
            } else {
                Gdx.app.log("LevelEditor", "Level file not found: " + file.path());
            }
        }

        private void clearLevel() {
            Array<Level.PlatformData> platformsToBackup = new Array<>(currentLevel.getPlatformData());
            // Consider backing up enemies too if ClearLevelCommand is to be fully reversible for enemies
            Level.PlatformData defaultGroundInstance = new Level.PlatformData(
                0, 0, GRID_SIZE * DEFAULT_GROUND_WIDTH_MULTIPLIER, GRID_SIZE * DEFAULT_GROUND_HEIGHT_MULTIPLIER, Platform.PlatformType.GROUND
            );
            // For a true "clear", we also want to clear enemies. The command should ideally handle this.
            // For now, let's make the command simpler and clear enemies separately here.
            Array<Level.EnemyData> enemiesToBackup = new Array<>(currentLevel.getEnemyData()); // Backup enemies

            executeCommand(new ClearLevelCommand(currentLevel, platformsToBackup, defaultGroundInstance));
            // ClearLevelCommand only handles platforms. Manually clear enemies for the 'clear' action.
            // To make this undoable for enemies, ClearLevelCommand would need to store and restore enemies.
            // For simplicity now:
            currentLevel.getEnemyData().clear();

            hasUnappliedChanges = true;
        }

        public Level getCurrentLevel() { return currentLevel; }
        public EditorUIMode getCurrentUIMode() { return currentUIMode; }
        public boolean hasUnappliedChanges() { return hasUnappliedChanges; }
        public void clearChangesFlag() { hasUnappliedChanges = false; }

        public boolean isPlayButtonClicked() {
            Vector3 screenPos = new Vector3(Gdx.input.getX(), Gdx.input.getY(), 0);
            return playButton != null && Gdx.input.isButtonJustPressed(Input.Buttons.LEFT) &&
                isScreenButtonClicked(playButton, screenPos);
        }


        public void dispose() {
            if (shapeRenderer != null) shapeRenderer.dispose();
            if (font != null) font.dispose();
            if (notificationFont != null) notificationFont.dispose();
            if (goombaPreviewTexture != null) goombaPreviewTexture.dispose();
        }
    }

    ================
    File: core/src/main/java/io/github/game/Main.gwt.xml
    ================
    <?xml version="1.0" encoding="UTF-8"?>

    <!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit 2.11.0//EN" "https://www.gwtproject.org/doctype/2.11.0/gwt-module.dtd">
    <module>
      <!-- Paths to source are relative to this file and separated by slashes ('/'). -->
      <source path="" />

      <!-- Reflection includes may be needed for your code or library code. Each value is separated by periods ('.'). -->
      <!-- You can include a full package by not including the name of a type at the end. -->

    </module>

    ================
    File: core/src/main/java/io/github/game/Main.java
    ================
    // File: core/src/main/java/io/github/game/Main.java
    package io.github.game;

    import com.badlogic.gdx.ApplicationAdapter;
    import com.badlogic.gdx.Gdx;
    import com.badlogic.gdx.Input;
    import com.badlogic.gdx.graphics.GL20;
    import com.badlogic.gdx.graphics.OrthographicCamera;
    import com.badlogic.gdx.graphics.Texture;
    import com.badlogic.gdx.graphics.g2d.SpriteBatch;
    // No TextureAtlas import needed here if Goombas are the only enemies and use individual textures
    import com.badlogic.gdx.math.Rectangle;
    import com.badlogic.gdx.utils.Array;
    import com.badlogic.gdx.utils.viewport.FitViewport;
    import com.badlogic.gdx.utils.viewport.Viewport;

    // Import specific enemy classes
    import io.github.game.enemies.Enemy;
    import io.github.game.enemies.Goomba;

    public class Main extends ApplicationAdapter {
        // World and Game Mechanics Constants
        private static final float WORLD_WIDTH = 800;
        private static final float WORLD_HEIGHT = 480;
        private static final float GRAVITY = -900f;
        private static final float MOVE_SPEED = 200f;
        private static final float JUMP_INITIAL_IMPULSE = 380f;
        private static final float JUMP_HOLD_GRAVITY_MULTIPLIER = 0.40f;
        private static final float MAX_JUMP_HOLD_TIME = 0.22f;
        public static final float SCALED_BLOCK_SIZE = 32f;
        private static final float PLAYER_STOMP_BOUNCE_VELOCITY = 250f;

        // Core Game Objects
        private SpriteBatch batch;
        private OrthographicCamera camera;
        private Viewport viewport;
        private Player player;
        private Background background;
        private Array<Platform> activePlatforms;
        private Array<Enemy> activeEnemies;

        // Individual textures for Goomba
        private Texture goombaWalkFrame1Tex;
        private Texture goombaWalkFrame2Tex;
        private Texture goombaSquashedTex; // Can be one of the walk frames if no specific squashed sprite

        // Level Editor and Game State
        private LevelEditor levelEditor;
        private boolean editMode = true;
        private boolean gamePaused = false;

        // Utility
        private SoundManager soundManager;
        private Texture playerIdleTexture; // For editor preview of player start

        // Player jump state variables
        private boolean playerIsHoldingJumpKey = false;
        private float playerJumpHoldTimer = 0f;

        @Override
        public void create() {
            camera = new OrthographicCamera();
            viewport = new FitViewport(WORLD_WIDTH, WORLD_HEIGHT, camera);
            camera.position.set(WORLD_WIDTH / 2f, WORLD_HEIGHT / 2f, 0);

            batch = new SpriteBatch();
            soundManager = SoundManager.getInstance();
            player = new Player(150, Platform.GROUND_TILE_SIZE * 2);

            try {
                playerIdleTexture = new Texture(Gdx.files.internal("mario_sprites/playables/mario/mario_idle.png"));
                // Load Goomba Textures individually
                goombaWalkFrame1Tex = new Texture(Gdx.files.internal("mario_sprites/enemies/goomba_walk_0.png"));
                goombaWalkFrame2Tex = new Texture(Gdx.files.internal("mario_sprites/enemies/goomba_walk_1.png"));

                // For squashed, use walk_0 as a placeholder if a specific one isn't available
                if (Gdx.files.internal("mario_sprites/enemies/goomba_squashed.png").exists()) {
                    goombaSquashedTex = new Texture(Gdx.files.internal("mario_sprites/enemies/goomba_squashed.png"));
                } else {
                    goombaSquashedTex = goombaWalkFrame1Tex; // Use walk frame 0 as placeholder
                    Gdx.app.log("MainCreate", "goomba_squashed.png not found, using goomba_walk_0.png as placeholder.");
                }
            } catch (Exception e) {
                Gdx.app.error("MainCreate", "Failed to load essential textures (player idle or Goomba frames)", e);
                // Consider more robust error handling or exiting if critical assets are missing
            }

            background = new Background();
            activePlatforms = new Array<>();
            activeEnemies = new Array<>();

            levelEditor = new LevelEditor(); // LevelEditor will load its own preview for Goomba
            editMode = true;
            loadCurrentLevelData(); // Load initial level data
        }

        private void loadCurrentLevelData() {
            Level currentLoadedLevel = levelEditor.getCurrentLevel();

            activePlatforms.clear();
            activePlatforms.addAll(currentLoadedLevel.createPlatforms());

            activeEnemies.clear();
            // Ensure Goomba textures are loaded before attempting to create Goomba instances
            if (goombaWalkFrame1Tex != null && goombaWalkFrame2Tex != null && goombaSquashedTex != null) {
                for (Level.EnemyData data : currentLoadedLevel.getEnemyData()) {
                    if ("GOOMBA".equals(data.type)) {
                        activeEnemies.add(new Goomba(goombaWalkFrame1Tex, goombaWalkFrame2Tex, goombaSquashedTex, data.x, data.y));
                    }
                    // Add other enemy types here if they also use individual textures
                }
            } else {
                Gdx.app.error("LoadLevelData", "Goomba textures not loaded. Cannot create Goomba instances.");
            }

            background.setTexture(currentLoadedLevel.getBackgroundTexturePath());
            player.respawn(currentLoadedLevel.getPlayerStartX(), currentLoadedLevel.getPlayerStartY());
            player.getVelocity().set(0,0); // Explicitly reset velocity on level load/respawn

            levelEditor.clearChangesFlag(); // Mark changes as "applied" from editor's perspective
            gamePaused = false; // Ensure game is not paused when (re)loading level data
        }

        @Override
        public void render() {
            Gdx.gl.glClearColor(0.4f, 0.7f, 1, 1);
            Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
            float deltaTime = Gdx.graphics.getDeltaTime();

            if (Gdx.input.isKeyJustPressed(Input.Keys.P) || (editMode && levelEditor.isPlayButtonClicked())) {
                toggleFullEditPlayMode();
            }

            if (editMode) {
                if (levelEditor.hasUnappliedChanges()) {
                    loadCurrentLevelData(); // Refresh game view if editor made changes
                }
                levelEditor.update(camera);

                if (levelEditor.getCurrentUIMode() == LevelEditor.EditorUIMode.EDITING) {
                    camera.update();
                    batch.setProjectionMatrix(camera.combined);
                    batch.begin();
                    background.render(batch, camera);
                    for (Platform item : activePlatforms) item.render(batch);
                    batch.end();
                    levelEditor.renderEditorElements(batch, camera); // Handles its own previews
                } else if (levelEditor.getCurrentUIMode() == LevelEditor.EditorUIMode.LEVEL_PREVIEW) {
                    Level currentLevel = levelEditor.getCurrentLevel();
                    background.setTexture(currentLevel.getBackgroundTexturePath());

                    float targetX = currentLevel.getPlayerStartX() + Player.PLAYER_WIDTH / 2f;
                    float targetY = currentLevel.getPlayerStartY() + Player.PLAYER_HEIGHT / 2f;
                    camera.position.set(targetX + 100, Math.max(WORLD_HEIGHT / 2f, targetY + 50), 0);
                    camera.update();

                    batch.setProjectionMatrix(camera.combined);
                    batch.begin();
                    background.render(batch, camera);
                    for (Platform p : activePlatforms) p.render(batch);
                    for (Enemy enemy : activeEnemies) enemy.render(batch); // Render actual enemies
                    if (playerIdleTexture != null) {
                        batch.draw(playerIdleTexture, currentLevel.getPlayerStartX(), currentLevel.getPlayerStartY(), Player.PLAYER_WIDTH, Player.PLAYER_HEIGHT);
                    }
                    batch.end();
                    levelEditor.renderPreviewNotification(batch);
                }
            } else { // Play Mode
                if (!gamePaused) {
                    updateGameLogic(deltaTime);
                } else {
                    player.update(deltaTime); // Player death animation
                    for (int i = activeEnemies.size - 1; i >= 0; i--) {
                        Enemy enemy = activeEnemies.get(i);
                        if (enemy.getCurrentState() == Enemy.EnemyState.STOMPED) {
                            enemy.update(deltaTime, activePlatforms, player);
                            if (!enemy.isAlive()) {
                                activeEnemies.removeIndex(i);
                            }
                        }
                    }
                }

                if (player.getCurrentState() == Player.State.DEATH && player.getStateTimer() > Player.DEATH_ANIMATION_DURATION) {
                    respawnPlayerAndResetLevel();
                }

                camera.position.x = player.getPosition().x + Player.PLAYER_WIDTH / 2f + 100f;
                camera.position.y = Math.max(WORLD_HEIGHT / 2f, player.getPosition().y + Player.PLAYER_HEIGHT / 2f - WORLD_HEIGHT / 4f + 50f);
                camera.position.x = Math.max(camera.viewportWidth / 2f, camera.position.x);
                camera.position.y = Math.max(camera.viewportHeight / 2f, camera.position.y);
                camera.update();

                batch.setProjectionMatrix(camera.combined);
                batch.begin();
                background.render(batch, camera);
                for (Platform item : activePlatforms) item.render(batch);
                for (Enemy enemy : activeEnemies) enemy.render(batch);
                player.render(batch);
                batch.end();
            }
        }

        private void toggleFullEditPlayMode() {
            editMode = !editMode;
            if (editMode) {
                soundManager.stopMusic();
                gamePaused = false;
                System.out.println("Switched to EDITOR MODE");
                // No need to loadCurrentLevelData here usually, as editor drives its own state
                // unless you want to force a sync from game state back to editor view if they diverge.
            } else { // Switching to Play Mode
                levelEditor.clearChangesFlag();
                loadCurrentLevelData(); // CRUCIAL: Load latest editor state into game world

                Level currentLevel = levelEditor.getCurrentLevel();
                if (currentLevel.getBackgroundMusic() != null && !currentLevel.getBackgroundMusic().isEmpty()) {
                    soundManager.playMusic(currentLevel.getBackgroundMusic(), currentLevel.getMusicVolume());
                } else {
                    soundManager.stopMusic();
                }
                gamePaused = false;
                playerIsHoldingJumpKey = false;
                playerJumpHoldTimer = 0f;
                System.out.println("Switched to PLAY MODE");
            }
        }

        private void updateGameLogic(float deltaTime) {
            if (player.getCurrentState() == Player.State.DEATH) {
                gamePaused = true;
                return;
            }

            handlePlayerInput(deltaTime);

            float effectiveGravity = GRAVITY;
            boolean jumpKeyIsCurrentlyHeld = Gdx.input.isKeyPressed(Input.Keys.UP) ||
                Gdx.input.isKeyPressed(Input.Keys.W) ||
                Gdx.input.isKeyPressed(Input.Keys.SPACE);

            if (playerIsHoldingJumpKey && jumpKeyIsCurrentlyHeld && player.getVelocity().y > 0 && playerJumpHoldTimer < MAX_JUMP_HOLD_TIME) {
                effectiveGravity = GRAVITY * JUMP_HOLD_GRAVITY_MULTIPLIER;
                playerJumpHoldTimer += deltaTime;
            } else {
                playerIsHoldingJumpKey = false;
            }
            player.getVelocity().y += effectiveGravity * deltaTime;

            player.getPosition().x += player.getVelocity().x * deltaTime;
            player.getBounds().setX(player.getPosition().x);
            checkHorizontalCollisions(player, activePlatforms);

            player.getPosition().y += player.getVelocity().y * deltaTime;
            player.getBounds().setY(player.getPosition().y);
            checkVerticalCollisions(player, activePlatforms);

            player.update(deltaTime);
            collectCoins();

            for (int i = activeEnemies.size - 1; i >= 0; i--) {
                Enemy enemy = activeEnemies.get(i);
                enemy.update(deltaTime, activePlatforms, player);
                if (!enemy.isAlive() && enemy.getCurrentState() == Enemy.EnemyState.DEAD) {
                    activeEnemies.removeIndex(i);
                }
            }
            checkPlayerEnemyCollisions();

            if (player.getPosition().y < -Player.PLAYER_HEIGHT * 2 && player.getCurrentState() != Player.State.DEATH) {
                player.die();
                gamePaused = true;
            }
        }

        private void handlePlayerInput(float deltaTime) {
            if (player.getCurrentState() == Player.State.DEATH) return;

            if (Gdx.input.isKeyPressed(Input.Keys.RIGHT) || Gdx.input.isKeyPressed(Input.Keys.D)) {
                player.getVelocity().x = MOVE_SPEED;
                player.setFacingRight(false);
                if (player.isGrounded()) player.setCurrentState(Player.State.WALKING);
            } else if (Gdx.input.isKeyPressed(Input.Keys.LEFT) || Gdx.input.isKeyPressed(Input.Keys.A)) {
                player.getVelocity().x = -MOVE_SPEED;
                player.setFacingRight(true);
                if (player.isGrounded()) player.setCurrentState(Player.State.WALKING);
            } else {
                player.getVelocity().x = 0;
                if (player.isGrounded() && player.getCurrentState() == Player.State.WALKING) {
                    player.setCurrentState(Player.State.IDLE);
                }
            }

            boolean jumpKeyPressedThisFrame = Gdx.input.isKeyJustPressed(Input.Keys.UP) ||
                Gdx.input.isKeyJustPressed(Input.Keys.W) ||
                Gdx.input.isKeyJustPressed(Input.Keys.SPACE);

            if (jumpKeyPressedThisFrame && player.isGrounded()) {
                player.getVelocity().y = JUMP_INITIAL_IMPULSE;
                player.setGrounded(false);
                player.setCurrentState(Player.State.JUMPING);
                soundManager.playJump();
                playerIsHoldingJumpKey = true;
                playerJumpHoldTimer = 0f;
            }

            boolean duckKeyPressed = Gdx.input.isKeyPressed(Input.Keys.DOWN) || Gdx.input.isKeyPressed(Input.Keys.S);
            if (duckKeyPressed) {
                if (player.isGrounded() && player.getCurrentState() != Player.State.DUCKING) {
                    player.setCurrentState(Player.State.DUCKING);
                    player.getVelocity().x *= 0.5f;
                }
            } else {
                if (player.getCurrentState() == Player.State.DUCKING) {
                    player.setCurrentState(player.getVelocity().x != 0 ? Player.State.WALKING : Player.State.IDLE);
                }
            }
        }

        private void checkHorizontalCollisions(Player gamePlayer, Array<Platform> platforms) {
            Rectangle playerRect = gamePlayer.getBounds();
            for (Platform platform : platforms) {
                if (platform.getType() == Platform.PlatformType.COIN) continue;
                Rectangle platformRect = platform.getBounds();
                if (playerRect.overlaps(platformRect)) {
                    if (gamePlayer.getVelocity().x > 0) {
                        gamePlayer.getPosition().x = platformRect.x - playerRect.width;
                    } else if (gamePlayer.getVelocity().x < 0) {
                        gamePlayer.getPosition().x = platformRect.x + platformRect.width;
                    }
                    gamePlayer.getVelocity().x = 0;
                    gamePlayer.getBounds().setX(gamePlayer.getPosition().x);
                }
            }
        }

        private void checkVerticalCollisions(Player gamePlayer, Array<Platform> platforms) {
            gamePlayer.setGrounded(false);
            Rectangle playerRect = gamePlayer.getBounds();
            float playerOldY = gamePlayer.getPosition().y - (gamePlayer.getVelocity().y * Gdx.graphics.getDeltaTime());

            for (Platform platform : platforms) {
                if (platform.getType() == Platform.PlatformType.COIN) continue;
                Rectangle platformRect = platform.getBounds();

                if (playerRect.overlaps(platformRect)) {
                    if (gamePlayer.getVelocity().y <= 0 && playerOldY + playerRect.height * 0.5f >= platformRect.y + platformRect.height) {
                        gamePlayer.getPosition().y = platformRect.y + platformRect.height;
                        gamePlayer.getVelocity().y = 0;
                        gamePlayer.setGrounded(true);
                        if (gamePlayer.getCurrentState() == Player.State.JUMPING || gamePlayer.getCurrentState() == Player.State.FALLING) {
                            gamePlayer.setCurrentState(player.getVelocity().x == 0 ? Player.State.IDLE : Player.State.WALKING);
                        }
                    } else if (gamePlayer.getVelocity().y > 0 && playerOldY <= platformRect.y) {
                        gamePlayer.getPosition().y = platformRect.y - playerRect.height;
                        gamePlayer.getVelocity().y = 0;
                        playerIsHoldingJumpKey = false;
                        if(gamePlayer.getCurrentState() == Player.State.JUMPING) gamePlayer.setCurrentState(Player.State.FALLING);
                    }
                    gamePlayer.getBounds().setY(gamePlayer.getPosition().y);
                }
            }
        }

        private void checkPlayerEnemyCollisions() {
            if (player.getCurrentState() == Player.State.DEATH) return;

            Rectangle playerRect = player.getBounds();
            for (Enemy enemy : activeEnemies) {
                if (!enemy.isAlive() || enemy.getCurrentState() == Enemy.EnemyState.STOMPED) continue;

                if (playerRect.overlaps(enemy.getBounds())) {
                    boolean isStomp = player.getVelocity().y < 0 &&
                        (player.getBounds().y > enemy.getBounds().y + enemy.getBounds().height * 0.5f);
                    if (isStomp) {
                        enemy.onStompedBy(player);
                        player.getVelocity().y = PLAYER_STOMP_BOUNCE_VELOCITY;
                        player.setGrounded(false);
                        // SoundManager.getInstance().playEnemyStomp(); // Now handled in Enemy.onStompedBy
                    } else {
                        if (enemy.onCollisionWith(player)) {
                            player.die();
                            gamePaused = true;
                            break;
                        }
                    }
                }
            }
        }

        private void respawnPlayerAndResetLevel() {
            Gdx.app.log("Game", "Player Died. Respawning and Resetting Level.");
            gamePaused = false;
            Level currentLevel = levelEditor.getCurrentLevel();

            player.respawn(currentLevel.getPlayerStartX(), currentLevel.getPlayerStartY());

            activeEnemies.clear();
            if (goombaWalkFrame1Tex != null && goombaWalkFrame2Tex != null && goombaSquashedTex != null) {
                for (Level.EnemyData data : currentLevel.getEnemyData()) {
                    if ("GOOMBA".equals(data.type)) {
                        activeEnemies.add(new Goomba(goombaWalkFrame1Tex, goombaWalkFrame2Tex, goombaSquashedTex, data.x, data.y));
                    }
                }
            }

            camera.position.x = player.getPosition().x + Player.PLAYER_WIDTH / 2f + 100f;
            camera.position.y = Math.max(WORLD_HEIGHT / 2f, player.getPosition().y + Player.PLAYER_HEIGHT / 2f); // Adjusted Y
            camera.update();

            if (currentLevel.getBackgroundMusic() != null && !currentLevel.getBackgroundMusic().isEmpty()) {
                soundManager.playMusic(currentLevel.getBackgroundMusic(), currentLevel.getMusicVolume());
            } else {
                soundManager.stopMusic();
            }
            playerIsHoldingJumpKey = false;
            playerJumpHoldTimer = 0f;
        }

        private void collectCoins() {
            Rectangle playerRect = player.getBounds();
            for (int i = activePlatforms.size - 1; i >= 0; i--) {
                Platform item = activePlatforms.get(i);
                if (item.getType() == Platform.PlatformType.COIN && playerRect.overlaps(item.getBounds())) {
                    activePlatforms.removeIndex(i);
                    soundManager.playCoinCollect();
                    Gdx.app.log("Game", "Coin collected!");
                }
            }
        }

        @Override
        public void resize(int width, int height) {
            viewport.update(width, height, true);
            if (levelEditor != null) {
                levelEditor.resize(width, height);
            }
        }

        @Override
        public void dispose() {
            if (batch != null) batch.dispose();
            if (player != null) player.dispose();
            if (playerIdleTexture != null) playerIdleTexture.dispose();
            if (background != null) background.dispose();

            Platform.disposeSharedTextures();
            if (activePlatforms != null) activePlatforms.clear();

            // Dispose Goomba textures
            if (goombaWalkFrame1Tex != null) goombaWalkFrame1Tex.dispose();
            if (goombaWalkFrame2Tex != null) goombaWalkFrame2Tex.dispose();
            // Dispose squashed texture only if it's a unique texture and not just a reference to walkFrame1Tex
            if (goombaSquashedTex != null && goombaSquashedTex != goombaWalkFrame1Tex) {
                goombaSquashedTex.dispose();
            }

            if (activeEnemies != null) {
                for (Enemy enemy : activeEnemies) {
                    enemy.dispose(); // Enemy subclasses might have their own resources to dispose if not shared
                }
                activeEnemies.clear();
            }

            if (levelEditor != null) levelEditor.dispose();
            if (soundManager != null) soundManager.dispose();
        }
    }

    ================
    File: core/src/main/java/io/github/game/Platform.java
    ================
    package io.github.game;

    import com.badlogic.gdx.graphics.Texture;
    import com.badlogic.gdx.graphics.g2d.SpriteBatch;
    import com.badlogic.gdx.math.Rectangle;
    import com.badlogic.gdx.utils.ObjectMap;
    import com.badlogic.gdx.Gdx;

    public class Platform {
        private Rectangle bounds;
        private PlatformType type;
        private Texture singleBlockTexture;
        private Powerup.PowerupType containedPowerup;
        private boolean hasBeenHit;
        private String uniqueId;

        // Visual size of each ground tile component
        public static final int GROUND_TILE_SIZE = 32;

        // Static textures for ground composition
        private static Texture texGrassCornerLeft;
        private static Texture texGrassMiddle;
        private static Texture texGrassCornerRight;
        private static Texture texDirtMiddle;
        private static Texture texQuestionBlockEmpty;

        // Static map for textures
        private static ObjectMap<PlatformType, Texture> otherBlockTextures;

        public enum PlatformType {
            GROUND,
            GRAVEL_BLOCK,
            QUESTION_BLOCK,
            COIN
        }

        static {
            try {
                // Load ground composition textures
                texGrassCornerLeft = new Texture("mario_sprites/world/grass_left_corner.png");
                texGrassMiddle = new Texture("mario_sprites/world/grass_middle.png");
                texGrassCornerRight = new Texture("mario_sprites/world/grass_right_corner.png");
                texDirtMiddle = new Texture("mario_sprites/world/dirt_middle.png");

                // Initialize map and load other block textures
                otherBlockTextures = new ObjectMap<>();
                otherBlockTextures.put(PlatformType.GRAVEL_BLOCK, new Texture("mario_sprites/world/gravel.png"));

                String qbPath = "mario_sprites/world/question_block.png";
                if (Gdx.files.internal(qbPath).exists()) {
                    otherBlockTextures.put(PlatformType.QUESTION_BLOCK, new Texture(qbPath));
                } else {
                    System.err.println("Warning: Texture not found: " + qbPath);
                    if (otherBlockTextures.containsKey(PlatformType.GRAVEL_BLOCK)) {
                        otherBlockTextures.put(PlatformType.QUESTION_BLOCK, otherBlockTextures.get(PlatformType.GRAVEL_BLOCK));
                    }
                }

                // Try to load empty question block texture
                String emptyQbPath = "mario_sprites/world/question_block_empty.png";
                if (Gdx.files.internal(emptyQbPath).exists()) {
                    texQuestionBlockEmpty = new Texture(emptyQbPath);
                } else {
                    // Use gravel as fallback for empty question block
                    texQuestionBlockEmpty = otherBlockTextures.get(PlatformType.GRAVEL_BLOCK);
                }

                String coinPath = "mario_sprites/world/coin.png";
                if (Gdx.files.internal(coinPath).exists()) {
                    otherBlockTextures.put(PlatformType.COIN, new Texture(coinPath));
                } else {
                    System.err.println("Warning: Texture not found: " + coinPath);
                }

            } catch (Exception e) {
                System.err.println("Fatal error loading platform textures: " + e.getMessage());
                e.printStackTrace();
            }
        }

        public static Texture getTextureForType(PlatformType type) {
            if (type == PlatformType.GROUND) {
                return null;
            }
            return otherBlockTextures.get(type);
        }

        public Platform(float x, float y, float width, float height, PlatformType type) {
            this.bounds = new Rectangle(x, y, width, height);
            this.type = type;
            this.hasBeenHit = false;
            this.containedPowerup = null;
            this.uniqueId = x + "_" + y + "_" + type;

            if (type != PlatformType.GROUND) {
                this.singleBlockTexture = getTextureForType(type);

                if (this.singleBlockTexture == null) {
                    System.err.println("Warning: Texture for type " + type + " is missing.");
                    if (type != PlatformType.GRAVEL_BLOCK && getTextureForType(PlatformType.GRAVEL_BLOCK) != null) {
                        this.singleBlockTexture = getTextureForType(PlatformType.GRAVEL_BLOCK);
                    }
                }
            }
        }

        public void setContainedPowerup(Powerup.PowerupType powerup) {
            this.containedPowerup = powerup;
        }

        public Powerup.PowerupType getContainedPowerup() {
            return containedPowerup;
        }

        public boolean hit() {
            if (type == PlatformType.QUESTION_BLOCK && !hasBeenHit) {
                hasBeenHit = true;
                return true;
            }
            return false;
        }

        public boolean hasBeenHit() {
            return hasBeenHit;
        }

        public String getUniqueId() {
            return uniqueId;
        }

        public void render(SpriteBatch batch) {
            switch (type) {
                case GROUND:
                    renderGroundPlatform(batch);
                    break;
                case GRAVEL_BLOCK:
                case COIN:
                    renderSingleScaledBlock(batch);
                    break;
                case QUESTION_BLOCK:
                    renderQuestionBlock(batch);
                    break;
                default:
                    if (singleBlockTexture != null) {
                        batch.draw(singleBlockTexture, bounds.x, bounds.y, bounds.width, bounds.height);
                    }
                    break;
            }
        }

        private void renderQuestionBlock(SpriteBatch batch) {
            Texture textureToDraw;
            if (hasBeenHit && texQuestionBlockEmpty != null) {
                textureToDraw = texQuestionBlockEmpty;
            } else if (singleBlockTexture != null) {
                textureToDraw = singleBlockTexture;
            } else {
                return;
            }
            batch.draw(textureToDraw, bounds.x, bounds.y, bounds.width, bounds.height);
        }

        private void renderGroundPlatform(SpriteBatch batch) {
            if (texGrassCornerLeft == null || texGrassMiddle == null || texGrassCornerRight == null || texDirtMiddle == null) {
                System.err.println("Cannot render GROUND: one or more essential ground textures are missing.");
                return;
            }

            int numCols = (int) (bounds.width / GROUND_TILE_SIZE);
            int numRows = (int) (bounds.height / GROUND_TILE_SIZE);

            for (int row = 0; row < numRows; row++) {
                for (int col = 0; col < numCols; col++) {
                    float tileX = bounds.x + col * GROUND_TILE_SIZE;
                    float tileY = bounds.y + (numRows - 1 - row) * GROUND_TILE_SIZE;

                    Texture currentTileToDraw;
                    if (row == 0) {
                        if (numCols == 1) {
                            currentTileToDraw = texGrassMiddle;
                        } else if (col == 0) {
                            currentTileToDraw = texGrassCornerLeft;
                        } else if (col == numCols - 1) {
                            currentTileToDraw = texGrassCornerRight;
                        } else {
                            currentTileToDraw = texGrassMiddle;
                        }
                    } else {
                        currentTileToDraw = texDirtMiddle;
                    }
                    batch.draw(currentTileToDraw, tileX, tileY, GROUND_TILE_SIZE, GROUND_TILE_SIZE);
                }
            }
        }

        private void renderSingleScaledBlock(SpriteBatch batch) {
            if (singleBlockTexture == null) {
                return;
            }
            batch.draw(singleBlockTexture, bounds.x, bounds.y, bounds.width, bounds.height);
        }

        public Rectangle getBounds() {
            return bounds;
        }

        public static void disposeSharedTextures() {
            if (texGrassCornerLeft != null) texGrassCornerLeft.dispose();
            if (texGrassMiddle != null) texGrassMiddle.dispose();
            if (texGrassCornerRight != null) texGrassCornerRight.dispose();
            if (texDirtMiddle != null) texDirtMiddle.dispose();
            if (texQuestionBlockEmpty != null) texQuestionBlockEmpty.dispose();

            if (otherBlockTextures != null) {
                for (Texture tex : otherBlockTextures.values()) {
                    if (tex != null) tex.dispose();
                }
                otherBlockTextures.clear();
            }
            System.out.println("Platform shared textures disposed.");
        }

        public void dispose() {
            // No operation needed here as textures are static and shared.
        }

        public PlatformType getType() {
            return type;
        }
    }

    ================
    File: core/src/main/java/io/github/game/Player.java
    ================
    // File: core/src/main/java/io/github/game/Player.java
    package io.github.game;

    import com.badlogic.gdx.Gdx;
    import com.badlogic.gdx.graphics.Texture;
    import com.badlogic.gdx.graphics.g2d.Animation;
    import com.badlogic.gdx.graphics.g2d.SpriteBatch;
    import com.badlogic.gdx.math.Rectangle;
    import com.badlogic.gdx.math.Vector2;
    import com.badlogic.gdx.utils.Array;

    public class Player {

        private Texture deathTexture;
        public static final float DEATH_ANIMATION_DURATION = 1.5f; // Already present, good duration
        public enum State {
            IDLE, FALLING, WALKING, RUNNING, JUMPING, DUCKING, OPENING_DOOR, FULL_SPEED_JUMPING, DEATH, GROUND_POUNDING, GOING_DOWN_PIPE;
        }
        private Vector2 position;
        private Vector2 velocity;
        private boolean facingRight;
        private boolean grounded;
        private State currentState;
        private State previousState;
        private float stateTimer;

        public static final int PLAYER_WIDTH = 32;
        public static final int PLAYER_HEIGHT = 48;

        private Rectangle bounds;
        private Texture idleTexture;
        private Texture duckTexture;
        private Texture jumpTexture;
        private Texture walkTexture0;
        private Texture walkTexture1;
        private Texture walkTexture2;
        private Texture fallTexture;
        private Texture pipeTexture;
        private Texture lookUpTexture;
        private Animation<Texture> walkAnimation;

        // Added for Mario-style death animation
        private static final float DEATH_JUMP_VELOCITY = 350f;
        private static final float DEATH_GRAVITY = -900f; // Independent gravity for death sequence

        public Player(float x, float y){
            position = new Vector2(x,y);
            velocity = new Vector2(0, 0);
            facingRight = true; // Player starts facing right
            grounded = false;
            currentState = State.IDLE;
            previousState = State.IDLE;
            bounds = new Rectangle(x, y, PLAYER_WIDTH, PLAYER_HEIGHT);
            idleTexture = new Texture("mario_sprites/playables/mario/mario_idle.png");
            walkTexture0 = new Texture("mario_sprites/playables/mario/mario_walk_0.png");
            walkTexture1 = new Texture("mario_sprites/playables/mario/mario_walk_1.png");
            walkTexture2 = new Texture("mario_sprites/playables/mario/mario_walk_2.png");
            duckTexture = new Texture("mario_sprites/playables/mario/mario_duck.png");
            jumpTexture = new Texture("mario_sprites/playables/mario/mario_jump.png");
            lookUpTexture = new Texture("mario_sprites/playables/mario/mario_look_up.png");
            pipeTexture = new Texture("mario_sprites/playables/mario/mario_pipe.png");
            fallTexture = new Texture("mario_sprites/playables/mario/mario_fall.png");

            // Corrected deathTexture loading
            String deathSpritePath = "mario_sprites/playables/mario/mario_death.png";
            if (Gdx.files.internal(deathSpritePath).exists()) {
                deathTexture = new Texture(Gdx.files.internal(deathSpritePath));
            } else {
                deathTexture = fallTexture; // Use fallTexture as a fallback
                Gdx.app.log("Player", "'" + deathSpritePath + "' not found, using fall texture for death animation.");
            }

            Array<Texture> walkFrames = new Array<Texture>();
            walkFrames.add(walkTexture0);
            walkFrames.add(walkTexture1);
            walkFrames.add(walkTexture2);
            walkAnimation = new Animation<Texture>(0.1f, walkFrames, Animation.PlayMode.LOOP);
        }

        public void update(float deltaTime){
            stateTimer = currentState == previousState ? stateTimer + deltaTime : 0;
            previousState = currentState;

            if (currentState == State.DEATH) {
                // Apply death physics (vertical jump and fall)
                velocity.y += DEATH_GRAVITY * deltaTime;
                position.y += velocity.y * deltaTime;
                // position.x remains unchanged as velocity.x is set to 0 in die()
                bounds.setPosition(position.x, position.y);
                // No platform collision checks during the death animation itself
            } else {
                // Existing update logic for non-death states
                bounds.setPosition(position.x, position.y);
                // Condition for falling state based on vertical velocity and not being grounded
                if (velocity.y < 0 && !grounded && currentState != State.FALLING && currentState != State.DUCKING && currentState != State.GOING_DOWN_PIPE) {
                    setCurrentState(State.FALLING);
                }
            }
        }

        public void render(SpriteBatch batch){
            Texture currentFrame = getFrame();

            boolean flipX = !facingRight; // Player faces right by default, flip if not facingRight

            // Standard drawing logic
            batch.draw(
                currentFrame,
                flipX ? position.x + PLAYER_WIDTH : position.x, // Adjust x for flipped sprite
                position.y,
                flipX ? -PLAYER_WIDTH : PLAYER_WIDTH, // Negative width to flip
                PLAYER_HEIGHT
            );
        }

        public Texture getFrame() {
            switch(currentState){
                case WALKING:
                    return walkAnimation.getKeyFrame(stateTimer, true);
                case JUMPING:
                    return jumpTexture;
                case DUCKING:
                    return duckTexture;
                case FALLING:
                    return fallTexture;
                case DEATH: // Use deathTexture for the death animation
                    return deathTexture;
                case IDLE:
                default:
                    return idleTexture;
            }
        }

        public Vector2 getPosition() {
            return position;
        }

        public void setPosition(Vector2 position) {
            this.position = position;
        }

        public Vector2 getVelocity() {
            return velocity;
        }

        public void setVelocity(Vector2 velocity) {
            this.velocity = velocity;
        }

        public boolean isFacingRight() {
            return facingRight;
        }

        public void setFacingRight(boolean facingRight) {
            this.facingRight = facingRight;
        }

        public boolean isGrounded() {
            return grounded;
        }

        public void setGrounded(boolean grounded) {
            this.grounded = grounded;
        }

        public State getCurrentState() {
            return currentState;
        }

        public void setCurrentState(State currentState) {
            if (this.currentState != currentState) {
                this.currentState = currentState;
                this.stateTimer = 0; // Reset state timer on state change
            }
        }
        public void dispose(){
            idleTexture.dispose();
            walkTexture0.dispose();
            walkTexture1.dispose();
            walkTexture2.dispose();
            jumpTexture.dispose();
            fallTexture.dispose();
            duckTexture.dispose();
            lookUpTexture.dispose();
            pipeTexture.dispose();
            if (deathTexture != null && deathTexture != fallTexture) { // Dispose only if it's a unique loaded texture
                deathTexture.dispose();
            }
        }

        public State getPreviousState() {
            return previousState;
        }

        public void setPreviousState(State previousState) {
            this.previousState = previousState;
        }

        public float getStateTimer() {
            return stateTimer;
        }

        public void setStateTimer(float stateTimer) {
            this.stateTimer = stateTimer;
        }

        public Rectangle getBounds() {
            return bounds;
        }

        public void setBounds(Rectangle bounds) {
            this.bounds = bounds;
        }

        public void die() {
            if (currentState != State.DEATH) {
                setCurrentState(State.DEATH);
                velocity.y = DEATH_JUMP_VELOCITY; // Mario-style upward pop
                velocity.x = 0; // Stop horizontal movement
                grounded = false; // Player is in the air
                stateTimer = 0f; // Reset timer for the death sequence duration
                SoundManager.getInstance().playPlayerDeath(); // Play death sound
            }
        }
        public void respawn(float x, float y) {
            position.set(x, y);
            velocity.set(0, 0);
            setCurrentState(State.IDLE);
            grounded = true; // Assume respawn on ground
            facingRight = true; // Default facing direction
            stateTimer = 0f;
        }
        public Texture getIdleTexture() { return idleTexture; }
        public void setIdleTexture(Texture idleTexture) { this.idleTexture = idleTexture; }
        public Texture getDuckTexture() { return duckTexture; }
        public void setDuckTexture(Texture duckTexture) { this.duckTexture = duckTexture; }
        public Texture getJumpTexture() { return jumpTexture; }
        public void setJumpTexture(Texture jumpTexture) { this.jumpTexture = jumpTexture; }
        public Texture getWalkTexture0() { return walkTexture0; }
        public void setWalkTexture0(Texture walkTexture0) { this.walkTexture0 = walkTexture0; }
        public Texture getWalkTexture1() { return walkTexture1; }
        public void setWalkTexture1(Texture walkTexture1) { this.walkTexture1 = walkTexture1; }
        public Texture getFallTexture() { return fallTexture; }
        public void setFallTexture(Texture fallTexture) { this.fallTexture = fallTexture; }
        public Texture getPipeTexture() { return pipeTexture; }
        public void setPipeTexture(Texture pipeTexture) { this.pipeTexture = pipeTexture; }
        public Texture getLookUpTexture() { return lookUpTexture; }
        public void setLookUpTexture(Texture lookUpTexture) { this.lookUpTexture = lookUpTexture; }
        public Animation<Texture> getWalkAnimation() { return walkAnimation; }
        public void setWalkAnimation(Animation<Texture> walkAnimation) { this.walkAnimation = walkAnimation; }
    }

    ================
    File: core/src/main/java/io/github/game/Powerup.java
    ================
    package io.github.game;

    import com.badlogic.gdx.graphics.Texture;
    import com.badlogic.gdx.graphics.g2d.SpriteBatch;
    import com.badlogic.gdx.math.Rectangle;
    import com.badlogic.gdx.math.Vector2;
    import com.badlogic.gdx.utils.Array;

    public class Powerup {
        public enum PowerupType {
            CHICKEN("Chicken Power", "mario_sprites/items/chicken.png"),
            MUSHROOM("Mushroom", "mario_sprites/items/mushroom.png"),
            FIRE_FLOWER("Fire Flower", "mario_sprites/items/fire_flower.png"),
            STAR("Star", "mario_sprites/items/star.png");

            private final String name;
            private final String texturePath;

            PowerupType(String name, String texturePath) {
                this.name = name;
                this.texturePath = texturePath;
            }

            public String getName() { return name; }
            public String getTexturePath() { return texturePath; }
        }

        private PowerupType type;
        private Vector2 position;
        private Vector2 velocity;
        private Rectangle bounds;
        private Texture texture;
        private boolean active;
        private float animationTimer;

        public static final float POWERUP_SIZE = 32f;
        private static final float SPAWN_VELOCITY = 50f;
        private static final float MOVE_SPEED = 50f;

        public Powerup(PowerupType type, float x, float y) {
            this.type = type;
            this.position = new Vector2(x, y);
            this.velocity = new Vector2(MOVE_SPEED, SPAWN_VELOCITY);
            this.bounds = new Rectangle(x, y, POWERUP_SIZE, POWERUP_SIZE);
            this.active = true;
            this.animationTimer = 0;

            // Try to load texture, use placeholder if not found
            try {
                this.texture = new Texture(type.getTexturePath());
            } catch (Exception e) {
                // Use coin texture as placeholder if powerup texture doesn't exist
                try {
                    this.texture = new Texture("mario_sprites/world/coin.png");
                } catch (Exception e2) {
                    System.err.println("Warning: Could not load powerup texture: " + type.getTexturePath());
                }
            }
        }

        public void update(float deltaTime, Array<Platform> platforms) {
            if (!active) return;

            animationTimer += deltaTime;

            // Apply gravity
            velocity.y -= 400f * deltaTime;

            // Update position
            position.x += velocity.x * deltaTime;
            position.y += velocity.y * deltaTime;

            // Update bounds
            bounds.setPosition(position.x, position.y);

            // Check collisions with platforms
            for (Platform platform : platforms) {
                if (platform.getType() == Platform.PlatformType.COIN) continue;

                Rectangle platformBounds = platform.getBounds();
                if (bounds.overlaps(platformBounds)) {
                    // Landing on top
                    if (velocity.y < 0 && position.y > platformBounds.y) {
                        position.y = platformBounds.y + platformBounds.height;
                        velocity.y = 0;
                    }
                    // Hitting from side
                    if (velocity.x > 0 && position.x < platformBounds.x) {
                        position.x = platformBounds.x - POWERUP_SIZE;
                        velocity.x = -MOVE_SPEED;
                    } else if (velocity.x < 0 && position.x > platformBounds.x) {
                        position.x = platformBounds.x + platformBounds.width;
                        velocity.x = MOVE_SPEED;
                    }
                }
            }

            // Remove if fallen off screen
            if (position.y < -100) {
                active = false;
            }
        }

        public void render(SpriteBatch batch) {
            if (!active || texture == null) return;

            // Add slight bobbing animation
            float yOffset = (float)Math.sin(animationTimer * 3) * 2;

            batch.draw(texture, position.x, position.y + yOffset, POWERUP_SIZE, POWERUP_SIZE);
        }

        public boolean checkCollision(Rectangle playerBounds) {
            return active && bounds.overlaps(playerBounds);
        }

        public void collect() {
            active = false;
            System.out.println(type.getName() + " collected!");
        }

        public PowerupType getType() { return type; }
        public boolean isActive() { return active; }
        public Vector2 getPosition() { return position; }
        public Rectangle getBounds() { return bounds; }

        public void dispose() {
            if (texture != null) {
                texture.dispose();
            }
        }
    }

    ================
    File: core/src/main/java/io/github/game/SoundManager.java
    ================
    // File: core/src/main/java/io/github/game/SoundManager.java
    package io.github.game;

    import com.badlogic.gdx.Gdx;
    import com.badlogic.gdx.audio.Music;
    import com.badlogic.gdx.audio.Sound;
    import com.badlogic.gdx.utils.Disposable;

    public class SoundManager implements Disposable {
        private static SoundManager instance;

        private Sound jumpSound;
        private Sound coinSound;
        private Sound growSound;
        private Sound itemGetSound;
        private Sound doorSound;
        private Sound powerupSound;
        private Sound playerDeathSound;
        private Sound enemyStompSound;

        private Music currentMusic;
        private String currentMusicPath;

        private float masterVolume = 0.5f; // Keep existing volume controls
        private float musicVolume = 0.5f;  // This seems to be a specific multiplier for music
        private boolean soundEnabled = true;
        private boolean musicEnabled = true;

        private SoundManager() {
            loadSounds();
        }

        public static SoundManager getInstance() {
            if (instance == null) {
                instance = new SoundManager();
            }
            return instance;
        }

        private void loadSounds() {
            try {
                jumpSound = Gdx.audio.newSound(Gdx.files.internal("sounds/jump.wav"));
                coinSound = Gdx.audio.newSound(Gdx.files.internal("sounds/coin.wav"));

                if (Gdx.files.internal("sounds/grow.wav").exists()) {
                    growSound = Gdx.audio.newSound(Gdx.files.internal("sounds/grow.wav"));
                }
                if (Gdx.files.internal("sounds/item-get.wav").exists()) {
                    itemGetSound = Gdx.audio.newSound(Gdx.files.internal("sounds/item-get.wav"));
                }
                if (Gdx.files.internal("sounds/door.wav").exists()) {
                    doorSound = Gdx.audio.newSound(Gdx.files.internal("sounds/door.wav"));
                }
                if (Gdx.files.internal("sounds/powerup.wav").exists()) {
                    powerupSound = Gdx.audio.newSound(Gdx.files.internal("sounds/powerup.wav"));
                }
                if (Gdx.files.internal("sounds/player_death.wav").exists()) {
                    playerDeathSound = Gdx.audio.newSound(Gdx.files.internal("sounds/player_death.wav"));
                } else { Gdx.app.log("SoundManager", "player_death.wav not found."); }

                if (Gdx.files.internal("sounds/enemy_stomp.wav").exists()) {
                    enemyStompSound = Gdx.audio.newSound(Gdx.files.internal("sounds/enemy_stomp.wav"));
                } else { Gdx.app.log("SoundManager", "enemy_stomp.wav not found."); }

            } catch (Exception e) {
                System.err.println("Error loading sounds: " + e.getMessage());
                // Consider setting soundEnabled = false here if critical sounds fail
            }
        }

        public void playMusic(String musicPath, float volume) {
            if (!musicEnabled || musicPath == null || musicPath.isEmpty()) return;

            if (currentMusic != null) {
                if (currentMusicPath != null && currentMusicPath.equals(musicPath) && currentMusic.isPlaying()) {
                    currentMusic.setVolume(volume * this.musicVolume); // Adjust volume if same music
                    return;
                }
                currentMusic.stop();
                currentMusic.dispose(); // Dispose old music before loading new
                currentMusic = null;
                currentMusicPath = null;
            }

            try {
                if (Gdx.files.internal(musicPath).exists()) {
                    currentMusic = Gdx.audio.newMusic(Gdx.files.internal(musicPath));
                    currentMusicPath = musicPath;
                    currentMusic.setLooping(true);
                    currentMusic.setVolume(volume * this.musicVolume); // Use the passed volume parameter
                    currentMusic.play();
                } else {
                    Gdx.app.error("SoundManager", "Music file not found: " + musicPath);
                }
            } catch (Exception e) {
                Gdx.app.error("SoundManager", "Error loading music: " + musicPath, e);
                if (currentMusic != null) currentMusic.dispose(); // Clean up if load failed
                currentMusic = null;
                currentMusicPath = null;
            }
        }

        // Method to play player death sound
        public void playPlayerDeath() {
            if (soundEnabled && playerDeathSound != null) {
                playerDeathSound.play(masterVolume);
            }
        }

        // Method to play enemy stomp sound
        public void playEnemyStomp() {
            if (soundEnabled && enemyStompSound != null) {
                enemyStompSound.play(masterVolume);
            }
        }


        public void stopMusic() {
            if (currentMusic != null) {
                currentMusic.stop();
            }
        }

        public void pauseMusic() {
            if (currentMusic != null) {
                currentMusic.pause();
            }
        }

        public void resumeMusic() {
            if (currentMusic != null && musicEnabled && !currentMusic.isPlaying()) {
                currentMusic.play();
            }
        }

        public void playJump() {
            if (soundEnabled && jumpSound != null) {
                jumpSound.play(masterVolume);
            }
        }

        public void playCoinCollect() {
            if (soundEnabled && coinSound != null) {
                coinSound.play(masterVolume * 0.8f);
            }
        }

        public void playPowerup() {
            if (soundEnabled) {
                if (powerupSound != null) {
                    powerupSound.play(masterVolume);
                } else if (itemGetSound != null) { // Fallback
                    itemGetSound.play(masterVolume);
                }
            }
        }

        public void playGrow() {
            if (soundEnabled && growSound != null) {
                growSound.play(masterVolume);
            }
        }

        public void playItemGet() {
            if (soundEnabled && itemGetSound != null) {
                itemGetSound.play(masterVolume);
            }
        }

        public void playDoor() {
            if (soundEnabled && doorSound != null) {
                doorSound.play(masterVolume * 0.7f);
            }
        }

        public void setMasterVolume(float volume) {
            this.masterVolume = Math.max(0f, Math.min(1f, volume));
            // Note: This does not retroactively change playing sound instances' volumes, only future ones.
            // LibGDX Sound instances don't typically have individual volume controls after play() without more complex pooling.
        }

        public float getMasterVolume() {
            return masterVolume;
        }

        public void setMusicVolume(float volume) {
            this.musicVolume = Math.max(0f, Math.min(1f, volume));
            if (currentMusic != null) {
                // This requires the 'volume' parameter in playMusic to be the level-specific volume
                // and this.musicVolume to be the global music volume setting.
                // For playMusic(String musicPath, float levelVolume), it would be:
                // currentMusic.setVolume(levelVolume * this.musicVolume);
                currentMusic.setVolume(currentMusic.getVolume() / (this.musicVolume == 0 ? 1 : this.musicVolume) * volume); // Re-calculate based on new global music volume
            }
        }

        public float getMusicVolume() {
            return musicVolume;
        }

        public void setSoundEnabled(boolean enabled) {
            this.soundEnabled = enabled;
        }

        public boolean isSoundEnabled() {
            return soundEnabled;
        }

        public void setMusicEnabled(boolean enabled) {
            this.musicEnabled = enabled;
            if (!enabled && currentMusic != null) {
                currentMusic.stop();
            } else if (enabled && currentMusic != null && !currentMusic.isPlaying()) {
                // Only play if it was previously stopped due to being disabled, and path is still valid
                if (currentMusicPath != null && Gdx.files.internal(currentMusicPath).exists()){
                    currentMusic.play();
                }
            }
        }

        public boolean isMusicEnabled() {
            return musicEnabled;
        }

        @Override
        public void dispose() {
            if (jumpSound != null) jumpSound.dispose();
            if (coinSound != null) coinSound.dispose();
            if (growSound != null) growSound.dispose();
            if (itemGetSound != null) itemGetSound.dispose();
            if (doorSound != null) doorSound.dispose();
            if (powerupSound != null) powerupSound.dispose();
            if (playerDeathSound != null) playerDeathSound.dispose();
            if (enemyStompSound != null) enemyStompSound.dispose();

            if (currentMusic != null) {
                currentMusic.dispose();
                currentMusic = null;
            }
            currentMusicPath = null;
            instance = null; // Allow re-creation if needed
        }
    }

    ================
    File: gradle.properties
    ================
    org.gradle.daemon=false
    org.gradle.jvmargs=-Xms512M -Xmx1G -Dfile.encoding=UTF-8 -Dconsole.encoding=UTF-8
    org.gradle.configureondemand=false
    gdxBasisUniversalVersion=1.0.2
    kryoNetVersion=2.22.9
    graalHelperVersion=2.0.1
    gwtFrameworkVersion=2.11.0
    gwtPluginVersion=1.1.29
    enableGraalNative=false
    gdxVersion=1.13.5
    projectVersion=1.0.0

    ================
    File: gradle/gradle-daemon-jvm.properties
    ================
    #This file is generated by updateDaemonJvm
    toolchainUrl.FREE_BSD.AARCH64=https\://api.foojay.io/disco/v3.0/ids/65aaef917b9f394804f058f1861225c9/redirect
    toolchainUrl.FREE_BSD.X86_64=https\://api.foojay.io/disco/v3.0/ids/c728c5388b044fbdbbc44b0c6acee0df/redirect
    toolchainUrl.LINUX.AARCH64=https\://api.foojay.io/disco/v3.0/ids/65aaef917b9f394804f058f1861225c9/redirect
    toolchainUrl.LINUX.X86_64=https\://api.foojay.io/disco/v3.0/ids/c728c5388b044fbdbbc44b0c6acee0df/redirect
    toolchainUrl.MAC_OS.AARCH64=https\://api.foojay.io/disco/v3.0/ids/dc463b4a8183dbcaa1b32544189c7f03/redirect
    toolchainUrl.MAC_OS.X86_64=https\://api.foojay.io/disco/v3.0/ids/cb7dc109dd590ebca2d703734d23c9d3/redirect
    toolchainUrl.UNIX.AARCH64=https\://api.foojay.io/disco/v3.0/ids/65aaef917b9f394804f058f1861225c9/redirect
    toolchainUrl.UNIX.X86_64=https\://api.foojay.io/disco/v3.0/ids/c728c5388b044fbdbbc44b0c6acee0df/redirect
    toolchainUrl.WINDOWS.AARCH64=https\://api.foojay.io/disco/v3.0/ids/43ee83889b87bacad5d3071ae7bbd349/redirect
    toolchainUrl.WINDOWS.X86_64=https\://api.foojay.io/disco/v3.0/ids/2d57bdd1e17a18f83ff073919daa35ba/redirect
    toolchainVersion=17

    ================
    File: gradle/wrapper/gradle-wrapper.properties
    ================
    distributionBase=GRADLE_USER_HOME
    distributionPath=wrapper/dists
    distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-bin.zip
    networkTimeout=10000
    validateDistributionUrl=true
    zipStoreBase=GRADLE_USER_HOME
    zipStorePath=wrapper/dists

    ================
    File: gradlew
    ================
    #!/bin/sh

    #
    # Copyright © 2015-2021 the original authors.
    #
    # Licensed under the Apache License, Version 2.0 (the "License");
    # you may not use this file except in compliance with the License.
    # You may obtain a copy of the License at
    #
    #      https://www.apache.org/licenses/LICENSE-2.0
    #
    # Unless required by applicable law or agreed to in writing, software
    # distributed under the License is distributed on an "AS IS" BASIS,
    # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    # See the License for the specific language governing permissions and
    # limitations under the License.
    #
    # SPDX-License-Identifier: Apache-2.0
    #

    ##############################################################################
    #
    #   Gradle start up script for POSIX generated by Gradle.
    #
    #   Important for running:
    #
    #   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
    #       noncompliant, but you have some other compliant shell such as ksh or
    #       bash, then to run this script, type that shell name before the whole
    #       command line, like:
    #
    #           ksh Gradle
    #
    #       Busybox and similar reduced shells will NOT work, because this script
    #       requires all of these POSIX shell features:
    #         * functions;
    #         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
    #           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
    #         * compound commands having a testable exit status, especially «case»;
    #         * various built-in commands including «command», «set», and «ulimit».
    #
    #   Important for patching:
    #
    #   (2) This script targets any POSIX shell, so it avoids extensions provided
    #       by Bash, Ksh, etc; in particular arrays are avoided.
    #
    #       The "traditional" practice of packing multiple parameters into a
    #       space-separated string is a well documented source of bugs and security
    #       problems, so this is (mostly) avoided, by progressively accumulating
    #       options in "$@", and eventually passing that to Java.
    #
    #       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
    #       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
    #       see the in-line comments for details.
    #
    #       There are tweaks for specific operating systems such as AIX, CygWin,
    #       Darwin, MinGW, and NonStop.
    #
    #   (3) This script is generated from the Groovy template
    #       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
    #       within the Gradle project.
    #
    #       You can find Gradle at https://github.com/gradle/gradle/.
    #
    ##############################################################################

    # Attempt to set APP_HOME

    # Resolve links: $0 may be a link
    app_path=$0

    # Need this for daisy-chained symlinks.
    while
        APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
        [ -h "$app_path" ]
    do
        ls=$( ls -ld "$app_path" )
        link=${ls#*' -> '}
        case $link in             #(
          /*)   app_path=$link ;; #(
          *)    app_path=$APP_HOME$link ;;
        esac
    done

    # This is normally unused
    # shellcheck disable=SC2034
    APP_BASE_NAME=${0##*/}
    # Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
    APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

    # Use the maximum available, or set MAX_FD != -1 to use that value.
    MAX_FD=maximum

    warn () {
        echo "$*"
    } >&2

    die () {
        echo
        echo "$*"
        echo
        exit 1
    } >&2

    # OS specific support (must be 'true' or 'false').
    cygwin=false
    msys=false
    darwin=false
    nonstop=false
    case "$( uname )" in                #(
      CYGWIN* )         cygwin=true  ;; #(
      Darwin* )         darwin=true  ;; #(
      MSYS* | MINGW* )  msys=true    ;; #(
      NONSTOP* )        nonstop=true ;;
    esac

    CLASSPATH="\\\"\\\""


    # Determine the Java command to use to start the JVM.
    if [ -n "$JAVA_HOME" ] ; then
        if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
            # IBM's JDK on AIX uses strange locations for the executables
            JAVACMD=$JAVA_HOME/jre/sh/java
        else
            JAVACMD=$JAVA_HOME/bin/java
        fi
        if [ ! -x "$JAVACMD" ] ; then
            die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

    Please set the JAVA_HOME variable in your environment to match the
    location of your Java installation."
        fi
    else
        JAVACMD=java
        if ! command -v java >/dev/null 2>&1
        then
            die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

    Please set the JAVA_HOME variable in your environment to match the
    location of your Java installation."
        fi
    fi

    # Increase the maximum file descriptors if we can.
    if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
        case $MAX_FD in #(
          max*)
            # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
            # shellcheck disable=SC2039,SC3045
            MAX_FD=$( ulimit -H -n ) ||
                warn "Could not query maximum file descriptor limit"
        esac
        case $MAX_FD in  #(
          '' | soft) :;; #(
          *)
            # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
            # shellcheck disable=SC2039,SC3045
            ulimit -n "$MAX_FD" ||
                warn "Could not set maximum file descriptor limit to $MAX_FD"
        esac
    fi

    # Collect all arguments for the java command, stacking in reverse order:
    #   * args from the command line
    #   * the main class name
    #   * -classpath
    #   * -D...appname settings
    #   * --module-path (only if needed)
    #   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

    # For Cygwin or MSYS, switch paths to Windows format before running java
    if "$cygwin" || "$msys" ; then
        APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
        CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

        JAVACMD=$( cygpath --unix "$JAVACMD" )

        # Now convert the arguments - kludge to limit ourselves to /bin/sh
        for arg do
            if
                case $arg in                                #(
                  -*)   false ;;                            # don't mess with options #(
                  /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                        [ -e "$t" ] ;;                      #(
                  *)    false ;;
                esac
            then
                arg=$( cygpath --path --ignore --mixed "$arg" )
            fi
            # Roll the args list around exactly as many times as the number of
            # args, so each arg winds up back in the position where it started, but
            # possibly modified.
            #
            # NB: a `for` loop captures its iteration list before it begins, so
            # changing the positional parameters here affects neither the number of
            # iterations, nor the values presented in `arg`.
            shift                   # remove old arg
            set -- "$@" "$arg"      # push replacement arg
        done
    fi


    # Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
    DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

    # Collect all arguments for the java command:
    #   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
    #     and any embedded shellness will be escaped.
    #   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
    #     treated as '${Hostname}' itself on the command line.

    set -- \
            "-Dorg.gradle.appname=$APP_BASE_NAME" \
            -classpath "$CLASSPATH" \
            -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
            "$@"

    # Stop when "xargs" is not available.
    if ! command -v xargs >/dev/null 2>&1
    then
        die "xargs is not available"
    fi

    # Use "xargs" to parse quoted args.
    #
    # With -n1 it outputs one arg per line, with the quotes and backslashes removed.
    #
    # In Bash we could simply go:
    #
    #   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
    #   set -- "${ARGS[@]}" "$@"
    #
    # but POSIX shell has neither arrays nor command substitution, so instead we
    # post-process each arg (as a line of input to sed) to backslash-escape any
    # character that might be a shell metacharacter, then use eval to reverse
    # that process (while maintaining the separation between arguments), and wrap
    # the whole thing up as a single "set" statement.
    #
    # This will of course break if any of these variables contains a newline or
    # an unmatched quote.
    #

    eval "set -- $(
            printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
            xargs -n1 |
            sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
            tr '\n' ' '
        )" '"$@"'

    exec "$JAVACMD" "$@"

    ================
    File: gradlew.bat
    ================
    @rem
    @rem Copyright 2015 the original author or authors.
    @rem
    @rem Licensed under the Apache License, Version 2.0 (the "License");
    @rem you may not use this file except in compliance with the License.
    @rem You may obtain a copy of the License at
    @rem
    @rem      https://www.apache.org/licenses/LICENSE-2.0
    @rem
    @rem Unless required by applicable law or agreed to in writing, software
    @rem distributed under the License is distributed on an "AS IS" BASIS,
    @rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    @rem See the License for the specific language governing permissions and
    @rem limitations under the License.
    @rem
    @rem SPDX-License-Identifier: Apache-2.0
    @rem

    @if "%DEBUG%"=="" @echo off
    @rem ##########################################################################
    @rem
    @rem  Gradle startup script for Windows
    @rem
    @rem ##########################################################################

    @rem Set local scope for the variables with windows NT shell
    if "%OS%"=="Windows_NT" setlocal

    set DIRNAME=%~dp0
    if "%DIRNAME%"=="" set DIRNAME=.
    @rem This is normally unused
    set APP_BASE_NAME=%~n0
    set APP_HOME=%DIRNAME%

    @rem Resolve any "." and ".." in APP_HOME to make it shorter.
    for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

    @rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
    set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

    @rem Find java.exe
    if defined JAVA_HOME goto findJavaFromJavaHome

    set JAVA_EXE=java.exe
    %JAVA_EXE% -version >NUL 2>&1
    if %ERRORLEVEL% equ 0 goto execute

    echo. 1>&2
    echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
    echo. 1>&2
    echo Please set the JAVA_HOME variable in your environment to match the 1>&2
    echo location of your Java installation. 1>&2

    goto fail

    :findJavaFromJavaHome
    set JAVA_HOME=%JAVA_HOME:"=%
    set JAVA_EXE=%JAVA_HOME%/bin/java.exe

    if exist "%JAVA_EXE%" goto execute

    echo. 1>&2
    echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
    echo. 1>&2
    echo Please set the JAVA_HOME variable in your environment to match the 1>&2
    echo location of your Java installation. 1>&2

    goto fail

    :execute
    @rem Setup the command line

    set CLASSPATH=


    @rem Execute Gradle
    "%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

    :end
    @rem End local scope for the variables with windows NT shell
    if %ERRORLEVEL% equ 0 goto mainEnd

    :fail
    rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
    rem the _cmd.exe /c_ return code!
    set EXIT_CODE=%ERRORLEVEL%
    if %EXIT_CODE% equ 0 set EXIT_CODE=1
    if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
    exit /b %EXIT_CODE%

    :mainEnd
    if "%OS%"=="Windows_NT" endlocal

    :omega

    ================
    File: html/build.gradle
    ================
    buildscript {
      repositories {
        mavenCentral()
      }
      dependencies {
        classpath 'org.gretty:gretty:3.1.5'
        classpath "org.docstr:gwt-gradle-plugin:$gwtPluginVersion"

      }
    }
    apply plugin: "gwt"
    apply plugin: "war"
    apply plugin: "org.gretty"

    gwt {
      gwtVersion = "$gwtFrameworkVersion" // Should match the version used for building the GWT backend. See gradle.properties.
      maxHeapSize = '1G' // Default 256m is not enough for the GWT compiler. GWT is HUNGRY.
      minHeapSize = '1G'

      // Needs to be in front of "modules" below.
      src = files(file('src/main/java'), project(":core").file('src/main/java'))
      modules += ["io.github.game.GdxDefinition"]
      devModules += ["io.github.game.GdxDefinitionSuperdev"]
      project.webAppDirName = "webapp"

      compiler.strict = true
      compiler.disableCastChecking = true
      //// The next line can be useful to uncomment if you want output that hasn't been obfuscated.
    //  compiler.style = org.docstr.gradle.plugins.gwt.Style.DETAILED

      sourceLevel = 1.11
    }

    dependencies {
      implementation "com.badlogicgames.gdx:gdx-backend-gwt:$gdxVersion"
      implementation "com.badlogicgames.gdx:gdx-backend-gwt:$gdxVersion:sources"
      implementation "com.badlogicgames.gdx:gdx:$gdxVersion:sources"
      implementation "com.crashinvaders.basisu:basisu-gdx:$gdxBasisUniversalVersion:sources"
      implementation "com.crashinvaders.basisu:basisu-wrapper:$gdxBasisUniversalVersion:natives-web"
      implementation "com.crashinvaders.basisu:basisu-wrapper:$gdxBasisUniversalVersion:sources"
      implementation project(':core')
      implementation("com.crashinvaders.basisu:basisu-gdx-gwt:$gdxBasisUniversalVersion:sources"){exclude group: "com.badlogicgames.gdx", module: "gdx-backend-gwt"}

    }

    import org.akhikhl.gretty.AppBeforeIntegrationTestTask
    import org.docstr.gradle.plugins.gwt.GwtSuperDev

    gretty.httpPort = 8080
    // The line below will need to be changed only if you change the build directory to something other than "build".
    gretty.resourceBase = "${project.layout.buildDirectory.asFile.get().absolutePath}/gwt/draftOut"
    gretty.contextPath = "/"
    gretty.portPropertiesFileName = "TEMP_PORTS.properties"

    tasks.register('startHttpServer') {
      dependsOn("draftCompileGwt")
      doFirst {
        copy {
          from "webapp"
          into gretty.resourceBase
        }
        copy {
          from "war"
          into gretty.resourceBase
        }
      }
    }

    tasks.register('beforeRun', AppBeforeIntegrationTestTask) {
      dependsOn("startHttpServer")
      gretty {
        integrationTestTask("superDev")
      }
      // The next line allows ports to be reused instead of
      // needing a process to be manually terminated.
      file("build/TEMP_PORTS.properties").delete()
      interactive = false
    }

    tasks.register('superDev', GwtSuperDev) {
      group("gwt")
      dependsOn("beforeRun")
      doFirst {
        gwt.modules = gwt.devModules
      }
    }

    //// We delete the (temporary) war/ folder because if any extra files get into it, problems occur.
    //// The war/ folder shouldn't be committed to version control.
    clean.delete += [file("war")]

    // This next line can be changed if you want to, for instance, always build into the
    // docs/ folder of a Git repo, which can be set to automatically publish on GitHub Pages.
    // This is relative to the html/ folder.
    var outputPath = "build/dist/"

    tasks.register('dist') {
      dependsOn(["clean", "compileGwt"])
      doLast {
        // Uncomment the next line if you have changed outputPath and know that its contents
        // should be replaced by a new dist build. Some large JS files are not cleaned up by
        // default unless the outputPath is inside build/ (then the clean task removes them).
        // Do not uncomment the next line if you changed outputPath to a folder that has
        // non-generated files that you want to keep!
        //delete(file(outputPath))

        file(outputPath).mkdirs()
        copy {
          from("build/gwt/out") {
            exclude '**/*.symbolMap' // Not used by a dist, and these can be large.
          }
          into outputPath
        }
        copy {
          from("webapp") {
            exclude 'index.html' // We edit this HTML file later.
            exclude 'refresh.png' // We don't need this button; this saves some bytes.
          }
          into outputPath
        }
        copy {
          from("webapp") {
            // These next two lines take the index.html page and remove the superdev refresh button.
            include 'index.html'
            filter { String line -> line.replaceAll('<a class="superdev" .+', '') }
            // This does not modify the original index.html, only the copy in the dist.
            // If you decide to manually remove or comment out the superdev button from index.html, you should also
            // either remove or comment out only the "filter" line above this.
          }
          into outputPath
        }
        copy {
          from "war"
          into outputPath
        }
      }
    }

    tasks.register('addSource') {
      doLast {
        sourceSets.main.compileClasspath += files(project(':core').sourceSets.main.allJava.srcDirs)
        sourceSets.main.compileClasspath += files("../core/build/generated/sources/annotationProcessor/java/main")
        sourceSets.main.compileClasspath += files(sourceSets.main.output.resourcesDir)

      }
    }

    tasks.register("distZip", Zip) {
      dependsOn("dist")
      //// This uses the output of the dist task, which removes the superdev button from index.html .
      from(outputPath)
      archiveVersion = projectVersion
      archiveBaseName.set("${appName}-dist")
      //// The result will be in html/build/ with a name containing "-dist".
      destinationDirectory.set(file("build"))
    }

    tasks.compileGwt.dependsOn("addSource")
    tasks.draftCompileGwt.dependsOn("addSource")
    tasks.checkGwt.dependsOn("addSource")

    java.sourceCompatibility = JavaVersion.VERSION_11
    java.targetCompatibility = JavaVersion.VERSION_11
    sourceSets.main.java.srcDirs = [ "src/main/java/" ]

    eclipse.project.name = appName + "-html"

    ================
    File: html/src/main/java/io/github/game/GdxDefinition.gwt.xml
    ================
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit 2.11.0//EN" "https://www.gwtproject.org/doctype/2.11.0/gwt-module.dtd">
    <module rename-to="html">
      <!-- Paths to source are relative to this file and separated by slashes ('/'). -->
      <source path="" />

      <!-- Any resources placed under package public_html, relative to this file, will be copied verbatim into the final webapp folder. -->
      <!-- This is where you can place your JavaScript, CSS and other resources for advanced JS integration. -->
      <public path="public_html" />

      <!-- "Inherits" lines are how GWT knows where to look for code and configuration in other projects or libraries. -->
      <inherits name="com.badlogic.gdx.backends.gdx_backends_gwt" />
      <inherits name="com.crashinvaders.basisu.BasisuGdxGwt" />
      <inherits name="io.github.game.Main" />

      <!-- You must change this if you rename packages later, or rename GwtLauncher. -->
      <entry-point class="io.github.game.gwt.GwtLauncher" />

      <!-- Reflection includes may be needed for your code or library code. Each value is separated by periods ('.'). -->
      <!-- You can include a full package by not including the name of a type at the end. -->
      <!-- This is a feature of libGDX, so these lines go after the above "inherits" that brings in libGDX. -->
      <!-- <extend-configuration-property name="gdx.reflect.include" value="fully.qualified.TypeName" /> -->

      <!-- Rarely, projects may need to include files but do not have access to the complete assets. -->
      <!-- This happens for libraries and shared projects, typically, and the configuration goes in that project. -->
      <!-- The value is a path, separated by forward slashes, where the root is your html project's resources root. -->
      <!-- You can include individual files like this, and access them with Gdx.files.classpath("path/to/file.png") : -->
      <!-- This is also a feature of libGDX, so these lines go after the above "inherits" that brings in libGDX. -->
      <!-- <extend-configuration-property name="gdx.files.classpath" value="path/to/file.png" /> -->

      <!-- You usually won't need to make changes to the rest of this. -->
      <set-configuration-property name="gdx.assetpath" value="../assets" />
      <set-configuration-property name="xsiframe.failIfScriptTag" value="FALSE"/>
      <!-- These two lines reduce the work GWT has to do during compilation and also shrink output size. -->
      <set-property name="user.agent" value="gecko1_8, safari"/>
      <collapse-property name="user.agent" values="*" />
      <!-- Remove the "user.agent" lines above if you encounter issues with Safari or other Gecko browsers. -->
    </module>

    ================
    File: html/src/main/java/io/github/game/GdxDefinitionSuperdev.gwt.xml
    ================
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit 2.11.0//EN" "https://www.gwtproject.org/doctype/2.11.0/gwt-module.dtd">
    <module rename-to="html">
      <inherits name="io.github.game.GdxDefinition" />
      <collapse-all-properties />
      <add-linker name="xsiframe"/>
      <set-configuration-property name="devModeRedirectEnabled" value="true"/>
      <set-configuration-property name="xsiframe.failIfScriptTag" value="FALSE"/>
    </module>

    ================
    File: html/src/main/java/io/github/game/gwt/GwtLauncher.java
    ================
    package io.github.game.gwt;

    import com.badlogic.gdx.ApplicationListener;
    import com.badlogic.gdx.backends.gwt.GwtApplication;
    import com.badlogic.gdx.backends.gwt.GwtApplicationConfiguration;
    import io.github.game.Main;

    /** Launches the GWT application. */
    public class GwtLauncher extends GwtApplication {
            @Override
            public GwtApplicationConfiguration getConfig () {
                // Resizable application, uses available space in browser with no padding:
                GwtApplicationConfiguration cfg = new GwtApplicationConfiguration(true);
                cfg.padVertical = 0;
                cfg.padHorizontal = 0;
                return cfg;
                // If you want a fixed size application, comment out the above resizable section,
                // and uncomment below:
                //return new GwtApplicationConfiguration(640, 480);
            }

            @Override
            public ApplicationListener createApplicationListener () {
                return new Main();
            }
    }

    ================
    File: html/webapp/index.html
    ================
    <!doctype html>
    <html>
    <head>
      <title>Mario</title>
      <meta http-equiv="content-type" content="text/html; charset=UTF-8">
      <meta id="gameViewport" name="viewport" content="width=device-width initial-scale=1">
      <link href="styles.css" rel="stylesheet" type="text/css">
    </head>

    <body>
    <a class="superdev" href="javascript:%7B%20window.__gwt_bookmarklet_params%20%3D%20%7B'server_url'%3A'http%3A%2F%2Flocalhost%3A9876%2F'%7D%3B%20var%20s%20%3D%20document.createElement('script')%3B%20s.src%20%3D%20'http%3A%2F%2Flocalhost%3A9876%2Fdev_mode_on.js'%3B%20void(document.getElementsByTagName('head')%5B0%5D.appendChild(s))%3B%7D">&#8635;</a>
    <div align="center" id="embed-html"></div>
    <script type="text/javascript" src="html/html.nocache.js"></script>
    </body>

    <script>
    function handleMouseDown(evt) {
      evt.preventDefault();
      evt.stopPropagation();
      window.focus();
    }

    function handleMouseUp(evt) {
      evt.preventDefault();
      evt.stopPropagation();
    }
    document.addEventListener('contextmenu', event => event.preventDefault());
    document.getElementById('embed-html').addEventListener('mousedown', handleMouseDown, false);
    document.getElementById('embed-html').addEventListener('mouseup', handleMouseUp, false);
    </script>
    </html>

    ================
    File: html/webapp/styles.css
    ================
    canvas {
        cursor: default;
        outline: none;
    }

    body {
        background-color: #222222;
        margin: 0px;
    }

    p {
        text-align: center;
        color: #eeeeee;
    }

    a {
        text-align: center;
        color: #bbbbff;
    }

    .superdev {
        color: rgb(37,37,37);
        text-shadow: 0px 1px 1px rgba(250,250,250,0.1);
        font-size: 50pt;
        display: block;
        position: relative;
        text-decoration: none;
        background-color: rgb(83,87,93);
        box-shadow: 0px 3px 0px 0px rgb(34,34,34),
                    0px 7px 10px 0px rgb(17,17,17),
                    inset 0px 1px 1px 0px rgba(250, 250, 250, .2),
                    inset 0px -12px 35px 0px rgba(0, 0, 0, .5);
        width: 70px;
        height: 70px;
        border: 0;
        border-radius: 35px;
        text-align: center;
        line-height: 68px;
    }

    .superdev:active {
        box-shadow: 0px 0px 0px 0px rgb(34,34,34),
                    0px 3px 7px 0px rgb(17,17,17),
                    inset 0px 1px 1px 0px rgba(250, 250, 250, .2),
                    inset 0px -10px 35px 5px rgba(0, 0, 0, .5);
        background-color: rgb(83,87,93);
        top: 3px;
        color: #fff;
        text-shadow: 0px 0px 3px rgb(250,250,250);
    }

    .superdev:hover {
        background-color: rgb(100,100,100);
    }

    ================
    File: html/webapp/WEB-INF/web.xml
    ================
    <?xml version="1.0" ?>
    <web-app>
    </web-app>

    ================
    File: levels/New Level.json
    ================
    {
    name: New Level
    playerStartX: 150
    playerStartY: 64
    backgroundMusic: music/level1.mp3
    musicVolume: 0.5
    backgroundTexturePath: mario_sprites/backgrounds/background_0.png
    platforms: [
        {
            class: io.github.game.Level$PlatformData
            width: 3200
            height: 64
            type: GROUND
        }
        {
            class: io.github.game.Level$PlatformData
            x: 416
            y: 128
            width: 32
            height: 32
            type: GRAVEL_BLOCK
        }
        {
            class: io.github.game.Level$PlatformData
            x: 416
            y: 128
            width: 32
            height: 32
            type: GRAVEL_BLOCK
        }
        {
            class: io.github.game.Level$PlatformData
            x: 416
            y: 128
            width: 32
            height: 32
            type: GRAVEL_BLOCK
        }
        {
            class: io.github.game.Level$PlatformData
            x: 416
            y: 128
            width: 32
            height: 32
            type: GRAVEL_BLOCK
        }
        {
            class: io.github.game.Level$PlatformData
            x: 416
            y: 128
            width: 32
            height: 32
            type: GRAVEL_BLOCK
        }
        {
            class: io.github.game.Level$PlatformData
            x: 416
            y: 160
            width: 32
            height: 32
            type: GRAVEL_BLOCK
        }
        {
            class: io.github.game.Level$PlatformData
            x: 448
            y: 192
            width: 32
            height: 32
            type: GRAVEL_BLOCK
        }
        {
            class: io.github.game.Level$PlatformData
            x: 480
            y: 160
            width: 32
            height: 32
            type: GRAVEL_BLOCK
        }
        {
            class: io.github.game.Level$PlatformData
            x: 544
            y: 160
            width: 32
            height: 32
            type: GRAVEL_BLOCK
        }
        {
            class: io.github.game.Level$PlatformData
            x: 576
            y: 128
            width: 32
            height: 32
            type: QUESTION_BLOCK
        }
        {
            class: io.github.game.Level$PlatformData
            x: 640
            y: 128
            width: 32
            height: 32
            type: COIN
        }
        {
            class: io.github.game.Level$PlatformData
            x: 672
            y: 128
            width: 32
            height: 32
            type: COIN
        }
        {
            class: io.github.game.Level$PlatformData
            x: 704
            y: 128
            width: 32
            height: 32
            type: COIN
        }
    ]
    enemies: [
        {
            class: io.github.game.Level$EnemyData
            x: 544
            y: 64
            type: GOOMBA
        }
    ]
    questionBlockContents: {}
    }

    ================
    File: lwjgl3/build.gradle
    ================
    buildscript {
      repositories {
        gradlePluginPortal()
      }
      dependencies {
        classpath "io.github.fourlastor:construo:1.7.1"
        if(enableGraalNative == 'true') {
          classpath "org.graalvm.buildtools.native:org.graalvm.buildtools.native.gradle.plugin:0.9.28"
        }
      }
    }
    plugins {
      id "application"
    }
    apply plugin: 'io.github.fourlastor.construo'


    import io.github.fourlastor.construo.Target

    sourceSets.main.resources.srcDirs += [ rootProject.file('assets').path ]
    mainClassName = 'io.github.game.lwjgl3.Lwjgl3Launcher'
    application.setMainClass(mainClassName)
    eclipse.project.name = appName + '-lwjgl3'
    java.sourceCompatibility = 8
    java.targetCompatibility = 8
    if (JavaVersion.current().isJava9Compatible()) {
            compileJava.options.release.set(8)
    }

    dependencies {
      implementation "com.badlogicgames.gdx:gdx-backend-lwjgl3:$gdxVersion"
      implementation "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-desktop"
      implementation "com.crashinvaders.basisu:basisu-wrapper:$gdxBasisUniversalVersion:natives-desktop"
      implementation project(':core')

      if(enableGraalNative == 'true') {
        implementation "io.github.berstanio:gdx-svmhelper-backend-lwjgl3:$graalHelperVersion"

        }
    }

    def os = System.properties['os.name'].toLowerCase()

    run {
      workingDir = rootProject.file('assets').path
    // You can uncomment the next line if your IDE claims a build failure even when the app closed properly.
      //setIgnoreExitValue(true)

      if (os.contains('mac')) jvmArgs += "-XstartOnFirstThread"
    }

    jar {
    // sets the name of the .jar file this produces to the name of the game or app, with the version after.
      archiveFileName.set("${appName}-${projectVersion}.jar")
    // the duplicatesStrategy matters starting in Gradle 7.0; this setting works.
      duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
      dependsOn configurations.runtimeClasspath
      from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    // these "exclude" lines remove some unnecessary duplicate files in the output JAR.
      exclude('META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
      dependencies {
        exclude('META-INF/INDEX.LIST', 'META-INF/maven/**')
      }
    // setting the manifest makes the JAR runnable.
      manifest {
        attributes 'Main-Class': project.mainClassName
      }
    // this last step may help on some OSes that need extra instruction to make runnable JARs.
      doLast {
        file(archiveFile).setExecutable(true, false)
      }
    }

    // Builds a JAR that only includes the files needed to run on macOS, not Windows or Linux.
    // The file size for a Mac-only JAR is about 7MB smaller than a cross-platform JAR.
    tasks.register("jarMac") {
      dependsOn("jar")
      group("build")
      jar.archiveFileName.set("${appName}-${projectVersion}-mac.jar")
      jar.exclude("windows/x86/**", "windows/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**", "**/*.dll", "**/*.so",
        'META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
      dependencies {
        jar.exclude("windows/x86/**", "windows/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**",
          'META-INF/INDEX.LIST', 'META-INF/maven/**')
      }
    }

    // Builds a JAR that only includes the files needed to run on Linux, not Windows or macOS.
    // The file size for a Linux-only JAR is about 5MB smaller than a cross-platform JAR.
    tasks.register("jarLinux") {
      dependsOn("jar")
      group("build")
      jar.archiveFileName.set("${appName}-${projectVersion}-linux.jar")
      jar.exclude("windows/x86/**", "windows/x64/**", "macos/arm64/**", "macos/x64/**", "**/*.dll", "**/*.dylib",
        'META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
      dependencies {
        jar.exclude("windows/x86/**", "windows/x64/**", "macos/arm64/**", "macos/x64/**",
          'META-INF/INDEX.LIST', 'META-INF/maven/**')
      }
    }

    // Builds a JAR that only includes the files needed to run on Windows, not Linux or macOS.
    // The file size for a Windows-only JAR is about 6MB smaller than a cross-platform JAR.
    tasks.register("jarWin") {
      dependsOn("jar")
      group("build")
      jar.archiveFileName.set("${appName}-${projectVersion}-win.jar")
      jar.exclude("macos/arm64/**", "macos/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**", "**/*.dylib", "**/*.so",
        'META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
      dependencies {
        jar.exclude("macos/arm64/**", "macos/x64/**", "linux/arm32/**", "linux/arm64/**", "linux/x64/**",
          'META-INF/INDEX.LIST', 'META-INF/maven/**')
      }
    }

    construo {
        // name of the executable
        name.set(appName)
        // human-readable name, used for example in the `.app` name for macOS
        humanName.set(appName)
        // Optional, defaults to project version property
        version.set("$projectVersion")

        targets.configure {
          create("linuxX64", Target.Linux) {
            architecture.set(Target.Architecture.X86_64)
            jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_x64_linux_hotspot_17.0.15_6.tar.gz")
            // Linux does not currently have a way to set the icon on the executable
          }
          create("macM1", Target.MacOs) {
            architecture.set(Target.Architecture.AARCH64)
            jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_aarch64_mac_hotspot_17.0.15_6.tar.gz")
            // macOS needs an identifier
            identifier.set("io.github.game." + appName)
            // Optional: icon for macOS, as an ICNS file
            macIcon.set(project.file("icons/logo.icns"))
          }
          create("macX64", Target.MacOs) {
            architecture.set(Target.Architecture.X86_64)
            jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_x64_mac_hotspot_17.0.15_6.tar.gz")
            // macOS needs an identifier
            identifier.set("io.github.game." + appName)
            // Optional: icon for macOS, as an ICNS file
            macIcon.set(project.file("icons/logo.icns"))
          }
          create("winX64", Target.Windows) {
            architecture.set(Target.Architecture.X86_64)
            // Optional: icon for Windows, as a PNG
            icon.set(project.file("icons/logo.png"))
            jdkUrl.set("https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.15%2B6/OpenJDK17U-jdk_x64_windows_hotspot_17.0.15_6.zip")
            // Uncomment the next line to show a console when the game runs, to print messages.
            //useConsole.set(true)
          }
        }
    }

    // Equivalent to the jar task; here for compatibility with gdx-setup.
    tasks.register('dist') {
      dependsOn 'jar'
    }

    distributions {
      main {
        contents {
          into('libs') {
            project.configurations.runtimeClasspath.files.findAll { file ->
              file.getName() != project.tasks.jar.outputs.files.singleFile.name
            }.each { file ->
              exclude file.name
            }
          }
        }
      }
    }

    startScripts.dependsOn(':lwjgl3:jar')
    startScripts.classpath = project.tasks.jar.outputs.files

    if(enableGraalNative == 'true') {
      apply from: file("nativeimage.gradle")
    }

    ================
    File: lwjgl3/nativeimage.gradle
    ================
    project(":lwjgl3") {
      apply plugin: "org.graalvm.buildtools.native"

      graalvmNative {
        binaries {
          main {
            imageName = appName
            mainClass = project.mainClassName
            requiredVersion = '23.0'
            buildArgs.add("-march=compatibility")
            jvmArgs.addAll("-Dfile.encoding=UTF8")
            sharedLibrary = false
            resources.autodetect()
          }
        }
      }

      run {
        doNotTrackState("Running the app should not be affected by Graal.")
      }

      // Modified from https://lyze.dev/2021/04/29/libGDX-Internal-Assets-List/ ; thanks again, Lyze!
      // This creates a resource-config.json file based on the contents of the assets folder (and the libGDX icons).
      // This file is used by Graal Native to embed those specific files.
      // This has to run before nativeCompile, so it runs at the start of an unrelated resource-handling command.
      generateResourcesConfigFile.doFirst {
        def assetsFolder = new File("${project.rootDir}/assets/")
        def lwjgl3 = project(':lwjgl3')
        def resFolder = new File("${lwjgl3.projectDir}/src/main/resources/META-INF/native-image/${lwjgl3.ext.appName}")
        resFolder.mkdirs()
        def resFile = new File(resFolder, "resource-config.json")
        resFile.delete()
        resFile.append(
                """{
      "resources":{
      "includes":[
        {
          "pattern": ".*(""")
        // This adds every filename in the assets/ folder to a pattern that adds those files as resources.
        fileTree(assetsFolder).each {
          // The backslash-Q and backslash-E escape the start and end of a literal string, respectively.
          resFile.append("\\\\Q${it.name}\\\\E|")
        }
        // We also match all of the window icon images this way and the font files that are part of libGDX.
        resFile.append(
                """libgdx.+\\\\.png|lsans.+)"
        }
      ]},
      "bundles":[]
    }"""
        )
      }
    }

    ================
    File: lwjgl3/src/main/java/io/github/game/lwjgl3/Lwjgl3Launcher.java
    ================
    package io.github.game.lwjgl3;

    import com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application;
    import com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration;
    import io.github.game.Main;

    /** Launches the desktop (LWJGL3) application. */
    public class Lwjgl3Launcher {
        public static void main(String[] args) {
            if (StartupHelper.startNewJvmIfRequired()) return; // This handles macOS support and helps on Windows.
            createApplication();
        }

        private static Lwjgl3Application createApplication() {
            return new Lwjgl3Application(new Main(), getDefaultConfiguration());
        }

        private static Lwjgl3ApplicationConfiguration getDefaultConfiguration() {
            Lwjgl3ApplicationConfiguration configuration = new Lwjgl3ApplicationConfiguration();
            configuration.setTitle("Mario");
            //// Vsync limits the frames per second to what your hardware can display, and helps eliminate
            //// screen tearing. This setting doesn't always work on Linux, so the line after is a safeguard.
            configuration.useVsync(true);
            //// Limits FPS to the refresh rate of the currently active monitor, plus 1 to try to match fractional
            //// refresh rates. The Vsync setting above should limit the actual FPS to match the monitor.
            configuration.setForegroundFPS(Lwjgl3ApplicationConfiguration.getDisplayMode().refreshRate + 1);
            //// If you remove the above line and set Vsync to false, you can get unlimited FPS, which can be
            //// useful for testing performance, but can also be very stressful to some hardware.
            //// You may also need to configure GPU drivers to fully disable Vsync; this can cause screen tearing.

            configuration.setWindowedMode(640, 480);
            //// You can change these files; they are in lwjgl3/src/main/resources/ .
            //// They can also be loaded from the root of assets/ .
            configuration.setWindowIcon("libgdx128.png", "libgdx64.png", "libgdx32.png", "libgdx16.png");
            return configuration;
        }
    }

    ================
    File: lwjgl3/src/main/java/io/github/game/lwjgl3/StartupHelper.java
    ================
    /*
     * Copyright 2020 damios
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at:
     * https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    //Note, the above license and copyright applies to this file only.

    package io.github.game.lwjgl3;

    import com.badlogic.gdx.Version;
    import com.badlogic.gdx.backends.lwjgl3.Lwjgl3NativesLoader;
    import org.lwjgl.system.macosx.LibC;
    import org.lwjgl.system.macosx.ObjCRuntime;

    import java.io.BufferedReader;
    import java.io.File;
    import java.io.InputStreamReader;
    import java.lang.management.ManagementFactory;
    import java.util.ArrayList;

    import static org.lwjgl.system.JNI.invokePPP;
    import static org.lwjgl.system.JNI.invokePPZ;
    import static org.lwjgl.system.macosx.ObjCRuntime.objc_getClass;
    import static org.lwjgl.system.macosx.ObjCRuntime.sel_getUid;

    /**
     * Adds some utilities to ensure that the JVM was started with the
     * {@code -XstartOnFirstThread} argument, which is required on macOS for LWJGL 3
     * to function. Also helps on Windows when users have names with characters from
     * outside the Latin alphabet, a common cause of startup crashes.
     * <br>
     * <a href="https://jvm-gaming.org/t/starting-jvm-on-mac-with-xstartonfirstthread-programmatically/57547">Based on this java-gaming.org post by kappa</a>
     * @author damios
     */
    public class StartupHelper {

        private static final String JVM_RESTARTED_ARG = "jvmIsRestarted";

        private StartupHelper() {
            throw new UnsupportedOperationException();
        }

        /**
         * Starts a new JVM if the application was started on macOS without the
         * {@code -XstartOnFirstThread} argument. This also includes some code for
         * Windows, for the case where the user's home directory includes certain
         * non-Latin-alphabet characters (without this code, most LWJGL3 apps fail
         * immediately for those users). Returns whether a new JVM was started and
         * thus no code should be executed.
         * <p>
         * <u>Usage:</u>
         *
         * <pre><code>
         * public static void main(String... args) {
         * 	if (StartupHelper.startNewJvmIfRequired(true)) return; // This handles macOS support and helps on Windows.
         * 	// after this is the actual main method code
         * }
         * </code></pre>
         *
         * @param redirectOutput
         *            whether the output of the new JVM should be rerouted to the
         *            old JVM, so it can be accessed in the same place; keeps the
         *            old JVM running if enabled
         * @return whether a new JVM was started and thus no code should be executed
         *         in this one
         */
        public static boolean startNewJvmIfRequired(boolean redirectOutput) {
            String osName = System.getProperty("os.name").toLowerCase();
            if (!osName.contains("mac")) {
                if (osName.contains("windows")) {
    // Here, we are trying to work around an issue with how LWJGL3 loads its extracted .dll files.
    // By default, LWJGL3 extracts to the directory specified by "java.io.tmpdir", which is usually the user's home.
    // If the user's name has non-ASCII (or some non-alphanumeric) characters in it, that would fail.
    // By extracting to the relevant "ProgramData" folder, which is usually "C:\ProgramData", we avoid this.
    // We also temporarily change the "user.name" property to one without any chars that would be invalid.
    // We revert our changes immediately after loading LWJGL3 natives.
                    String programData = System.getenv("ProgramData");
                    if(programData == null) programData = "C:\\Temp\\"; // if ProgramData isn't set, try some fallback.
                    String prevTmpDir = System.getProperty("java.io.tmpdir", programData);
                    String prevUser = System.getProperty("user.name", "libGDX_User");
                    System.setProperty("java.io.tmpdir", programData + "/libGDX-temp");
                    System.setProperty("user.name", ("User_" + prevUser.hashCode() + "_GDX" + Version.VERSION).replace('.', '_'));
                    Lwjgl3NativesLoader.load();
                    System.setProperty("java.io.tmpdir", prevTmpDir);
                    System.setProperty("user.name", prevUser);
                }
                return false;
            }

            // There is no need for -XstartOnFirstThread on Graal native image
            if (!System.getProperty("org.graalvm.nativeimage.imagecode", "").isEmpty()) {
                return false;
            }

            // Checks if we are already on the main thread, such as from running via Construo.
            long objc_msgSend = ObjCRuntime.getLibrary().getFunctionAddress("objc_msgSend");
            long NSThread      = objc_getClass("NSThread");
            long currentThread = invokePPP(NSThread, sel_getUid("currentThread"), objc_msgSend);
            boolean isMainThread = invokePPZ(currentThread, sel_getUid("isMainThread"), objc_msgSend);
            if(isMainThread) return false;

            long pid = LibC.getpid();

            // check whether -XstartOnFirstThread is enabled
            if ("1".equals(System.getenv("JAVA_STARTED_ON_FIRST_THREAD_" + pid))) {
                return false;
            }

            // check whether the JVM was previously restarted
            // avoids looping, but most certainly leads to a crash
            if ("true".equals(System.getProperty(JVM_RESTARTED_ARG))) {
                System.err.println(
                        "There was a problem evaluating whether the JVM was started with the -XstartOnFirstThread argument.");
                return false;
            }

            // Restart the JVM with -XstartOnFirstThread
            ArrayList<String> jvmArgs = new ArrayList<>();
            String separator = System.getProperty("file.separator", "/");
            // The following line is used assuming you target Java 8, the minimum for LWJGL3.
            String javaExecPath = System.getProperty("java.home") + separator + "bin" + separator + "java";
            // If targeting Java 9 or higher, you could use the following instead of the above line:
            //String javaExecPath = ProcessHandle.current().info().command().orElseThrow();

            if (!(new File(javaExecPath)).exists()) {
                System.err.println(
                        "A Java installation could not be found. If you are distributing this app with a bundled JRE, be sure to set the -XstartOnFirstThread argument manually!");
                return false;
            }

            jvmArgs.add(javaExecPath);
            jvmArgs.add("-XstartOnFirstThread");
            jvmArgs.add("-D" + JVM_RESTARTED_ARG + "=true");
            jvmArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());
            jvmArgs.add("-cp");
            jvmArgs.add(System.getProperty("java.class.path"));
            String mainClass = System.getenv("JAVA_MAIN_CLASS_" + pid);
            if (mainClass == null) {
                StackTraceElement[] trace = Thread.currentThread().getStackTrace();
                if (trace.length > 0) {
                    mainClass = trace[trace.length - 1].getClassName();
                } else {
                    System.err.println("The main class could not be determined.");
                    return false;
                }
            }
            jvmArgs.add(mainClass);

            try {
                if (!redirectOutput) {
                    ProcessBuilder processBuilder = new ProcessBuilder(jvmArgs);
                    processBuilder.start();
                } else {
                    Process process = (new ProcessBuilder(jvmArgs))
                            .redirectErrorStream(true).start();
                    BufferedReader processOutput = new BufferedReader(
                            new InputStreamReader(process.getInputStream()));
                    String line;

                    while ((line = processOutput.readLine()) != null) {
                        System.out.println(line);
                    }

                    process.waitFor();
                }
            } catch (Exception e) {
                System.err.println("There was a problem restarting the JVM");
                e.printStackTrace();
            }

            return true;
        }

        /**
         * Starts a new JVM if the application was started on macOS without the
         * {@code -XstartOnFirstThread} argument. Returns whether a new JVM was
         * started and thus no code should be executed. Redirects the output of the
         * new JVM to the old one.
         * <p>
         * <u>Usage:</u>
         *
         * <pre>
         * public static void main(String... args) {
         * 	if (StartupHelper.startNewJvmIfRequired()) return; // This handles macOS support and helps on Windows.
         * 	// the actual main method code
         * }
         * </pre>
         *
         * @return whether a new JVM was started and thus no code should be executed
         *         in this one
         */
        public static boolean startNewJvmIfRequired() {
            return startNewJvmIfRequired(true);
        }
    }

    ================
    File: README.md
    ================
    # Mario

    A [libGDX](https://libgdx.com/) project generated with [gdx-liftoff](https://github.com/libgdx/gdx-liftoff).

    This project was generated with a template including simple application launchers and an `ApplicationAdapter` extension that draws libGDX logo.

    ## Platforms

    - `core`: Main module with the application logic shared by all platforms.
    - `lwjgl3`: Primary desktop platform using LWJGL3; was called 'desktop' in older docs.
    - `html`: Web platform using GWT and WebGL. Supports only Java projects.
    - `server`: A separate application without access to the `core` module.

    ## Gradle

    This project uses [Gradle](https://gradle.org/) to manage dependencies.
    The Gradle wrapper was included, so you can run Gradle tasks using `gradlew.bat` or `./gradlew` commands.
    Useful Gradle tasks and flags:

    - `--continue`: when using this flag, errors will not stop the tasks from running.
    - `--daemon`: thanks to this flag, Gradle daemon will be used to run chosen tasks.
    - `--offline`: when using this flag, cached dependency archives will be used.
    - `--refresh-dependencies`: this flag forces validation of all dependencies. Useful for snapshot versions.
    - `build`: builds sources and archives of every project.
    - `cleanEclipse`: removes Eclipse project data.
    - `cleanIdea`: removes IntelliJ project data.
    - `clean`: removes `build` folders, which store compiled classes and built archives.
    - `eclipse`: generates Eclipse project data.
    - `html:dist`: compiles GWT sources. The compiled application can be found at `html/build/dist`: you can use any HTTP server to deploy it.
    - `html:superDev`: compiles GWT sources and runs the application in SuperDev mode. It will be available at [localhost:8080/html](http://localhost:8080/html). Use only during development.
    - `idea`: generates IntelliJ project data.
    - `lwjgl3:jar`: builds application's runnable jar, which can be found at `lwjgl3/build/libs`.
    - `lwjgl3:run`: starts the application.
    - `server:run`: runs the server application.
    - `test`: runs unit tests (if any).

    Note that most tasks that are not specific to a single project can be run with `name:` prefix, where the `name` should be replaced with the ID of a specific project.
    For example, `core:clean` removes `build` folder only from the `core` project.

    ================
    File: server/build.gradle
    ================
    apply plugin: 'application'


    java.sourceCompatibility = 8
    java.targetCompatibility = 8
    if (JavaVersion.current().isJava9Compatible()) {
            compileJava.options.release.set(8)
    }

    mainClassName = 'io.github.game.server.ServerLauncher'
    application.setMainClass(mainClassName)
    eclipse.project.name = appName + '-server'

    dependencies {

    }

    jar {
      archiveBaseName.set(appName)
    // the duplicatesStrategy matters starting in Gradle 7.0; this setting works.
      duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
      dependsOn configurations.runtimeClasspath
      from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    // these "exclude" lines remove some unnecessary duplicate files in the output JAR.
      exclude('META-INF/INDEX.LIST', 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA')
      dependencies {
        exclude('META-INF/INDEX.LIST', 'META-INF/maven/**')
      }
    // setting the manifest makes the JAR runnable.
      manifest {
        attributes 'Main-Class': project.mainClassName
      }
    // this last step may help on some OSes that need extra instruction to make runnable JARs.
      doLast {
        file(archiveFile).setExecutable(true, false)
      }
    }

    // Equivalent to the jar task; here for compatibility with gdx-setup.
    task dist(dependsOn: [jar]) {
    }

    ================
    File: server/src/main/java/io/github/game/server/ServerLauncher.java
    ================
    package io.github.game.server;

    /** Launches the server application. */
    public class ServerLauncher {
        public static void main(String[] args) {
            // TODO Implement server application.
        }
    }

    ================
    File: settings.gradle
    ================
    plugins {
      // Applies the foojay-resolver plugin to allow automatic download of JDKs.
      id("org.gradle.toolchains.foojay-resolver-convention") version "0.9.0"
    }
    // A list of which subprojects to load as part of the same larger project.
    // You can remove Strings from the list and reload the Gradle project
    // if you want to temporarily disable a subproject.
    include 'lwjgl3', 'server', 'html', 'core'
